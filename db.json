{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"source/uploads/avatar.jpg","path":"uploads/avatar.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/images/forkMeOnGithub.png","path":"images/forkMeOnGithub.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"c2c749da5f1d9a4235a9ec5a90b1c2eca28b398c","modified":1492273323370},{"_id":"source/favicon.ico","hash":"158a13168976f0520cbebcd50a4561f5a3c660b6","modified":1492319321464},{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1492179463814},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1492179463815},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1492179463815},{"_id":"themes/next/.gitignore","hash":"de5b9b9e5b313b4a86e805b02f334d35c87bfe56","modified":1492179463817},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1492179463818},{"_id":"themes/next/.javascript_ignore","hash":"74b54cf920cbbf4038a68e54b7138af8b8f45588","modified":1492179463818},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1492179463819},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1492179463819},{"_id":"themes/next/.travis.yml","hash":"360f38044910e74bf628b0799e19db90718b2cbe","modified":1492179463820},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1492179463820},{"_id":"themes/next/README.en.md","hash":"953873fe2ee79bfc567b16dcdf8f91c1410444f8","modified":1492179463821},{"_id":"themes/next/README.md","hash":"06aaf1241e9e1619956c86d8b1397a643840a9d1","modified":1492179463822},{"_id":"themes/next/_config.yml","hash":"e4b33229548861ea04091b5e034c62af4db2e20d","modified":1492409510965},{"_id":"themes/next/bower.json","hash":"bd70cf5988bbfc8cbcf13adae659151a55466524","modified":1492179463823},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1492179463823},{"_id":"themes/next/package.json","hash":"a5c189d4c4e946e936d3b5e29e2d81ddaf03ff96","modified":1492179463870},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-1-一切都是对象.md","hash":"51cde5e6d3518f31565771a141587e6d68ee5a46","modified":1492364286342},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-2-函数和对象的关系.md","hash":"4e9f46442e5dd44178bf8557d464989b25e1b036","modified":1492364333273},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-3-prototype原型.md","hash":"e543268d55909bc77a64be6c9839d0e4aeaeddf6","modified":1492364347081},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-4-隐式原型.md","hash":"e79f113c3b742e177b0239af697b2a955692e282","modified":1492364377962},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-5-instanceof.md","hash":"d26b66e744fedc582e8236457429500832cdf768","modified":1492364390500},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-6-继承.md","hash":"0bdb7fda26e27d015268fe0bb159898576ab829f","modified":1492364400937},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-7-原型的灵活性.md","hash":"e16bf015adefb8649cbf58d3e6eb235f0d035f00","modified":1492364417673},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-8-简述【执行上下文】上.md","hash":"b19d8c7b6f09cb97cec9bd67b3de1b840b786727","modified":1492364437429},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-9-简述【执行上下文】下.md","hash":"8de0785d0737714cbb5294967709de0bde033c3f","modified":1492364449435},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-10-this.md","hash":"00774b76881e908c18d7e8a322b29d6d21d2cf68","modified":1492364459188},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-11-执行上下文栈.md","hash":"35d8e4aa5b17224a449c33bba93ffcaa09f7b4a1","modified":1492364472722},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-12-简介【作用域】.md","hash":"cc9e505ea3709378fcd055f43c3f7470f125f502","modified":1492364493236},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-13-【作用域】和【上下文环境】.md","hash":"7f2d1aaa8420246fc24045cf7bb664fe58f49883","modified":1492364508209},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-14-从【自由变量】和【作用域链】.md","hash":"d9de200ea6de0243be354ac45aa39e8c58491108","modified":1492364519457},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-15-闭包.md","hash":"7327653d8cb8387ea9844f0f94124c85654afab2","modified":1492364528125},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系.md","hash":"c92be8ba6677eaaf1b03cb88a3eb2bc6cec08322","modified":1492364544144},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包引言和目录.md","hash":"259987e219dde87d4417c846bc79d56889ae6023","modified":1492401037758},{"_id":"source/_posts/hello-world.md","hash":"439d7dcb2fb3cea3028f4d43d121f25ebdedc07d","modified":1492327192668},{"_id":"source/about/index.md","hash":"a1842401d486e7abc30d5b73a19beab949b569f9","modified":1492322483851},{"_id":"source/categories/index.md","hash":"3d66055246abcaf1f405dd0f3a5358c0daa640d3","modified":1492327156655},{"_id":"source/production/index.md","hash":"0208fe0e496a57929cb2d4e47d9500f4859cc8fa","modified":1492322477277},{"_id":"source/tags/index.md","hash":"a562c0c8caedd0afb1552e8f6be091a9f9c473a7","modified":1492327240053},{"_id":"source/uploads/avatar.jpg","hash":"367c1277d84436d7e400db2326bc3655554265b3","modified":1492318959711},{"_id":"themes/next/languages/de.yml","hash":"4be3e7d296d5592e0d111dfa6cbbff02602c972d","modified":1492179463825},{"_id":"themes/next/languages/default.yml","hash":"d912814caac150da1611c96843371a87714e52f9","modified":1492179463825},{"_id":"themes/next/languages/en.yml","hash":"b3ee45143bc014578db6b8ac0573f7c7b143a743","modified":1492179463826},{"_id":"themes/next/languages/fr-FR.yml","hash":"0d5bd8bbbeafb72506124ed35e7509debc753612","modified":1492179463826},{"_id":"themes/next/languages/id.yml","hash":"c0848e93bf33a1333ff232905b6b392b1e056dd1","modified":1492179463827},{"_id":"themes/next/languages/ja.yml","hash":"1a608dc799c0f9c36b626bac6fe3404acb45b86d","modified":1492179463828},{"_id":"themes/next/languages/ko.yml","hash":"5c811514aef401317a9ec38b95679d6d2ef0ad42","modified":1492179463828},{"_id":"themes/next/languages/pt-BR.yml","hash":"cc8b5a67ec87b0d5aec6e253bab67ec3cfe3069c","modified":1492179463829},{"_id":"themes/next/languages/pt.yml","hash":"943475a7d681f37ede579cd62da9c50568ca0f8d","modified":1492179463829},{"_id":"themes/next/languages/ru.yml","hash":"84d41a111e497236b2c1fa16e9b91668a1f37037","modified":1492179463830},{"_id":"themes/next/languages/zh-Hans.yml","hash":"b4c223e1984864d324471f6c71006be12c9cf9fd","modified":1492322940592},{"_id":"themes/next/languages/zh-hk.yml","hash":"b58c0d85daa4d62b0c9753a59de0739aa0120735","modified":1492179463831},{"_id":"themes/next/languages/zh-tw.yml","hash":"8ce0a32411de111ae39d08e4bc936767dacdeb08","modified":1492179463832},{"_id":"themes/next/layout/_layout.swig","hash":"8271f63d2975d1a4479270d6c62fcd680629f9e5","modified":1492410834568},{"_id":"themes/next/layout/archive.swig","hash":"b867a08f6b43de8b5d700c84b943df55917407ae","modified":1492179463867},{"_id":"themes/next/layout/category.swig","hash":"58cf08388901f7549b1fca95548b2c79173aa840","modified":1492179463868},{"_id":"themes/next/layout/index.swig","hash":"e5b52e04296203262a400e8e36ae12426d31fd5b","modified":1492179463868},{"_id":"themes/next/layout/page.swig","hash":"2a13804aa186f6062738d136e430870c53789bf4","modified":1492179463868},{"_id":"themes/next/layout/post.swig","hash":"b8334c479840b7724638eec71971cbd8512ae58d","modified":1492179463869},{"_id":"themes/next/layout/schedule.swig","hash":"459cd6d9887b7a2ebda9ba3a5585a718904adb02","modified":1492179463869},{"_id":"themes/next/layout/tag.swig","hash":"6f764ea3ab11eeb7c530df45528d449b14f5dc62","modified":1492179463869},{"_id":"themes/next/scripts/merge-configs.js","hash":"3ce1be32bb77ee19da25e8dae7dc04e2afc46ca1","modified":1492179463870},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1492179463872},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1492179463992},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1492179463993},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1492179463993},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1492179463924},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-1-一切都是对象/1-1.png","hash":"ff0cdaf7778265b52e9b6706753c5ea4dbdc5dee","modified":1492348198204},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-3-prototype原型/3-1.png","hash":"d0c6d67f117f19eeda50fd593cc1014fa75f3803","modified":1492352777577},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-3-prototype原型/3-2.png","hash":"6cdeed2018010c3cf34b5c80886c88c2f9e2f038","modified":1492352914422},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-3-prototype原型/3-3.png","hash":"4662ec06c30582d99d4cd8bdc108a7d2059cc95e","modified":1492353015761},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-4-隐式原型/4-1.png","hash":"ded99a25d92c312822f8fd4123c992302bb98197","modified":1492353597261},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-4-隐式原型/4-2.png","hash":"913ed7694fa146426d21a5b845e83a7be39147bb","modified":1492353667903},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-4-隐式原型/4-4.png","hash":"a67484de0f4b28ccce72359476c3adde6b1ab13d","modified":1492354034589},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-4-隐式原型/4-6.png","hash":"3ba945539126b9bd93e0b980385c31c69652ee57","modified":1492354339890},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-5-instanceof/5-1.png","hash":"1876af6f0907d5f6dea33a805378ed463c2ff8aa","modified":1492354694245},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-6-继承/6-1.png","hash":"b2965e59ecb843aa7fb775afc36480313ec68cf5","modified":1492355382989},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-6-继承/6-2.png","hash":"60e5cfe8fd6ff448c2b66f6dd0175ba55829bd4c","modified":1492355444882},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-6-继承/6-4.png","hash":"f9c12de21a41238620bd5ba09ed62cacbc2dfe61","modified":1492355588785},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-7-原型的灵活性/7-1.png","hash":"91454a713d0dd6e9497974ef80ed605301b1c15a","modified":1492355778368},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-7-原型的灵活性/7-2.png","hash":"acafa14137a3f6d9b9db8f0267f65b7b820bd7a7","modified":1492356085624},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-8-简述【执行上下文】上/8-1.png","hash":"e0f4185bbc34774cfec67b570007ad2d844af2ee","modified":1492356281013},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-8-简述【执行上下文】上/8-2.png","hash":"7b0309d32c5dc411d37937a33d99f3ce55a5c05c","modified":1492356333931},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-8-简述【执行上下文】上/8-3.png","hash":"96078d248a5a2abe28aca1ff5430852e3006109a","modified":1492356370926},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-8-简述【执行上下文】上/8-4.png","hash":"43cabaaad6714ffad5648e5251ea92fba18bc9b6","modified":1492356452594},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-8-简述【执行上下文】上/8-5.png","hash":"bea80bf46b4ade26e863d1167bf42c7f8e85ac85","modified":1492357050112},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-8-简述【执行上下文】上/8-6.png","hash":"6cb84b0de56592fd44a818ff5161e05aeade3df2","modified":1492357189452},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-9-简述【执行上下文】下/9-1.png","hash":"2d48783d8535f1afbd48fc5352d7e1f33efd21ae","modified":1492357447455},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-9-简述【执行上下文】下/9-2.png","hash":"08a4772ef0a541c53bc3bafd828c9fc4eed56f20","modified":1492357584899},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-10-this/10-1.png","hash":"ea9039112c3f3e417e82fddb16108eaccf04df76","modified":1492359055296},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-10-this/10-2.png","hash":"706dd7ed31bcaf0c25c0343c6d7b6f44a4c0fbea","modified":1492359108924},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-10-this/10-3.png","hash":"47de71fd746fbe77f2e09d567a4856cb99e4bb24","modified":1492359183738},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-10-this/10-4.png","hash":"121821fcfa0d5e5fd51bd1576662773bf15fc38f","modified":1492359248971},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-10-this/10-5.png","hash":"b869a88b3d749418f374f2ab4274389657fe11d7","modified":1492359311697},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-10-this/10-6.png","hash":"59d5daceda5402bfbbf1cd03fb327f8bc72c2cfd","modified":1492359406495},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-10-this/10-7.png","hash":"c77b6cbfd1e9311b79d4d8ba56121e5f375750c7","modified":1492359466382},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-10-this/10-8.png","hash":"e7cff8e085076a1ec8ae040f804deb5ba784f33c","modified":1492359516177},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-10-this/10-9.png","hash":"8486b2254aa2c46195f85e14a959d1df2da42c17","modified":1492359677494},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-11-执行上下文栈/11-1.png","hash":"6041d80cc2741e142b8530348a5fcb13fb292e5d","modified":1492360246781},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-11-执行上下文栈/11-2.png","hash":"ef8d97e59712016fa1e6b7a5c1f2235869946153","modified":1492360300588},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-11-执行上下文栈/11-3.png","hash":"58009b232e130da5182caf23ebd2f7975a7a0d2e","modified":1492360344929},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-11-执行上下文栈/11-4.png","hash":"f73282808ff51aee0096176ab3169e2abbf05e5d","modified":1492360388644},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-11-执行上下文栈/11-5.png","hash":"47690aee78d0afa4564e0f5a6db453b23159a86d","modified":1492360426692},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-11-执行上下文栈/11-6.png","hash":"f6addd2d137f52c6bd80b7af9a689a79b6d22f9d","modified":1492360463676},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-11-执行上下文栈/11-7.png","hash":"8acc5cfc592ad1068167d0c020d5dc90dff54add","modified":1492360509336},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-11-执行上下文栈/11-8.png","hash":"e1cee4c79029bc31a875843644bbfe2129cb0edf","modified":1492360549453},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-11-执行上下文栈/11-9.png","hash":"3dadea7ed800d2f731f85af9b6e7e85d3fccf073","modified":1492360662159},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-12-简介【作用域】/12-1.png","hash":"10b3375a1fea7d5b8aeb07778e2cfd9509b18f8c","modified":1492361159982},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-12-简介【作用域】/12-2.png","hash":"bb1fd2adb0f37aea8b12dec2a1493a32614b7625","modified":1492361211044},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-12-简介【作用域】/12-3.png","hash":"7e4d5323fb683903b6aaa5a93bd20e2bdb350e54","modified":1492361335018},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-1.png","hash":"25216e9b9996693b3458617359c040e96a293634","modified":1492361562610},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-2.png","hash":"ede30d068dd7deba8ca1f03d4400b8961aa7d6e1","modified":1492361719999},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-3.png","hash":"4e67e25472fe755cc4ca3de14110b3e9bb878d14","modified":1492361758529},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-4.png","hash":"74718eb7bd9fb33cd5d4e0c092675b29111e21f2","modified":1492361806546},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-5.png","hash":"c79124d4d95a727906a7ed68d2391a0962f48bfc","modified":1492361860533},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-6.png","hash":"8dadb472dd4d8bb29223673887258867b187712c","modified":1492361901245},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-7.png","hash":"32cee111ffcfae235d13850ab1beca836ac9e339","modified":1492361963609},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-8.png","hash":"047a5c98359b4ea95ad761a5e9a299a74cf7832c","modified":1492362003125},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-14-从【自由变量】和【作用域链】/14-1.png","hash":"8a9d6a0681cac72f68cab041bf7be169412c2f91","modified":1492362404989},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-14-从【自由变量】和【作用域链】/14-2.png","hash":"6f8028da9665cfec2ea2121eacf47ba8926a0959","modified":1492362476828},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-14-从【自由变量】和【作用域链】/14-3.png","hash":"53bd1c969dc1615992e26dbcbd3c6bb3db74dd70","modified":1492362734161},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-15-闭包/15-1.png","hash":"37f4557c5beda3cae8aa67bcfb71cc90344986f3","modified":1492362919548},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-15-闭包/15-2.png","hash":"eaf9b9aaff5b271fcd3e75736324effd4b9e81c5","modified":1492362979074},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-15-闭包/15-3.png","hash":"0f9b94f35d270374eb96337d653575ed17995d3a","modified":1492363234019},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-15-闭包/15-4.png","hash":"2b30e5cfb61676ea89a8e5f490ba79ea97203326","modified":1492363286939},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-15-闭包/15-5.png","hash":"79521d5af27eaf2cc84a4f4d980f15fbaaf171cc","modified":1492363322364},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-15-闭包/15-6.png","hash":"73e55825f6a2813fb120785944e50f2e9cb8feae","modified":1492363358337},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-15-闭包/15-7.png","hash":"c9f00f3704a0fefa2256b866f6fb70fdb85c4961","modified":1492363398986},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系/16-1.png","hash":"bcd320e9cdc1dd67ee81bd8f60db5402f78fbc2e","modified":1492363850333},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系/16-2.png","hash":"190f8bcc79729088efdd8fa6bb6071a566f6e116","modified":1492363919012},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系/16-3.png","hash":"4e55af15b34bb3aa67ef86f1d3fed63a9e2d3e2f","modified":1492363972548},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系/16-4.png","hash":"c39df2b10a9a4982f7d7683077f65c80bcf2c75a","modified":1492364002920},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系/16-5.png","hash":"2ce6d084035eba435ad625f8282dd6548c16d7a7","modified":1492364082012},{"_id":"source/js/canvas_nest/index.js","hash":"0e0e5dc012fc9484f0a8c7e0cadd35c884d95f24","modified":1492337793493},{"_id":"themes/next/layout/_custom/canvas_nest.swig","hash":"aea36a2120344eec27e2b2d700b530855577ba37","modified":1492337609268},{"_id":"themes/next/layout/_custom/header.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1492410430183},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"2e69c509506eec705d3c69ca21a09308025ed638","modified":1492322038983},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"6d40652784585d263c37b8a3723e43e04b926ca7","modified":1492179463835},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"506feb56e9b1091187d2014742f63a17758df933","modified":1492179463835},{"_id":"themes/next/layout/_macro/post.swig","hash":"79851872b6b4fbd24e4a5a946f263da85b0c265d","modified":1492179463836},{"_id":"themes/next/layout/_macro/reward.swig","hash":"b6cb171f0ed227b82b8f7601814af2df93f3a09a","modified":1492179463837},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"911b99ba0445b2c07373128d87a4ef2eb7de341a","modified":1492322038924},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"c5cc0070ca7c9a8dbd4b09e0398db536c3cdbe8a","modified":1492179463838},{"_id":"themes/next/layout/_partials/comments.swig","hash":"5258c03149aa18e9abfeb8de10e435a406d9c924","modified":1492179463839},{"_id":"themes/next/layout/_partials/footer.swig","hash":"683616f4a80796051e2346d80acf838a589450b0","modified":1492179463840},{"_id":"themes/next/layout/_partials/head.swig","hash":"376adb0c482242ef8bcad31b93b99cc5c35e92fa","modified":1492179463842},{"_id":"themes/next/layout/_partials/header.swig","hash":"d6bf1d1554d91eaf1bfc40ba8905ae81673e5f45","modified":1492179463843},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1492179463844},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1492179463844},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1492179463845},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1492179463849},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1492179463849},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"1ada0189069e17b0dc567ae4b4ee365b2ec0c7d7","modified":1492179463852},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1492179463862},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1492179463862},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1492179463863},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1492179463863},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1492179463864},{"_id":"themes/next/scripts/tags/button.js","hash":"aaf71be6b483fca7a65cd6296c2cf1c2271c26a6","modified":1492179463872},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1492179463873},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1492179463873},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1492179463874},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1492179463875},{"_id":"themes/next/scripts/tags/note.js","hash":"7dc14db08f2c74f8f1952534b424f220f5c000c6","modified":1492179463875},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1492179463923},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"16505f61f19ba65f629dfd033f14ee9abcf18756","modified":1492179463924},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1492179463925},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1492179463925},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1492179463926},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1492179463926},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1492179463927},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1492179463927},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1492179463928},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1492179463928},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1492179463929},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1492179463929},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1492179463929},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1492179463930},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1492179463930},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-4-隐式原型/4-3.png","hash":"ef638bdd10f8ffdcfda56bcbe82b9ff70936b96a","modified":1492353841482},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-4-隐式原型/4-5.png","hash":"58b34c34b90b00dfd53ca871f150f4ba1c0cb126","modified":1492354223537},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-6-继承/6-3.png","hash":"6867c68909ac6d2c17d8bcdcbf29f657693c45d6","modified":1492355531683},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1492179463851},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1492179463851},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1492179463909},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1492179463909},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1492179463910},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1492179463921},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1492179463923},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-5-instanceof/5-2.png","hash":"9ea88f3f079f9fd0143e6b140405ae1b7525b882","modified":1492354878210},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1492179463843},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1492179463843},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b6e4754498b5eeb470e11fd596227552d9070605","modified":1492179463845},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1492179463846},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1492179463846},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1492179463847},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1492179463847},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1492179463848},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"12684840de632eb16e53ffa863166306a756fd4f","modified":1492179463848},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1492179463850},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1492179463851},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1492179463853},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1492179463854},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1492179463854},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1492179463855},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a79e7e0d809fcf407593dd7ed9e023db21c3cbd6","modified":1492179463855},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1492179463855},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"441f1a1b4e2f652d3b975995bd9d44ff4866f057","modified":1492179463856},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e495aed8fb36bf8015ddbd64366270a7debad2b0","modified":1492179463856},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1492179463857},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"e9a0590dafde1046356620dd2b81e83b6b3b0936","modified":1492179463857},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1492179463858},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1492179463858},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1492179463859},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1492179463859},{"_id":"themes/next/layout/_third-party/comments/gentie.swig","hash":"0f38f053841ef77cdce56a84cfbb4dd4c3329486","modified":1492179463860},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1492179463860},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"0399bbdc524ba50930cb6f8e2d5628ff682fc612","modified":1492179463861},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"5830a52c2a555d3a1f19b67d7bf3d072376cdea9","modified":1492179463861},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"de95ec8920d1660680078451008f8bd69f14d082","modified":1492179463861},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1492179463865},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"4a10634dba16ddf2a3cbd4908dfbc97e9aa45469","modified":1492179463866},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1492179463866},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1492179463867},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"8885c6de0643763d0a49d8ebbf97773ab9fd313d","modified":1492411047738},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"a0f23e75a137d8c996c70e2059e0074f1e97a127","modified":1492179463909},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"531934ea21ef4dc9f0978512050f54834f0a6cff","modified":1492179463910},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"e55265c8a8a6ae0c3c08e3509de92ee62c3cb5f6","modified":1492179463921},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"09534b68bd1a708729b3cfffe17737e3af457757","modified":1492179463922},{"_id":"themes/next/source/css/_variables/base.styl","hash":"5b336489316d5efea069fe8bcea4479b53ec7545","modified":1492179463922},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1492179463931},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1492179463931},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0ec035e20d1f26bf553a79877180ba312bea885c","modified":1492179463931},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1492179463932},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1492179463933},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1492179463933},{"_id":"themes/next/source/js/src/motion.js","hash":"ff9ea37d05c269e3a140c4ab448af03efc4bcc76","modified":1492179463934},{"_id":"themes/next/source/js/src/post-details.js","hash":"bfaf52b69aad96566aa21b785973441a2555b4ba","modified":1492179463934},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1492179463935},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1492179463936},{"_id":"themes/next/source/js/src/utils.js","hash":"4aceddc2ca32097a9832374da232b6f76af4d5f4","modified":1492179463936},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1492179463937},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1492179463942},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ef4b2877e37d65025a28eea154b33fe66351493c","modified":1492179463942},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1492179463943},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1492179463943},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1492179463952},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1492179463952},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1492179463953},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1492179463953},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1492179463955},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1492179463956},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1492179463956},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1492179463956},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1492179463957},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1492179463974},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1492179463976},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1492179463976},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1492179463977},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1492179463977},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1492179463978},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1492179463978},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1492179463979},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1492179463987},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1492179463987},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1492179463990},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1492179463991},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1492179463992},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1492179463975},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1492179463865},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1492179463865},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"1dc2ed435e41ca041f43bd9633d5d95139afbb42","modified":1492179463877},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4ba6f2a615693b9b5afc266d9c833697016085fd","modified":1492179463877},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"22828f5141c0cecb9ef25a110e194cdfa3a36423","modified":1492179463878},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1492179463879},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1492179463879},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"88559b13ce94311405b170a0506ded91273beceb","modified":1492179463886},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1492179463896},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1492179463905},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"4998bedff9c84a09a294b8ef36ede2e3644d3528","modified":1492179463905},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1492179463906},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1492179463907},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"c9218b48c56e52c06af9ce3cc8fbdae737cf16fe","modified":1492179463907},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1492179463908},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1492179463911},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1492179463911},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1492179463912},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1492179463912},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"ce272226a1570f5f7c70243b751a5b0fe1671a88","modified":1492179463912},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1492179463913},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1492179463913},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1492179463915},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1492179463915},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"f23ac53ab901c48859dd29eee6e386b60ff956ba","modified":1492179463916},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1492179463917},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1492179463917},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1492179463918},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1492179463919},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1492179463919},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1492179463920},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"c48d4a561d047b3705924949b3ab7b57bee94ecd","modified":1492179463920},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1492179463921},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"c4358416f0a116d7f4037542fa3b385947e80908","modified":1492179463935},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1492179463944},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1492179463945},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1492179463945},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1492179463946},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1492179463946},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1492179463947},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1492179463950},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1492179463951},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1492179463951},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1492179463954},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1492179463954},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1492179463958},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1492179463959},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1492179463960},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1492179463986},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1492179463986},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1492179463972},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1492179463973},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1492179463990},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"4c4ef6e997d0c6e21de39c2daa0c768e12c8c6fa","modified":1492179463880},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1492179463880},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1492179463881},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1492179463881},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1492179463881},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1492179463882},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1492179463882},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"b3b783511bbd94af7e941abf8ff411885db7395b","modified":1492179463883},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1492179463883},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"104b5c79cd891506e0beaf938b083685f1da8637","modified":1492179463884},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1492179463884},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1492179463885},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1492179463885},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1492179463886},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"4783f85872bc7e218c1522a5c1c68cd27a5922db","modified":1492179463887},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"a45f5fce643eec4e1b927165229d560364bcace1","modified":1492179463887},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1492179463888},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1492179463888},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"fcd89ba4f6f48269e5caa73307e8689f41019896","modified":1492179463888},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1492179463889},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1492179463890},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"61ec8a8481e8b76f2943235256c6d4f89c751c1c","modified":1492179463889},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"8355b0e9375b3245508efda0e18acd069c2aa767","modified":1492179463890},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1492179463891},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"350469437b20ecfd6f3ca45e400478f8e3f71cfb","modified":1492179463891},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1492179463892},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a497ea244df7dd97d1b961412b56f94cc4031e23","modified":1492179463892},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"7f2bdd6109614d35408ee5ac3335aad4464c69c7","modified":1492179463893},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1492179463893},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"ac060861b27b764bc4012fc362a25a332df4045a","modified":1492179463894},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1492179463894},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1492179463894},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"394888efec32749b353292a59ec7f1b609d6325e","modified":1492179463895},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"c9f76d4f6806ef70fa2160c97afa0a0e0ae5373e","modified":1492179463895},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"702be9e57dd6ff5fa99642a1f6e3df26215b8805","modified":1492179463895},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1492179463896},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1492179463897},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1492179463897},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"3159b55f35c40bd08e55b00148c523760a708c51","modified":1492179463899},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1492179463900},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"8420b4be386469337243336aee694297875bd439","modified":1492179463900},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"e3ad37f2da35e330616a044621ffa50565a20c88","modified":1492179463900},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1492179463901},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1492179463901},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1492179463902},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1492179463902},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"cd526e814f9323a79fe835085d64867d34b3715d","modified":1492179463903},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1492179463903},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"6516b70ee9e44f1cf9443412cc31bcccb6cdb684","modified":1492179463904},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"dc944a01dd59f5ed2d44bb22fdb21fc3f455948f","modified":1492179463904},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1492179463914},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1492179463914},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1492179463918},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1492179463948},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1492179463947},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1492179463948},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1492179463948},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1492179463949},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1492179463949},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1492179463962},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1492179463964},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1492179463971},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1492179463941},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1492179463985},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1492179463969},{"_id":"public/js/canvas_nest/index.js","hash":"0e0e5dc012fc9484f0a8c7e0cadd35c884d95f24","modified":1492409163885},{"_id":"public/about/index.html","hash":"e31b2026f9021b0df238a79c00a6a0c0126cfa55","modified":1492409738772},{"_id":"public/categories/index.html","hash":"b37e329f0e4020497776821de8896d2e9135e33a","modified":1492409738773},{"_id":"public/production/index.html","hash":"f11985b5c49e58ba8ebef6d39ccb254e11ff4ff9","modified":1492409738773},{"_id":"public/tags/index.html","hash":"a970573f562062b43507b621e323a0d9cf2122ff","modified":1492409738773},{"_id":"public/categories/Hello-World/index.html","hash":"d621059b6e43b2306883213469a2ab33bb61967a","modified":1492409738773},{"_id":"public/tags/javascript/page/2/index.html","hash":"c9fdd09f0137945cdece4062a7e05d66645d6792","modified":1492409738776},{"_id":"public/tags/原型链/page/2/index.html","hash":"de0031b372e9f62ca18c25dcf98788763ba29784","modified":1492409738776},{"_id":"public/tags/闭包/page/2/index.html","hash":"2980856bb22456f21a90e999f67dd615b014dd57","modified":1492409738776},{"_id":"public/tags/Hello-World/index.html","hash":"f28ecef4e339377a0bd5fd22b0e50fd1c463633e","modified":1492409738774},{"_id":"public/2017/04/15/hello-world/index.html","hash":"f87b2e20bff7749937ee1441d016a4547fdb13c8","modified":1492409738774},{"_id":"public/2017/04/16/深入理解javascript原型和闭包-1-一切都是对象/index.html","hash":"f38a96ccb9394eb626b6953dab200808f5ff3ad9","modified":1492409738774},{"_id":"public/2017/04/16/深入理解javascript原型和闭包-2-函数和对象的关系/index.html","hash":"5fe458830296edefdb7cdaf7658aa266674ecd56","modified":1492409738774},{"_id":"public/2017/04/16/深入理解javascript原型和闭包-3-prototype原型/index.html","hash":"d81b7dc3f63f9896d81ce821fbdc662ca59c6a01","modified":1492409738774},{"_id":"public/2017/04/16/深入理解javascript原型和闭包-4-隐式原型/index.html","hash":"b6845fe7710fdf0dbdcb811665613a33db963183","modified":1492409738774},{"_id":"public/2017/04/16/深入理解javascript原型和闭包-5-instanceof/index.html","hash":"0d3e9dbd659c58cd4e20a98cbdc1465c6a4fb649","modified":1492409738774},{"_id":"public/2017/04/16/深入理解javascript原型和闭包-6-继承/index.html","hash":"6019a3d27c9a67862d33360559c459a1f1a2f87d","modified":1492409738774},{"_id":"public/2017/04/16/深入理解javascript原型和闭包-7-原型的灵活性/index.html","hash":"857fe913f386aee28897b9c421f40b0e043ed9a6","modified":1492409738774},{"_id":"public/2017/04/16/深入理解javascript原型和闭包-8-简述【执行上下文】上/index.html","hash":"d5897f972d6b6ce947548151dfe77169635265db","modified":1492409738774},{"_id":"public/2017/04/16/深入理解javascript原型和闭包-9-简述【执行上下文】下/index.html","hash":"daab3f72821e7e961db572a3fe5bc5edf3df51a4","modified":1492409738774},{"_id":"public/2017/04/17/深入理解javascript原型和闭包-10-this/index.html","hash":"27f797216616fbaa3dbef8d34fe605aaf06f0d9c","modified":1492409738774},{"_id":"public/2017/04/17/深入理解javascript原型和闭包-11-执行上下文栈/index.html","hash":"65f86f6cfc8a24dd759c1e2804e4b02eada4cb44","modified":1492409738774},{"_id":"public/2017/04/17/深入理解javascript原型和闭包-12-简介【作用域】/index.html","hash":"f8c1bd9807ce86a230ad24b1c5b4a1076a6e1692","modified":1492409738775},{"_id":"public/2017/04/17/深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/index.html","hash":"f1348fffe14bd00ea17d376d37d47055a4cc63ff","modified":1492409738775},{"_id":"public/2017/04/17/深入理解javascript原型和闭包-14-从【自由变量】和【作用域链】/index.html","hash":"12c075d16703116123598a4969b23d4f9986e623","modified":1492409738775},{"_id":"public/2017/04/17/深入理解javascript原型和闭包-15-闭包/index.html","hash":"b7f8bbeda09a0113477eff871696e612909d78c7","modified":1492409738775},{"_id":"public/2017/04/17/深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系/index.html","hash":"d7232aa8869c842f677e06ea22401a5f3df05f3d","modified":1492409738775},{"_id":"public/archives/index.html","hash":"eee9e38e2bc485c61195370c8dc7567ee3f4d08f","modified":1492409738775},{"_id":"public/archives/page/2/index.html","hash":"89e3ff66fb990626cb9f6d7237bce93a2647c42f","modified":1492409738775},{"_id":"public/archives/2017/index.html","hash":"a12f53a7e6b84f672394d41a8e96f27b4d3369c8","modified":1492409738775},{"_id":"public/archives/2017/page/2/index.html","hash":"44f860ccb9e2d8484e5dad9f3b9599bd8fd7faf0","modified":1492409738775},{"_id":"public/archives/2017/04/index.html","hash":"c9b251a353e8e61b2877c3fd0538eaf18eff3500","modified":1492409738775},{"_id":"public/archives/2017/04/page/2/index.html","hash":"defe9eecf44b9632094bbcf33ea342bf99dfef94","modified":1492409738775},{"_id":"public/categories/王福朋-深入理解javascript原型和闭包系列/index.html","hash":"88256996da9fc9c762e24aca61ae4f210e511b85","modified":1492409738775},{"_id":"public/categories/王福朋-深入理解javascript原型和闭包系列/page/2/index.html","hash":"1bf4805562f66624da3413df44ae8d714ca933c2","modified":1492409738776},{"_id":"public/index.html","hash":"83276c04a821650ab7e6e0d7c7461d6d4d854ed2","modified":1492409738775},{"_id":"public/page/2/index.html","hash":"659a5adf089b9668e1d4aa7cf067d8f1d187b510","modified":1492409738775},{"_id":"public/tags/javascript/index.html","hash":"fb60ce77ca7cfb7c82a4b342e281df60fe76b511","modified":1492409738776},{"_id":"public/tags/原型链/index.html","hash":"5e39a5e8951ef6f5448ced385fb43bd7d8d8333c","modified":1492409738776},{"_id":"public/tags/闭包/index.html","hash":"91d428182139c4cc25d824516555ea370031982f","modified":1492409738776},{"_id":"public/2017/04/17/深入理解javascript原型和闭包引言和目录/index.html","hash":"f19cf0cb160087d89807c38b0cbee1e5cc32dd52","modified":1492409738775},{"_id":"source/images/forkMeOnGithub.png","hash":"30e412feb56126976b4d332d546f69a59d1f43df","modified":1492410025573}],"Category":[{"name":"王福朋-深入理解javascript原型和闭包系列","_id":"cj1lk6e9q0004youa6ffk4md0"},{"name":"Hello World","_id":"cj1lk6edw001lyoua7hubacwq"}],"Data":[],"Page":[{"title":"about","date":"2017-04-16T06:01:00.000Z","comments":0,"_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2017-04-16 14:01:00\ncomments: false\n---\n","updated":"2017-04-16T06:01:23.851Z","path":"about/index.html","layout":"page","_id":"cj1lk6e980001youatwqwsc0i","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2017-04-16T07:03:37.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-04-16 15:03:37\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-04-16T07:19:16.655Z","path":"categories/index.html","layout":"page","_id":"cj1lk6e9m0003youaodd506tx","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"production","date":"2017-04-16T06:00:50.000Z","comments":0,"_content":"","source":"production/index.md","raw":"---\ntitle: production\ndate: 2017-04-16 14:00:50\ncomments: false\n---\n","updated":"2017-04-16T06:01:17.277Z","path":"production/index.html","layout":"page","_id":"cj1lk6ea80007youacq6xh0mi","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2017-04-16T05:47:38.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-04-16 13:47:38\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-04-16T07:20:40.053Z","path":"tags/index.html","layout":"page","_id":"cj1lk6eag0009youab26ktyt4","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Created by 晓倩 on 2017/4/3.\n */\nvar Circle = function () {\n    //创建对象\n    //以一个圆为对象\n    //设置随机的 x，y坐标，r半径，_mx，_my移动的距离\n    //this.r是创建圆的半径，参数越大半径越大\n    //this._mx,this._my是移动的距离，参数越大移动\n    function Circle(x, y) {\n        _classCallCheck(this, Circle);\n\n        this.x = x;\n        this.y = y;\n        this.r = Math.random() * 10;\n        this._mx = Math.random();\n        this._my = Math.random();\n    }\n\n    //canvas 画圆和画直线\n    //画圆就是正常的用canvas画一个圆\n    //画直线是两个圆连线，为了避免直线过多，给圆圈距离设置了一个值，距离很远的圆圈，就不做连线处理\n\n\n    _createClass(Circle, [{\n        key: 'drawCircle',\n        value: function drawCircle(ctx) {\n            ctx.beginPath();\n            //arc() 方法使用一个中心点和半径，为一个画布的当前子路径添加一条弧。\n            ctx.arc(this.x, this.y, this.r, 0, 360);\n            ctx.closePath();\n            ctx.fillStyle = 'rgba(204, 204, 204, 0.3)';\n            ctx.fill();\n        }\n    }, {\n        key: 'drawLine',\n        value: function drawLine(ctx, _circle) {\n            var dx = this.x - _circle.x;\n            var dy = this.y - _circle.y;\n            var d = Math.sqrt(dx * dx + dy * dy);\n            if (d < 150) {\n                ctx.beginPath();\n                //开始一条路径，移动到位置 this.x,this.y。创建到达位置 _circle.x,_circle.y 的一条线：\n                ctx.moveTo(this.x, this.y); //起始点\n                ctx.lineTo(_circle.x, _circle.y); //终点\n                ctx.closePath();\n                ctx.strokeStyle = 'rgba(204, 204, 204, 0.3)';\n                ctx.stroke();\n            }\n        }\n\n        // 圆圈移动\n        // 圆圈移动的距离必须在屏幕范围内\n\n    }, {\n        key: 'move',\n        value: function move(w, h) {\n            this._mx = this.x < w && this.x > 0 ? this._mx : -this._mx;\n            this._my = this.y < h && this.y > 0 ? this._my : -this._my;\n            this.x += this._mx / 2;\n            this.y += this._my / 2;\n        }\n    }]);\n\n    return Circle;\n}();\n//鼠标点画圆闪烁变动\n\n\nvar currentCirle = function (_Circle) {\n    _inherits(currentCirle, _Circle);\n\n    function currentCirle(x, y) {\n        _classCallCheck(this, currentCirle);\n\n        return _possibleConstructorReturn(this, (currentCirle.__proto__ || Object.getPrototypeOf(currentCirle)).call(this, x, y));\n    }\n\n    _createClass(currentCirle, [{\n        key: 'drawCircle',\n        value: function drawCircle(ctx) {\n            ctx.beginPath();\n            //注释内容为鼠标焦点的地方圆圈半径变化\n            //this.r = (this.r < 14 && this.r > 1) ? this.r + (Math.random() * 2 - 1) : 2;\n            this.r = 8;\n            ctx.arc(this.x, this.y, this.r, 0, 360);\n            ctx.closePath();\n            //ctx.fillStyle = 'rgba(0,0,0,' + (parseInt(Math.random() * 100) / 100) + ')'\n            ctx.fillStyle = 'rgba(255, 77, 54, 0.3)';\n            ctx.fill();\n        }\n    }]);\n\n    return currentCirle;\n}(Circle);\n//更新页面用requestAnimationFrame替代setTimeout\n\n\nwindow.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\n\nvar canvas = document.getElementById('canvas');\nvar ctx = canvas.getContext('2d');\nvar w = canvas.width = window.screen.width;\nvar h = canvas.height = window.screen.height;\nvar circles = [];\nvar current_circle = new currentCirle(0, 0);\n\nvar draw = function draw() {\n    ctx.clearRect(0, 0, w, h);\n    for (var i = 0; i < circles.length; i++) {\n        circles[i].move(w, h);\n        circles[i].drawCircle(ctx);\n        for (var j = i + 1; j < circles.length; j++) {\n            circles[i].drawLine(ctx, circles[j]);\n        }\n    }\n    if (current_circle.x) {\n        current_circle.drawCircle(ctx);\n        for (var k = 1; k < circles.length; k++) {\n            current_circle.drawLine(ctx, circles[k]);\n        }\n    }\n    requestAnimationFrame(draw);\n};\n\nvar init = function init(num) {\n    for (var i = 0; i < num; i++) {\n        circles.push(new Circle(Math.random() * w, Math.random() * h));\n    }\n    draw();\n};\nwindow.addEventListener('load', init(60));\nwindow.onmousemove = function (e) {\n    e = e || window.event;\n    current_circle.x = e.clientX;\n    current_circle.y = e.clientY;\n};\nwindow.onmouseout = function () {\n    current_circle.x = null;\n    current_circle.y = null;\n};","source":"js/canvas_nest/index.js","raw":"'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Created by 晓倩 on 2017/4/3.\n */\nvar Circle = function () {\n    //创建对象\n    //以一个圆为对象\n    //设置随机的 x，y坐标，r半径，_mx，_my移动的距离\n    //this.r是创建圆的半径，参数越大半径越大\n    //this._mx,this._my是移动的距离，参数越大移动\n    function Circle(x, y) {\n        _classCallCheck(this, Circle);\n\n        this.x = x;\n        this.y = y;\n        this.r = Math.random() * 10;\n        this._mx = Math.random();\n        this._my = Math.random();\n    }\n\n    //canvas 画圆和画直线\n    //画圆就是正常的用canvas画一个圆\n    //画直线是两个圆连线，为了避免直线过多，给圆圈距离设置了一个值，距离很远的圆圈，就不做连线处理\n\n\n    _createClass(Circle, [{\n        key: 'drawCircle',\n        value: function drawCircle(ctx) {\n            ctx.beginPath();\n            //arc() 方法使用一个中心点和半径，为一个画布的当前子路径添加一条弧。\n            ctx.arc(this.x, this.y, this.r, 0, 360);\n            ctx.closePath();\n            ctx.fillStyle = 'rgba(204, 204, 204, 0.3)';\n            ctx.fill();\n        }\n    }, {\n        key: 'drawLine',\n        value: function drawLine(ctx, _circle) {\n            var dx = this.x - _circle.x;\n            var dy = this.y - _circle.y;\n            var d = Math.sqrt(dx * dx + dy * dy);\n            if (d < 150) {\n                ctx.beginPath();\n                //开始一条路径，移动到位置 this.x,this.y。创建到达位置 _circle.x,_circle.y 的一条线：\n                ctx.moveTo(this.x, this.y); //起始点\n                ctx.lineTo(_circle.x, _circle.y); //终点\n                ctx.closePath();\n                ctx.strokeStyle = 'rgba(204, 204, 204, 0.3)';\n                ctx.stroke();\n            }\n        }\n\n        // 圆圈移动\n        // 圆圈移动的距离必须在屏幕范围内\n\n    }, {\n        key: 'move',\n        value: function move(w, h) {\n            this._mx = this.x < w && this.x > 0 ? this._mx : -this._mx;\n            this._my = this.y < h && this.y > 0 ? this._my : -this._my;\n            this.x += this._mx / 2;\n            this.y += this._my / 2;\n        }\n    }]);\n\n    return Circle;\n}();\n//鼠标点画圆闪烁变动\n\n\nvar currentCirle = function (_Circle) {\n    _inherits(currentCirle, _Circle);\n\n    function currentCirle(x, y) {\n        _classCallCheck(this, currentCirle);\n\n        return _possibleConstructorReturn(this, (currentCirle.__proto__ || Object.getPrototypeOf(currentCirle)).call(this, x, y));\n    }\n\n    _createClass(currentCirle, [{\n        key: 'drawCircle',\n        value: function drawCircle(ctx) {\n            ctx.beginPath();\n            //注释内容为鼠标焦点的地方圆圈半径变化\n            //this.r = (this.r < 14 && this.r > 1) ? this.r + (Math.random() * 2 - 1) : 2;\n            this.r = 8;\n            ctx.arc(this.x, this.y, this.r, 0, 360);\n            ctx.closePath();\n            //ctx.fillStyle = 'rgba(0,0,0,' + (parseInt(Math.random() * 100) / 100) + ')'\n            ctx.fillStyle = 'rgba(255, 77, 54, 0.3)';\n            ctx.fill();\n        }\n    }]);\n\n    return currentCirle;\n}(Circle);\n//更新页面用requestAnimationFrame替代setTimeout\n\n\nwindow.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\n\nvar canvas = document.getElementById('canvas');\nvar ctx = canvas.getContext('2d');\nvar w = canvas.width = window.screen.width;\nvar h = canvas.height = window.screen.height;\nvar circles = [];\nvar current_circle = new currentCirle(0, 0);\n\nvar draw = function draw() {\n    ctx.clearRect(0, 0, w, h);\n    for (var i = 0; i < circles.length; i++) {\n        circles[i].move(w, h);\n        circles[i].drawCircle(ctx);\n        for (var j = i + 1; j < circles.length; j++) {\n            circles[i].drawLine(ctx, circles[j]);\n        }\n    }\n    if (current_circle.x) {\n        current_circle.drawCircle(ctx);\n        for (var k = 1; k < circles.length; k++) {\n            current_circle.drawLine(ctx, circles[k]);\n        }\n    }\n    requestAnimationFrame(draw);\n};\n\nvar init = function init(num) {\n    for (var i = 0; i < num; i++) {\n        circles.push(new Circle(Math.random() * w, Math.random() * h));\n    }\n    draw();\n};\nwindow.addEventListener('load', init(60));\nwindow.onmousemove = function (e) {\n    e = e || window.event;\n    current_circle.x = e.clientX;\n    current_circle.y = e.clientY;\n};\nwindow.onmouseout = function () {\n    current_circle.x = null;\n    current_circle.y = null;\n};","date":"2017-04-16T10:16:33.534Z","updated":"2017-04-16T10:16:33.493Z","path":"js/canvas_nest/index.js","layout":"false","title":"","comments":1,"_id":"cj1lk6eip0034youaj5apwxq6","content":"'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Created by 晓倩 on 2017/4/3.\n */\nvar Circle = function () {\n    //创建对象\n    //以一个圆为对象\n    //设置随机的 x，y坐标，r半径，_mx，_my移动的距离\n    //this.r是创建圆的半径，参数越大半径越大\n    //this._mx,this._my是移动的距离，参数越大移动\n    function Circle(x, y) {\n        _classCallCheck(this, Circle);\n\n        this.x = x;\n        this.y = y;\n        this.r = Math.random() * 10;\n        this._mx = Math.random();\n        this._my = Math.random();\n    }\n\n    //canvas 画圆和画直线\n    //画圆就是正常的用canvas画一个圆\n    //画直线是两个圆连线，为了避免直线过多，给圆圈距离设置了一个值，距离很远的圆圈，就不做连线处理\n\n\n    _createClass(Circle, [{\n        key: 'drawCircle',\n        value: function drawCircle(ctx) {\n            ctx.beginPath();\n            //arc() 方法使用一个中心点和半径，为一个画布的当前子路径添加一条弧。\n            ctx.arc(this.x, this.y, this.r, 0, 360);\n            ctx.closePath();\n            ctx.fillStyle = 'rgba(204, 204, 204, 0.3)';\n            ctx.fill();\n        }\n    }, {\n        key: 'drawLine',\n        value: function drawLine(ctx, _circle) {\n            var dx = this.x - _circle.x;\n            var dy = this.y - _circle.y;\n            var d = Math.sqrt(dx * dx + dy * dy);\n            if (d < 150) {\n                ctx.beginPath();\n                //开始一条路径，移动到位置 this.x,this.y。创建到达位置 _circle.x,_circle.y 的一条线：\n                ctx.moveTo(this.x, this.y); //起始点\n                ctx.lineTo(_circle.x, _circle.y); //终点\n                ctx.closePath();\n                ctx.strokeStyle = 'rgba(204, 204, 204, 0.3)';\n                ctx.stroke();\n            }\n        }\n\n        // 圆圈移动\n        // 圆圈移动的距离必须在屏幕范围内\n\n    }, {\n        key: 'move',\n        value: function move(w, h) {\n            this._mx = this.x < w && this.x > 0 ? this._mx : -this._mx;\n            this._my = this.y < h && this.y > 0 ? this._my : -this._my;\n            this.x += this._mx / 2;\n            this.y += this._my / 2;\n        }\n    }]);\n\n    return Circle;\n}();\n//鼠标点画圆闪烁变动\n\n\nvar currentCirle = function (_Circle) {\n    _inherits(currentCirle, _Circle);\n\n    function currentCirle(x, y) {\n        _classCallCheck(this, currentCirle);\n\n        return _possibleConstructorReturn(this, (currentCirle.__proto__ || Object.getPrototypeOf(currentCirle)).call(this, x, y));\n    }\n\n    _createClass(currentCirle, [{\n        key: 'drawCircle',\n        value: function drawCircle(ctx) {\n            ctx.beginPath();\n            //注释内容为鼠标焦点的地方圆圈半径变化\n            //this.r = (this.r < 14 && this.r > 1) ? this.r + (Math.random() * 2 - 1) : 2;\n            this.r = 8;\n            ctx.arc(this.x, this.y, this.r, 0, 360);\n            ctx.closePath();\n            //ctx.fillStyle = 'rgba(0,0,0,' + (parseInt(Math.random() * 100) / 100) + ')'\n            ctx.fillStyle = 'rgba(255, 77, 54, 0.3)';\n            ctx.fill();\n        }\n    }]);\n\n    return currentCirle;\n}(Circle);\n//更新页面用requestAnimationFrame替代setTimeout\n\n\nwindow.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\n\nvar canvas = document.getElementById('canvas');\nvar ctx = canvas.getContext('2d');\nvar w = canvas.width = window.screen.width;\nvar h = canvas.height = window.screen.height;\nvar circles = [];\nvar current_circle = new currentCirle(0, 0);\n\nvar draw = function draw() {\n    ctx.clearRect(0, 0, w, h);\n    for (var i = 0; i < circles.length; i++) {\n        circles[i].move(w, h);\n        circles[i].drawCircle(ctx);\n        for (var j = i + 1; j < circles.length; j++) {\n            circles[i].drawLine(ctx, circles[j]);\n        }\n    }\n    if (current_circle.x) {\n        current_circle.drawCircle(ctx);\n        for (var k = 1; k < circles.length; k++) {\n            current_circle.drawLine(ctx, circles[k]);\n        }\n    }\n    requestAnimationFrame(draw);\n};\n\nvar init = function init(num) {\n    for (var i = 0; i < num; i++) {\n        circles.push(new Circle(Math.random() * w, Math.random() * h));\n    }\n    draw();\n};\nwindow.addEventListener('load', init(60));\nwindow.onmousemove = function (e) {\n    e = e || window.event;\n    current_circle.x = e.clientX;\n    current_circle.y = e.clientY;\n};\nwindow.onmouseout = function () {\n    current_circle.x = null;\n    current_circle.y = null;\n};","site":{"data":{}},"excerpt":"","more":"'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Created by 晓倩 on 2017/4/3.\n */\nvar Circle = function () {\n    //创建对象\n    //以一个圆为对象\n    //设置随机的 x，y坐标，r半径，_mx，_my移动的距离\n    //this.r是创建圆的半径，参数越大半径越大\n    //this._mx,this._my是移动的距离，参数越大移动\n    function Circle(x, y) {\n        _classCallCheck(this, Circle);\n\n        this.x = x;\n        this.y = y;\n        this.r = Math.random() * 10;\n        this._mx = Math.random();\n        this._my = Math.random();\n    }\n\n    //canvas 画圆和画直线\n    //画圆就是正常的用canvas画一个圆\n    //画直线是两个圆连线，为了避免直线过多，给圆圈距离设置了一个值，距离很远的圆圈，就不做连线处理\n\n\n    _createClass(Circle, [{\n        key: 'drawCircle',\n        value: function drawCircle(ctx) {\n            ctx.beginPath();\n            //arc() 方法使用一个中心点和半径，为一个画布的当前子路径添加一条弧。\n            ctx.arc(this.x, this.y, this.r, 0, 360);\n            ctx.closePath();\n            ctx.fillStyle = 'rgba(204, 204, 204, 0.3)';\n            ctx.fill();\n        }\n    }, {\n        key: 'drawLine',\n        value: function drawLine(ctx, _circle) {\n            var dx = this.x - _circle.x;\n            var dy = this.y - _circle.y;\n            var d = Math.sqrt(dx * dx + dy * dy);\n            if (d < 150) {\n                ctx.beginPath();\n                //开始一条路径，移动到位置 this.x,this.y。创建到达位置 _circle.x,_circle.y 的一条线：\n                ctx.moveTo(this.x, this.y); //起始点\n                ctx.lineTo(_circle.x, _circle.y); //终点\n                ctx.closePath();\n                ctx.strokeStyle = 'rgba(204, 204, 204, 0.3)';\n                ctx.stroke();\n            }\n        }\n\n        // 圆圈移动\n        // 圆圈移动的距离必须在屏幕范围内\n\n    }, {\n        key: 'move',\n        value: function move(w, h) {\n            this._mx = this.x < w && this.x > 0 ? this._mx : -this._mx;\n            this._my = this.y < h && this.y > 0 ? this._my : -this._my;\n            this.x += this._mx / 2;\n            this.y += this._my / 2;\n        }\n    }]);\n\n    return Circle;\n}();\n//鼠标点画圆闪烁变动\n\n\nvar currentCirle = function (_Circle) {\n    _inherits(currentCirle, _Circle);\n\n    function currentCirle(x, y) {\n        _classCallCheck(this, currentCirle);\n\n        return _possibleConstructorReturn(this, (currentCirle.__proto__ || Object.getPrototypeOf(currentCirle)).call(this, x, y));\n    }\n\n    _createClass(currentCirle, [{\n        key: 'drawCircle',\n        value: function drawCircle(ctx) {\n            ctx.beginPath();\n            //注释内容为鼠标焦点的地方圆圈半径变化\n            //this.r = (this.r < 14 && this.r > 1) ? this.r + (Math.random() * 2 - 1) : 2;\n            this.r = 8;\n            ctx.arc(this.x, this.y, this.r, 0, 360);\n            ctx.closePath();\n            //ctx.fillStyle = 'rgba(0,0,0,' + (parseInt(Math.random() * 100) / 100) + ')'\n            ctx.fillStyle = 'rgba(255, 77, 54, 0.3)';\n            ctx.fill();\n        }\n    }]);\n\n    return currentCirle;\n}(Circle);\n//更新页面用requestAnimationFrame替代setTimeout\n\n\nwindow.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\n\nvar canvas = document.getElementById('canvas');\nvar ctx = canvas.getContext('2d');\nvar w = canvas.width = window.screen.width;\nvar h = canvas.height = window.screen.height;\nvar circles = [];\nvar current_circle = new currentCirle(0, 0);\n\nvar draw = function draw() {\n    ctx.clearRect(0, 0, w, h);\n    for (var i = 0; i < circles.length; i++) {\n        circles[i].move(w, h);\n        circles[i].drawCircle(ctx);\n        for (var j = i + 1; j < circles.length; j++) {\n            circles[i].drawLine(ctx, circles[j]);\n        }\n    }\n    if (current_circle.x) {\n        current_circle.drawCircle(ctx);\n        for (var k = 1; k < circles.length; k++) {\n            current_circle.drawLine(ctx, circles[k]);\n        }\n    }\n    requestAnimationFrame(draw);\n};\n\nvar init = function init(num) {\n    for (var i = 0; i < num; i++) {\n        circles.push(new Circle(Math.random() * w, Math.random() * h));\n    }\n    draw();\n};\nwindow.addEventListener('load', init(60));\nwindow.onmousemove = function (e) {\n    e = e || window.event;\n    current_circle.x = e.clientX;\n    current_circle.y = e.clientY;\n};\nwindow.onmouseout = function () {\n    current_circle.x = null;\n    current_circle.y = null;\n};"}],"Post":[{"title":"深入理解javascript原型和闭包(2)--函数和对象的关系","date":"2017-04-16T13:34:35.000Z","_content":"{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3978035.html 深入理解javascript原型和闭包（2）——函数和对象的关系 %}\n{% endblockquote %}\n上文（{% post_link 深入理解javascript原型和闭包-1-一切都是对象 理解javascript原型和作用域系列（1）——一切都是对象 %}）已经提到，函数就是对象的一种，因为通过instanceof函数可以判断。\n```javascript\nvar fn = function () { };\nconsole.log(fn instanceof Object);  // true\n```\n对！函数是一种对象，但是函数却不像数组一样——你可以说数组是对象的一种，因为数组就像是对象的一个子集一样。但是函数与对象之间，却不仅仅是一种包含和被包含的关系，函数和对象之间的关系比较复杂，甚至有一点鸡生蛋蛋生鸡的逻辑，咱们这一节就缕一缕。\n\n还是先看一个小例子吧。\n```javascript\nfunction Fn() {\n            this.name = '王福朋';\n            this.year = 1988;\n        }\n        var fn1 = new Fn();\n ```\n 上面的这个例子很简单，它能说明：对象可以通过函数来创建。对！也只能说明这一点。\n\n 但是我要说——{% raw %}\n            <span style=\"background-color: #87daff;\">对象都是通过函数创建的</span>\n        {% endraw %}——有些人可能反驳：不对！因为：\n```javascript\nvar obj = { a: 10, b: 20 };\nvar arr = [5, 'x', true];\n```\n但是不好意思，这个——真的——是一种——“快捷方式”，在编程语言中，一般叫做“语法糖”。\n做“语法糖”做的最好的可谓是微软大哥，它把他们家C#那小子弄的不男不女从的，本想图个人见人爱，谁承想还得到处跟人解释——其实它是个男孩！\n话归正传——其实以上代码的本质是：\n```javascript\n//var obj = { a: 10, b: 20 };\n        //var arr = [5, 'x', true];\n\n        var obj = new Object();\n        obj.a = 10;\n        obj.b = 20;\n\n        var arr = new Array();\n        arr[0] = 5;\n        arr[1] = 'x';\n        arr[2] = true;\n```\n而其中的 Object 和 Array 都是函数：\n```javascript\nconsole.log(typeof (Object));  // function\nconsole.log(typeof (Array));  // function\n```\n所以，可以很负责任的说——{% raw %}\n                         <span style=\"background-color: #87daff;\">对象都是通过函数来创建的</span>\n                     {% endraw %}。\n<!-- more -->\n\n现在是不是糊涂了—— 对象是函数创建的，而函数却又是一种对象——天哪！函数和对象到底是什么关系啊？\n别着急！揭开这个谜底，还得先去了解一下另一位老朋友——prototype原型。\n\n本系列文章不打算动辄几千字的长篇大论，咱们小步快跑，不至于看的太乏味。","source":"_posts/2017-04-16-深入理解javascript原型和闭包-2-函数和对象的关系.md","raw":"---\ntitle: 深入理解javascript原型和闭包(2)--函数和对象的关系\ncategories: 王福朋-深入理解javascript原型和闭包系列\ntags:\n  - javascript\n  - 原型链\n  - 闭包\ndate: 2017-04-16 21:34:35\n---\n{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3978035.html 深入理解javascript原型和闭包（2）——函数和对象的关系 %}\n{% endblockquote %}\n上文（{% post_link 深入理解javascript原型和闭包-1-一切都是对象 理解javascript原型和作用域系列（1）——一切都是对象 %}）已经提到，函数就是对象的一种，因为通过instanceof函数可以判断。\n```javascript\nvar fn = function () { };\nconsole.log(fn instanceof Object);  // true\n```\n对！函数是一种对象，但是函数却不像数组一样——你可以说数组是对象的一种，因为数组就像是对象的一个子集一样。但是函数与对象之间，却不仅仅是一种包含和被包含的关系，函数和对象之间的关系比较复杂，甚至有一点鸡生蛋蛋生鸡的逻辑，咱们这一节就缕一缕。\n\n还是先看一个小例子吧。\n```javascript\nfunction Fn() {\n            this.name = '王福朋';\n            this.year = 1988;\n        }\n        var fn1 = new Fn();\n ```\n 上面的这个例子很简单，它能说明：对象可以通过函数来创建。对！也只能说明这一点。\n\n 但是我要说——{% raw %}\n            <span style=\"background-color: #87daff;\">对象都是通过函数创建的</span>\n        {% endraw %}——有些人可能反驳：不对！因为：\n```javascript\nvar obj = { a: 10, b: 20 };\nvar arr = [5, 'x', true];\n```\n但是不好意思，这个——真的——是一种——“快捷方式”，在编程语言中，一般叫做“语法糖”。\n做“语法糖”做的最好的可谓是微软大哥，它把他们家C#那小子弄的不男不女从的，本想图个人见人爱，谁承想还得到处跟人解释——其实它是个男孩！\n话归正传——其实以上代码的本质是：\n```javascript\n//var obj = { a: 10, b: 20 };\n        //var arr = [5, 'x', true];\n\n        var obj = new Object();\n        obj.a = 10;\n        obj.b = 20;\n\n        var arr = new Array();\n        arr[0] = 5;\n        arr[1] = 'x';\n        arr[2] = true;\n```\n而其中的 Object 和 Array 都是函数：\n```javascript\nconsole.log(typeof (Object));  // function\nconsole.log(typeof (Array));  // function\n```\n所以，可以很负责任的说——{% raw %}\n                         <span style=\"background-color: #87daff;\">对象都是通过函数来创建的</span>\n                     {% endraw %}。\n<!-- more -->\n\n现在是不是糊涂了—— 对象是函数创建的，而函数却又是一种对象——天哪！函数和对象到底是什么关系啊？\n别着急！揭开这个谜底，还得先去了解一下另一位老朋友——prototype原型。\n\n本系列文章不打算动辄几千字的长篇大论，咱们小步快跑，不至于看的太乏味。","slug":"深入理解javascript原型和闭包-2-函数和对象的关系","published":1,"updated":"2017-04-16T17:38:53.273Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1lk6e8u0000youamvfl9a7x","content":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3978035.html\" target=\"_blank\" rel=\"external\">深入理解javascript原型和闭包（2）——函数和对象的关系</a></cite></footer></blockquote>\n<p>上文（<a href=\"/2017/04/16/深入理解javascript原型和闭包-1-一切都是对象/\" title=\"理解javascript原型和作用域系列（1）——一切都是对象\">理解javascript原型和作用域系列（1）——一切都是对象</a>）已经提到，函数就是对象的一种，因为通过instanceof函数可以判断。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; &#125;;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(fn <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>);  <span class=\"comment\">// true</span></div></pre></td></tr></table></figure></p>\n<p>对！函数是一种对象，但是函数却不像数组一样——你可以说数组是对象的一种，因为数组就像是对象的一个子集一样。但是函数与对象之间，却不仅仅是一种包含和被包含的关系，函数和对象之间的关系比较复杂，甚至有一点鸡生蛋蛋生鸡的逻辑，咱们这一节就缕一缕。</p>\n<p>还是先看一个小例子吧。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fn</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.name = <span class=\"string\">'王福朋'</span>;</div><div class=\"line\">            <span class=\"keyword\">this</span>.year = <span class=\"number\">1988</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">var</span> fn1 = <span class=\"keyword\">new</span> Fn();</div></pre></td></tr></table></figure></p>\n<p> 上面的这个例子很简单，它能说明：对象可以通过函数来创建。对！也只能说明这一点。</p>\n<p> 但是我要说——\n            <span style=\"background-color: #87daff;\">对象都是通过函数创建的</span>\n        ——有些人可能反驳：不对！因为：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">a</span>: <span class=\"number\">10</span>, <span class=\"attr\">b</span>: <span class=\"number\">20</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">5</span>, <span class=\"string\">'x'</span>, <span class=\"literal\">true</span>];</div></pre></td></tr></table></figure></p>\n<p>但是不好意思，这个——真的——是一种——“快捷方式”，在编程语言中，一般叫做“语法糖”。<br>做“语法糖”做的最好的可谓是微软大哥，它把他们家C#那小子弄的不男不女从的，本想图个人见人爱，谁承想还得到处跟人解释——其实它是个男孩！<br>话归正传——其实以上代码的本质是：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//var obj = &#123; a: 10, b: 20 &#125;;</span></div><div class=\"line\">        <span class=\"comment\">//var arr = [5, 'x', true];</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div><div class=\"line\">        obj.a = <span class=\"number\">10</span>;</div><div class=\"line\">        obj.b = <span class=\"number\">20</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">var</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</div><div class=\"line\">        arr[<span class=\"number\">0</span>] = <span class=\"number\">5</span>;</div><div class=\"line\">        arr[<span class=\"number\">1</span>] = <span class=\"string\">'x'</span>;</div><div class=\"line\">        arr[<span class=\"number\">2</span>] = <span class=\"literal\">true</span>;</div></pre></td></tr></table></figure></p>\n<p>而其中的 Object 和 Array 都是函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> (<span class=\"built_in\">Object</span>));  <span class=\"comment\">// function</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> (<span class=\"built_in\">Array</span>));  <span class=\"comment\">// function</span></div></pre></td></tr></table></figure></p>\n<p>所以，可以很负责任的说——\n                         <span style=\"background-color: #87daff;\">对象都是通过函数来创建的</span>\n                     。<br><a id=\"more\"></a></p>\n<p>现在是不是糊涂了—— 对象是函数创建的，而函数却又是一种对象——天哪！函数和对象到底是什么关系啊？<br>别着急！揭开这个谜底，还得先去了解一下另一位老朋友——prototype原型。</p>\n<p>本系列文章不打算动辄几千字的长篇大论，咱们小步快跑，不至于看的太乏味。</p>\n","site":{"data":{}},"excerpt":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3978035.html\">深入理解javascript原型和闭包（2）——函数和对象的关系</a></cite></footer></blockquote>\n<p>上文（<a href=\"/2017/04/16/深入理解javascript原型和闭包-1-一切都是对象/\" title=\"理解javascript原型和作用域系列（1）——一切都是对象\">理解javascript原型和作用域系列（1）——一切都是对象</a>）已经提到，函数就是对象的一种，因为通过instanceof函数可以判断。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; &#125;;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(fn <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>);  <span class=\"comment\">// true</span></div></pre></td></tr></table></figure></p>\n<p>对！函数是一种对象，但是函数却不像数组一样——你可以说数组是对象的一种，因为数组就像是对象的一个子集一样。但是函数与对象之间，却不仅仅是一种包含和被包含的关系，函数和对象之间的关系比较复杂，甚至有一点鸡生蛋蛋生鸡的逻辑，咱们这一节就缕一缕。</p>\n<p>还是先看一个小例子吧。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fn</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.name = <span class=\"string\">'王福朋'</span>;</div><div class=\"line\">            <span class=\"keyword\">this</span>.year = <span class=\"number\">1988</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">var</span> fn1 = <span class=\"keyword\">new</span> Fn();</div></pre></td></tr></table></figure></p>\n<p> 上面的这个例子很简单，它能说明：对象可以通过函数来创建。对！也只能说明这一点。</p>\n<p> 但是我要说——\n            <span style=\"background-color: #87daff;\">对象都是通过函数创建的</span>\n        ——有些人可能反驳：不对！因为：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">a</span>: <span class=\"number\">10</span>, <span class=\"attr\">b</span>: <span class=\"number\">20</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">5</span>, <span class=\"string\">'x'</span>, <span class=\"literal\">true</span>];</div></pre></td></tr></table></figure></p>\n<p>但是不好意思，这个——真的——是一种——“快捷方式”，在编程语言中，一般叫做“语法糖”。<br>做“语法糖”做的最好的可谓是微软大哥，它把他们家C#那小子弄的不男不女从的，本想图个人见人爱，谁承想还得到处跟人解释——其实它是个男孩！<br>话归正传——其实以上代码的本质是：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//var obj = &#123; a: 10, b: 20 &#125;;</span></div><div class=\"line\">        <span class=\"comment\">//var arr = [5, 'x', true];</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div><div class=\"line\">        obj.a = <span class=\"number\">10</span>;</div><div class=\"line\">        obj.b = <span class=\"number\">20</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">var</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</div><div class=\"line\">        arr[<span class=\"number\">0</span>] = <span class=\"number\">5</span>;</div><div class=\"line\">        arr[<span class=\"number\">1</span>] = <span class=\"string\">'x'</span>;</div><div class=\"line\">        arr[<span class=\"number\">2</span>] = <span class=\"literal\">true</span>;</div></pre></td></tr></table></figure></p>\n<p>而其中的 Object 和 Array 都是函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> (<span class=\"built_in\">Object</span>));  <span class=\"comment\">// function</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> (<span class=\"built_in\">Array</span>));  <span class=\"comment\">// function</span></div></pre></td></tr></table></figure></p>\n<p>所以，可以很负责任的说——\n                         <span style=\"background-color: #87daff;\">对象都是通过函数来创建的</span>\n                     。<br>","more":"</p>\n<p>现在是不是糊涂了—— 对象是函数创建的，而函数却又是一种对象——天哪！函数和对象到底是什么关系啊？<br>别着急！揭开这个谜底，还得先去了解一下另一位老朋友——prototype原型。</p>\n<p>本系列文章不打算动辄几千字的长篇大论，咱们小步快跑，不至于看的太乏味。</p>"},{"title":"深入理解javascript原型和闭包(1)--一切都是对象","date":"2017-04-16T12:09:34.000Z","_content":"{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3977987.html 深入理解javascript原型和闭包（1）——一切都是对象 %}\n{% endblockquote %}\n###### “一切都是对象”这句话的重点在于如何去理解“对象”这个概念。\n——当然，也不是所有的都是对象，值类型就不是对象。\n\n\n\n首先咱们还是先看看javascript中一个常用的一元操作符——typeof。typeof应该算是咱们的老朋友，还有谁没用过它？\n{% blockquote %}\n    注释：原文中描述的typeof是一个函数，其实tyepof是一个一元操作符，原作者已经知晓，暂时未在文章中修改\n{% endblockquote %}\n\ntypeof函数输出的一共有几种类型，在此列出：\n```javascript\nfunction show(x) {\n            console.log(typeof(x));    // undefined\n            console.log(typeof(10));   // number\n            console.log(typeof('abc')); // string\n            console.log(typeof(true));  // boolean\n\n            console.log(typeof(function () { }));  //function\n\n            console.log(typeof([1, 'a', true]));  //object\n            console.log(typeof ({ a: 10, b: 20 }));  //object\n            console.log(typeof (null));  //object\n            console.log(typeof (new Number(10)));  //object\n        }\n\n        show();\n```\n<!-- more -->\n以上代码列出了typeof输出的集中类型标识，其中上面的四种（undefined, number, string, boolean）属于简单的{% raw %}\n    <span style=\"background-color: #87daff;\">值类型</span>\n{% endraw %}，不是对象。剩下的几种情况——函数、数组、对象、null、new Number(10)都是对象。他们都是{% raw %}\n                                                                   <span style=\"background-color: #87daff;\">引用类型</span>\n                                                                {% endraw %}。\n\n判断一个变量是不是对象非常简单。值类型的类型判断用typeof，引用类型的类型判断用instanceof。\n```javascript\nvar fn = function () { };\nconsole.log(fn instanceof Object);  // true\n```\n好了，上面说了半天对象，各位可能也经常在工作中应对对象，在生活中还得应对活生生的对象。有些个心理不正常或者爱开玩笑的单身人士，还对于系统提示的“找不到对象”耿耿于怀。那么在javascript中的对象，到底该如何定义呢？\n###### 对象——若干属性的集合。\njava或者C#中的对象都是new一个class出来的，而且里面有字段、属性、方法，规定的非常严格。但是javascript就比较随意了——数组是对象，函数是对象，对象还是对象。对象里面的一切都是属性，只有属性，没有方法。那么这样方法如何表示呢？——方法也是一种属性。因为它的属性表示为键值对的形式。\n\n而且，更加好玩的事，javascript中的对象可以任意的扩展属性，没有class的约束。这个大家应该都知道，就不再强调了。\n\n先说个最常见的例子：\n{% asset_img '1-1.png' %}\n以上代码中，obj是一个自定义的对象，其中a、b、c就是它的属性，而且在c的属性值还是一个对象，它又有name、year两个属性。\n\n\n\n这个可能比较好理解，那么函数和数组也可以这样定义属性吗？——当然不行，但是它可以用另一种形式，总之函数/数组之流，只要是对象，它就是属性的集合。\n\n以函数为例子：\n```javascript\nvar fn = function () {\n            alert(100);\n        };\n        fn.a = 10;\n        fn.b = function () {\n            alert(123);\n        };\n        fn.c = {\n            name: \"王福朋\",\n            year: 1988\n        };\n```\n上段代码中，函数就作为对象被赋值了a、b、c三个属性——很明显，这就是属性的集合吗。\n\n你问：这个有用吗？\n\n回答：可以看看jQuery源码！\n\n在jQuery源码中，“jQuery”或者“$”，这个变量其实是一个函数，不信你可以叫咱们的老朋友typeof验证一下。\n```javascript\nconsole.log(typeof ($));  // function\nconsole.log($.trim(\" ABC \"));\n```\n验明正身！的确是个函数。那么咱们常用的 $.trim() 也是个函数，经常用，就不用验了吧！\n\n很明显，这就是在$或者jQuery函数上加了一个trim属性，属性值是函数，作用是截取前后空格。\n\n\n\njavascript与java/C#相比，首先最需要解释的就是弱类型，因为弱类型是最基本的用法，而且最常用，就不打算做一节来讲。\n\n其次要解释的就是本文的内容——{% raw %}\n                   <span style=\"background-color: #87daff;\">一切（引用类型）都是对象，对象是属性的集合</span>\n               {% endraw %}。最需要了解的就是对象的概念，和java/C#完全不一样。所以，切记切记！\n\n\n\n最后，有个疑问。在typeof的输出类型中，function和object都是对象，为何却要输出两种答案呢？都叫做object不行吗？——当然不行。\n\n具体原因，且听下回分解！\n","source":"_posts/2017-04-16-深入理解javascript原型和闭包-1-一切都是对象.md","raw":"---\ntitle: 深入理解javascript原型和闭包(1)--一切都是对象\ncategories: 王福朋-深入理解javascript原型和闭包系列\ntags:\n  - javascript\n  - 原型链\n  - 闭包\ndate: 2017-04-16 20:09:34\n---\n{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3977987.html 深入理解javascript原型和闭包（1）——一切都是对象 %}\n{% endblockquote %}\n###### “一切都是对象”这句话的重点在于如何去理解“对象”这个概念。\n——当然，也不是所有的都是对象，值类型就不是对象。\n\n\n\n首先咱们还是先看看javascript中一个常用的一元操作符——typeof。typeof应该算是咱们的老朋友，还有谁没用过它？\n{% blockquote %}\n    注释：原文中描述的typeof是一个函数，其实tyepof是一个一元操作符，原作者已经知晓，暂时未在文章中修改\n{% endblockquote %}\n\ntypeof函数输出的一共有几种类型，在此列出：\n```javascript\nfunction show(x) {\n            console.log(typeof(x));    // undefined\n            console.log(typeof(10));   // number\n            console.log(typeof('abc')); // string\n            console.log(typeof(true));  // boolean\n\n            console.log(typeof(function () { }));  //function\n\n            console.log(typeof([1, 'a', true]));  //object\n            console.log(typeof ({ a: 10, b: 20 }));  //object\n            console.log(typeof (null));  //object\n            console.log(typeof (new Number(10)));  //object\n        }\n\n        show();\n```\n<!-- more -->\n以上代码列出了typeof输出的集中类型标识，其中上面的四种（undefined, number, string, boolean）属于简单的{% raw %}\n    <span style=\"background-color: #87daff;\">值类型</span>\n{% endraw %}，不是对象。剩下的几种情况——函数、数组、对象、null、new Number(10)都是对象。他们都是{% raw %}\n                                                                   <span style=\"background-color: #87daff;\">引用类型</span>\n                                                                {% endraw %}。\n\n判断一个变量是不是对象非常简单。值类型的类型判断用typeof，引用类型的类型判断用instanceof。\n```javascript\nvar fn = function () { };\nconsole.log(fn instanceof Object);  // true\n```\n好了，上面说了半天对象，各位可能也经常在工作中应对对象，在生活中还得应对活生生的对象。有些个心理不正常或者爱开玩笑的单身人士，还对于系统提示的“找不到对象”耿耿于怀。那么在javascript中的对象，到底该如何定义呢？\n###### 对象——若干属性的集合。\njava或者C#中的对象都是new一个class出来的，而且里面有字段、属性、方法，规定的非常严格。但是javascript就比较随意了——数组是对象，函数是对象，对象还是对象。对象里面的一切都是属性，只有属性，没有方法。那么这样方法如何表示呢？——方法也是一种属性。因为它的属性表示为键值对的形式。\n\n而且，更加好玩的事，javascript中的对象可以任意的扩展属性，没有class的约束。这个大家应该都知道，就不再强调了。\n\n先说个最常见的例子：\n{% asset_img '1-1.png' %}\n以上代码中，obj是一个自定义的对象，其中a、b、c就是它的属性，而且在c的属性值还是一个对象，它又有name、year两个属性。\n\n\n\n这个可能比较好理解，那么函数和数组也可以这样定义属性吗？——当然不行，但是它可以用另一种形式，总之函数/数组之流，只要是对象，它就是属性的集合。\n\n以函数为例子：\n```javascript\nvar fn = function () {\n            alert(100);\n        };\n        fn.a = 10;\n        fn.b = function () {\n            alert(123);\n        };\n        fn.c = {\n            name: \"王福朋\",\n            year: 1988\n        };\n```\n上段代码中，函数就作为对象被赋值了a、b、c三个属性——很明显，这就是属性的集合吗。\n\n你问：这个有用吗？\n\n回答：可以看看jQuery源码！\n\n在jQuery源码中，“jQuery”或者“$”，这个变量其实是一个函数，不信你可以叫咱们的老朋友typeof验证一下。\n```javascript\nconsole.log(typeof ($));  // function\nconsole.log($.trim(\" ABC \"));\n```\n验明正身！的确是个函数。那么咱们常用的 $.trim() 也是个函数，经常用，就不用验了吧！\n\n很明显，这就是在$或者jQuery函数上加了一个trim属性，属性值是函数，作用是截取前后空格。\n\n\n\njavascript与java/C#相比，首先最需要解释的就是弱类型，因为弱类型是最基本的用法，而且最常用，就不打算做一节来讲。\n\n其次要解释的就是本文的内容——{% raw %}\n                   <span style=\"background-color: #87daff;\">一切（引用类型）都是对象，对象是属性的集合</span>\n               {% endraw %}。最需要了解的就是对象的概念，和java/C#完全不一样。所以，切记切记！\n\n\n\n最后，有个疑问。在typeof的输出类型中，function和object都是对象，为何却要输出两种答案呢？都叫做object不行吗？——当然不行。\n\n具体原因，且听下回分解！\n","slug":"深入理解javascript原型和闭包-1-一切都是对象","published":1,"updated":"2017-04-16T17:38:06.342Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1lk6e9g0002youanv8y5pql","content":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3977987.html\" target=\"_blank\" rel=\"external\">深入理解javascript原型和闭包（1）——一切都是对象</a></cite></footer></blockquote>\n<h6 id=\"“一切都是对象”这句话的重点在于如何去理解“对象”这个概念。\"><a href=\"#“一切都是对象”这句话的重点在于如何去理解“对象”这个概念。\" class=\"headerlink\" title=\"“一切都是对象”这句话的重点在于如何去理解“对象”这个概念。\"></a>“一切都是对象”这句话的重点在于如何去理解“对象”这个概念。</h6><p>——当然，也不是所有的都是对象，值类型就不是对象。</p>\n<p>首先咱们还是先看看javascript中一个常用的一元操作符——typeof。typeof应该算是咱们的老朋友，还有谁没用过它？<br><blockquote><p>注释：原文中描述的typeof是一个函数，其实tyepof是一个一元操作符，原作者已经知晓，暂时未在文章中修改</p>\n</blockquote></p>\n<p>typeof函数输出的一共有几种类型，在此列出：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(x));    <span class=\"comment\">// undefined</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"number\">10</span>));   <span class=\"comment\">// number</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"string\">'abc'</span>)); <span class=\"comment\">// string</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"literal\">true</span>));  <span class=\"comment\">// boolean</span></div><div class=\"line\"></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; &#125;));  <span class=\"comment\">//function</span></div><div class=\"line\"></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>([<span class=\"number\">1</span>, <span class=\"string\">'a'</span>, <span class=\"literal\">true</span>]));  <span class=\"comment\">//object</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> (&#123; <span class=\"attr\">a</span>: <span class=\"number\">10</span>, <span class=\"attr\">b</span>: <span class=\"number\">20</span> &#125;));  <span class=\"comment\">//object</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> (<span class=\"literal\">null</span>));  <span class=\"comment\">//object</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> (<span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"number\">10</span>)));  <span class=\"comment\">//object</span></div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        show();</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>以上代码列出了typeof输出的集中类型标识，其中上面的四种（undefined, number, string, boolean）属于简单的\n    <span style=\"background-color: #87daff;\">值类型</span>\n，不是对象。剩下的几种情况——函数、数组、对象、null、new Number(10)都是对象。他们都是\n                                                                   <span style=\"background-color: #87daff;\">引用类型</span>\n                                                                。</p>\n<p>判断一个变量是不是对象非常简单。值类型的类型判断用typeof，引用类型的类型判断用instanceof。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; &#125;;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(fn <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>);  <span class=\"comment\">// true</span></div></pre></td></tr></table></figure></p>\n<p>好了，上面说了半天对象，各位可能也经常在工作中应对对象，在生活中还得应对活生生的对象。有些个心理不正常或者爱开玩笑的单身人士，还对于系统提示的“找不到对象”耿耿于怀。那么在javascript中的对象，到底该如何定义呢？</p>\n<h6 id=\"对象——若干属性的集合。\"><a href=\"#对象——若干属性的集合。\" class=\"headerlink\" title=\"对象——若干属性的集合。\"></a>对象——若干属性的集合。</h6><p>java或者C#中的对象都是new一个class出来的，而且里面有字段、属性、方法，规定的非常严格。但是javascript就比较随意了——数组是对象，函数是对象，对象还是对象。对象里面的一切都是属性，只有属性，没有方法。那么这样方法如何表示呢？——方法也是一种属性。因为它的属性表示为键值对的形式。</p>\n<p>而且，更加好玩的事，javascript中的对象可以任意的扩展属性，没有class的约束。这个大家应该都知道，就不再强调了。</p>\n<p>先说个最常见的例子：<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-1-一切都是对象/1-1.png\" alt=\"1-1.png\" title=\"\"><br>以上代码中，obj是一个自定义的对象，其中a、b、c就是它的属性，而且在c的属性值还是一个对象，它又有name、year两个属性。</p>\n<p>这个可能比较好理解，那么函数和数组也可以这样定义属性吗？——当然不行，但是它可以用另一种形式，总之函数/数组之流，只要是对象，它就是属性的集合。</p>\n<p>以函数为例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            alert(<span class=\"number\">100</span>);</div><div class=\"line\">        &#125;;</div><div class=\"line\">        fn.a = <span class=\"number\">10</span>;</div><div class=\"line\">        fn.b = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            alert(<span class=\"number\">123</span>);</div><div class=\"line\">        &#125;;</div><div class=\"line\">        fn.c = &#123;</div><div class=\"line\">            <span class=\"attr\">name</span>: <span class=\"string\">\"王福朋\"</span>,</div><div class=\"line\">            <span class=\"attr\">year</span>: <span class=\"number\">1988</span></div><div class=\"line\">        &#125;;</div></pre></td></tr></table></figure></p>\n<p>上段代码中，函数就作为对象被赋值了a、b、c三个属性——很明显，这就是属性的集合吗。</p>\n<p>你问：这个有用吗？</p>\n<p>回答：可以看看jQuery源码！</p>\n<p>在jQuery源码中，“jQuery”或者“$”，这个变量其实是一个函数，不信你可以叫咱们的老朋友typeof验证一下。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> ($));  <span class=\"comment\">// function</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log($.trim(<span class=\"string\">\" ABC \"</span>));</div></pre></td></tr></table></figure></p>\n<p>验明正身！的确是个函数。那么咱们常用的 $.trim() 也是个函数，经常用，就不用验了吧！</p>\n<p>很明显，这就是在$或者jQuery函数上加了一个trim属性，属性值是函数，作用是截取前后空格。</p>\n<p>javascript与java/C#相比，首先最需要解释的就是弱类型，因为弱类型是最基本的用法，而且最常用，就不打算做一节来讲。</p>\n<p>其次要解释的就是本文的内容——\n                   <span style=\"background-color: #87daff;\">一切（引用类型）都是对象，对象是属性的集合</span>\n               。最需要了解的就是对象的概念，和java/C#完全不一样。所以，切记切记！</p>\n<p>最后，有个疑问。在typeof的输出类型中，function和object都是对象，为何却要输出两种答案呢？都叫做object不行吗？——当然不行。</p>\n<p>具体原因，且听下回分解！</p>\n","site":{"data":{}},"excerpt":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3977987.html\">深入理解javascript原型和闭包（1）——一切都是对象</a></cite></footer></blockquote>\n<h6 id=\"“一切都是对象”这句话的重点在于如何去理解“对象”这个概念。\"><a href=\"#“一切都是对象”这句话的重点在于如何去理解“对象”这个概念。\" class=\"headerlink\" title=\"“一切都是对象”这句话的重点在于如何去理解“对象”这个概念。\"></a>“一切都是对象”这句话的重点在于如何去理解“对象”这个概念。</h6><p>——当然，也不是所有的都是对象，值类型就不是对象。</p>\n<p>首先咱们还是先看看javascript中一个常用的一元操作符——typeof。typeof应该算是咱们的老朋友，还有谁没用过它？<br><blockquote><p>注释：原文中描述的typeof是一个函数，其实tyepof是一个一元操作符，原作者已经知晓，暂时未在文章中修改</p>\n</blockquote></p>\n<p>typeof函数输出的一共有几种类型，在此列出：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(x));    <span class=\"comment\">// undefined</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"number\">10</span>));   <span class=\"comment\">// number</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"string\">'abc'</span>)); <span class=\"comment\">// string</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"literal\">true</span>));  <span class=\"comment\">// boolean</span></div><div class=\"line\"></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; &#125;));  <span class=\"comment\">//function</span></div><div class=\"line\"></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>([<span class=\"number\">1</span>, <span class=\"string\">'a'</span>, <span class=\"literal\">true</span>]));  <span class=\"comment\">//object</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> (&#123; <span class=\"attr\">a</span>: <span class=\"number\">10</span>, <span class=\"attr\">b</span>: <span class=\"number\">20</span> &#125;));  <span class=\"comment\">//object</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> (<span class=\"literal\">null</span>));  <span class=\"comment\">//object</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> (<span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"number\">10</span>)));  <span class=\"comment\">//object</span></div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        show();</div></pre></td></tr></table></figure></p>","more":"<p>以上代码列出了typeof输出的集中类型标识，其中上面的四种（undefined, number, string, boolean）属于简单的\n    <span style=\"background-color: #87daff;\">值类型</span>\n，不是对象。剩下的几种情况——函数、数组、对象、null、new Number(10)都是对象。他们都是\n                                                                   <span style=\"background-color: #87daff;\">引用类型</span>\n                                                                。</p>\n<p>判断一个变量是不是对象非常简单。值类型的类型判断用typeof，引用类型的类型判断用instanceof。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; &#125;;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(fn <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>);  <span class=\"comment\">// true</span></div></pre></td></tr></table></figure></p>\n<p>好了，上面说了半天对象，各位可能也经常在工作中应对对象，在生活中还得应对活生生的对象。有些个心理不正常或者爱开玩笑的单身人士，还对于系统提示的“找不到对象”耿耿于怀。那么在javascript中的对象，到底该如何定义呢？</p>\n<h6 id=\"对象——若干属性的集合。\"><a href=\"#对象——若干属性的集合。\" class=\"headerlink\" title=\"对象——若干属性的集合。\"></a>对象——若干属性的集合。</h6><p>java或者C#中的对象都是new一个class出来的，而且里面有字段、属性、方法，规定的非常严格。但是javascript就比较随意了——数组是对象，函数是对象，对象还是对象。对象里面的一切都是属性，只有属性，没有方法。那么这样方法如何表示呢？——方法也是一种属性。因为它的属性表示为键值对的形式。</p>\n<p>而且，更加好玩的事，javascript中的对象可以任意的扩展属性，没有class的约束。这个大家应该都知道，就不再强调了。</p>\n<p>先说个最常见的例子：<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-1-一切都是对象/1-1.png\" alt=\"1-1.png\" title=\"\"><br>以上代码中，obj是一个自定义的对象，其中a、b、c就是它的属性，而且在c的属性值还是一个对象，它又有name、year两个属性。</p>\n<p>这个可能比较好理解，那么函数和数组也可以这样定义属性吗？——当然不行，但是它可以用另一种形式，总之函数/数组之流，只要是对象，它就是属性的集合。</p>\n<p>以函数为例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            alert(<span class=\"number\">100</span>);</div><div class=\"line\">        &#125;;</div><div class=\"line\">        fn.a = <span class=\"number\">10</span>;</div><div class=\"line\">        fn.b = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            alert(<span class=\"number\">123</span>);</div><div class=\"line\">        &#125;;</div><div class=\"line\">        fn.c = &#123;</div><div class=\"line\">            <span class=\"attr\">name</span>: <span class=\"string\">\"王福朋\"</span>,</div><div class=\"line\">            <span class=\"attr\">year</span>: <span class=\"number\">1988</span></div><div class=\"line\">        &#125;;</div></pre></td></tr></table></figure></p>\n<p>上段代码中，函数就作为对象被赋值了a、b、c三个属性——很明显，这就是属性的集合吗。</p>\n<p>你问：这个有用吗？</p>\n<p>回答：可以看看jQuery源码！</p>\n<p>在jQuery源码中，“jQuery”或者“$”，这个变量其实是一个函数，不信你可以叫咱们的老朋友typeof验证一下。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> ($));  <span class=\"comment\">// function</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log($.trim(<span class=\"string\">\" ABC \"</span>));</div></pre></td></tr></table></figure></p>\n<p>验明正身！的确是个函数。那么咱们常用的 $.trim() 也是个函数，经常用，就不用验了吧！</p>\n<p>很明显，这就是在$或者jQuery函数上加了一个trim属性，属性值是函数，作用是截取前后空格。</p>\n<p>javascript与java/C#相比，首先最需要解释的就是弱类型，因为弱类型是最基本的用法，而且最常用，就不打算做一节来讲。</p>\n<p>其次要解释的就是本文的内容——\n                   <span style=\"background-color: #87daff;\">一切（引用类型）都是对象，对象是属性的集合</span>\n               。最需要了解的就是对象的概念，和java/C#完全不一样。所以，切记切记！</p>\n<p>最后，有个疑问。在typeof的输出类型中，function和object都是对象，为何却要输出两种答案呢？都叫做object不行吗？——当然不行。</p>\n<p>具体原因，且听下回分解！</p>"},{"title":"深入理解javascript原型和闭包(3)--prototype原型","date":"2017-04-16T14:08:26.000Z","_content":"{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3978131.html 深入理解javascript原型和闭包（3）——prototype原型 %}\n{% endblockquote %}\n既typeof之后的另一位老朋友！\n\nprototype也是我们的老朋友，即使不了解的人，也应该都听过它的大名。如果它还是您的新朋友，我估计您也是javascript的新朋友。\n\n\n\n在咱们的第一节（{% post_link 深入理解javascript原型和闭包-1-一切都是对象 理解javascript原型和作用域系列（1）——一切都是对象 %}）中说道，函数也是一种对象。他也是属性的集合，你也可以对函数进行自定义属性。\n\n不用等咱们去试验，javascript自己就先做了表率，人家就默认的给函数一个属性——prototype。对，每个函数都有一个属性叫做prototype。\n\n这个prototype的属性值是一个对象（属性的集合，再次强调！），默认的只有一个叫做constructor的属性，指向这个函数本身。\n{% asset_img '3-1.png' %}\n如上图，SuperType是是一个函数，右侧的方框就是它的原型。\n\n原型既然作为对象，属性的集合，不可能就只弄个constructor来玩玩，肯定可以自定义的增加许多属性。例如这位Object大哥，人家的prototype里面，就有好几个其他属性。\n{% asset_img '3-2.png' %}\n咦，有些方法怎么似曾相似？\n\n对！别着急，之后会让你知道他们为何似曾相识。\n\n接着往下说，你也可以在自己自定义的方法的prototype中新增自己的属性\n```javascript\nfunction Fn() { }\n        Fn.prototype.name = '王福朋';\n        Fn.prototype.getYear = function () {\n            return 1988;\n        };\n```\n看到没有，这样就变成了\n{% asset_img '3-3.png' %}\n没问题！\n<!-- more -->\n\n但是，这样做有何用呢？ —— 解决这个问题，咱们还是先说说jQuery吧。\n```javascript\nvar $div = $('div');\n$div.attr('myName', '王福朋');\n```\n以上代码中，$('div')返回的是一个对象，对象——被函数创建的。假设创建这一对象的函数是 myjQuery。它其实是这样实现的。\n```javascript\nmyjQuery.prototype.attr = function () {\n            //……\n        };\n        $('div') = new myjQuery();\n```\n不知道大家有没有看明白。\n\n如果用咱们自己的代码来演示，就是这样\n```javascript\nfunction Fn() { }\n        Fn.prototype.name = '王福朋';\n        Fn.prototype.getYear = function () {\n            return 1988;\n        };\n\n        var fn = new Fn();\n        console.log(fn.name);\n        console.log(fn.getYear());\n```\n即，Fn是一个函数，fn对象是从Fn函数new出来的，这样fn对象就可以调用Fn.prototype中的属性。\n\n因为每个对象都有一个隐藏的属性——“__proto__”，这个属性引用了创建这个对象的函数的prototype。即：fn.__proto__ === Fn.prototype\n\n这里的\"__proto__\"成为“隐式原型”，下回继续分解。","source":"_posts/2017-04-16-深入理解javascript原型和闭包-3-prototype原型.md","raw":"---\ntitle: 深入理解javascript原型和闭包(3)--prototype原型\ncategories: 王福朋-深入理解javascript原型和闭包系列\ntags:\n  - javascript\n  - 原型链\n  - 闭包\ndate: 2017-04-16 22:08:26\n---\n{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3978131.html 深入理解javascript原型和闭包（3）——prototype原型 %}\n{% endblockquote %}\n既typeof之后的另一位老朋友！\n\nprototype也是我们的老朋友，即使不了解的人，也应该都听过它的大名。如果它还是您的新朋友，我估计您也是javascript的新朋友。\n\n\n\n在咱们的第一节（{% post_link 深入理解javascript原型和闭包-1-一切都是对象 理解javascript原型和作用域系列（1）——一切都是对象 %}）中说道，函数也是一种对象。他也是属性的集合，你也可以对函数进行自定义属性。\n\n不用等咱们去试验，javascript自己就先做了表率，人家就默认的给函数一个属性——prototype。对，每个函数都有一个属性叫做prototype。\n\n这个prototype的属性值是一个对象（属性的集合，再次强调！），默认的只有一个叫做constructor的属性，指向这个函数本身。\n{% asset_img '3-1.png' %}\n如上图，SuperType是是一个函数，右侧的方框就是它的原型。\n\n原型既然作为对象，属性的集合，不可能就只弄个constructor来玩玩，肯定可以自定义的增加许多属性。例如这位Object大哥，人家的prototype里面，就有好几个其他属性。\n{% asset_img '3-2.png' %}\n咦，有些方法怎么似曾相似？\n\n对！别着急，之后会让你知道他们为何似曾相识。\n\n接着往下说，你也可以在自己自定义的方法的prototype中新增自己的属性\n```javascript\nfunction Fn() { }\n        Fn.prototype.name = '王福朋';\n        Fn.prototype.getYear = function () {\n            return 1988;\n        };\n```\n看到没有，这样就变成了\n{% asset_img '3-3.png' %}\n没问题！\n<!-- more -->\n\n但是，这样做有何用呢？ —— 解决这个问题，咱们还是先说说jQuery吧。\n```javascript\nvar $div = $('div');\n$div.attr('myName', '王福朋');\n```\n以上代码中，$('div')返回的是一个对象，对象——被函数创建的。假设创建这一对象的函数是 myjQuery。它其实是这样实现的。\n```javascript\nmyjQuery.prototype.attr = function () {\n            //……\n        };\n        $('div') = new myjQuery();\n```\n不知道大家有没有看明白。\n\n如果用咱们自己的代码来演示，就是这样\n```javascript\nfunction Fn() { }\n        Fn.prototype.name = '王福朋';\n        Fn.prototype.getYear = function () {\n            return 1988;\n        };\n\n        var fn = new Fn();\n        console.log(fn.name);\n        console.log(fn.getYear());\n```\n即，Fn是一个函数，fn对象是从Fn函数new出来的，这样fn对象就可以调用Fn.prototype中的属性。\n\n因为每个对象都有一个隐藏的属性——“__proto__”，这个属性引用了创建这个对象的函数的prototype。即：fn.__proto__ === Fn.prototype\n\n这里的\"__proto__\"成为“隐式原型”，下回继续分解。","slug":"深入理解javascript原型和闭包-3-prototype原型","published":1,"updated":"2017-04-16T17:39:07.081Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1lk6ea30006youa91z70jag","content":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3978131.html\" target=\"_blank\" rel=\"external\">深入理解javascript原型和闭包（3）——prototype原型</a></cite></footer></blockquote>\n<p>既typeof之后的另一位老朋友！</p>\n<p>prototype也是我们的老朋友，即使不了解的人，也应该都听过它的大名。如果它还是您的新朋友，我估计您也是javascript的新朋友。</p>\n<p>在咱们的第一节（<a href=\"/2017/04/16/深入理解javascript原型和闭包-1-一切都是对象/\" title=\"理解javascript原型和作用域系列（1）——一切都是对象\">理解javascript原型和作用域系列（1）——一切都是对象</a>）中说道，函数也是一种对象。他也是属性的集合，你也可以对函数进行自定义属性。</p>\n<p>不用等咱们去试验，javascript自己就先做了表率，人家就默认的给函数一个属性——prototype。对，每个函数都有一个属性叫做prototype。</p>\n<p>这个prototype的属性值是一个对象（属性的集合，再次强调！），默认的只有一个叫做constructor的属性，指向这个函数本身。<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-3-prototype原型/3-1.png\" alt=\"3-1.png\" title=\"\"><br>如上图，SuperType是是一个函数，右侧的方框就是它的原型。</p>\n<p>原型既然作为对象，属性的集合，不可能就只弄个constructor来玩玩，肯定可以自定义的增加许多属性。例如这位Object大哥，人家的prototype里面，就有好几个其他属性。<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-3-prototype原型/3-2.png\" alt=\"3-2.png\" title=\"\"><br>咦，有些方法怎么似曾相似？</p>\n<p>对！别着急，之后会让你知道他们为何似曾相识。</p>\n<p>接着往下说，你也可以在自己自定义的方法的prototype中新增自己的属性<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fn</span>(<span class=\"params\"></span>) </span>&#123; &#125;</div><div class=\"line\">        Fn.prototype.name = <span class=\"string\">'王福朋'</span>;</div><div class=\"line\">        Fn.prototype.getYear = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1988</span>;</div><div class=\"line\">        &#125;;</div></pre></td></tr></table></figure></p>\n<p>看到没有，这样就变成了<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-3-prototype原型/3-3.png\" alt=\"3-3.png\" title=\"\"><br>没问题！<br><a id=\"more\"></a></p>\n<p>但是，这样做有何用呢？ —— 解决这个问题，咱们还是先说说jQuery吧。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> $div = $(<span class=\"string\">'div'</span>);</div><div class=\"line\">$div.attr(<span class=\"string\">'myName'</span>, <span class=\"string\">'王福朋'</span>);</div></pre></td></tr></table></figure></p>\n<p>以上代码中，$(‘div’)返回的是一个对象，对象——被函数创建的。假设创建这一对象的函数是 myjQuery。它其实是这样实现的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">myjQuery.prototype.attr = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"comment\">//……</span></div><div class=\"line\">        &#125;;</div><div class=\"line\">        $(<span class=\"string\">'div'</span>) = <span class=\"keyword\">new</span> myjQuery();</div></pre></td></tr></table></figure></p>\n<p>不知道大家有没有看明白。</p>\n<p>如果用咱们自己的代码来演示，就是这样<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fn</span>(<span class=\"params\"></span>) </span>&#123; &#125;</div><div class=\"line\">        Fn.prototype.name = <span class=\"string\">'王福朋'</span>;</div><div class=\"line\">        Fn.prototype.getYear = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1988</span>;</div><div class=\"line\">        &#125;;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">var</span> fn = <span class=\"keyword\">new</span> Fn();</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(fn.name);</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(fn.getYear());</div></pre></td></tr></table></figure></p>\n<p>即，Fn是一个函数，fn对象是从Fn函数new出来的，这样fn对象就可以调用Fn.prototype中的属性。</p>\n<p>因为每个对象都有一个隐藏的属性——“<strong>proto</strong>”，这个属性引用了创建这个对象的函数的prototype。即：fn.<strong>proto</strong> === Fn.prototype</p>\n<p>这里的”<strong>proto</strong>“成为“隐式原型”，下回继续分解。</p>\n","site":{"data":{}},"excerpt":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3978131.html\">深入理解javascript原型和闭包（3）——prototype原型</a></cite></footer></blockquote>\n<p>既typeof之后的另一位老朋友！</p>\n<p>prototype也是我们的老朋友，即使不了解的人，也应该都听过它的大名。如果它还是您的新朋友，我估计您也是javascript的新朋友。</p>\n<p>在咱们的第一节（<a href=\"/2017/04/16/深入理解javascript原型和闭包-1-一切都是对象/\" title=\"理解javascript原型和作用域系列（1）——一切都是对象\">理解javascript原型和作用域系列（1）——一切都是对象</a>）中说道，函数也是一种对象。他也是属性的集合，你也可以对函数进行自定义属性。</p>\n<p>不用等咱们去试验，javascript自己就先做了表率，人家就默认的给函数一个属性——prototype。对，每个函数都有一个属性叫做prototype。</p>\n<p>这个prototype的属性值是一个对象（属性的集合，再次强调！），默认的只有一个叫做constructor的属性，指向这个函数本身。<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-3-prototype原型/3-1.png\" alt=\"3-1.png\" title=\"\"><br>如上图，SuperType是是一个函数，右侧的方框就是它的原型。</p>\n<p>原型既然作为对象，属性的集合，不可能就只弄个constructor来玩玩，肯定可以自定义的增加许多属性。例如这位Object大哥，人家的prototype里面，就有好几个其他属性。<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-3-prototype原型/3-2.png\" alt=\"3-2.png\" title=\"\"><br>咦，有些方法怎么似曾相似？</p>\n<p>对！别着急，之后会让你知道他们为何似曾相识。</p>\n<p>接着往下说，你也可以在自己自定义的方法的prototype中新增自己的属性<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fn</span>(<span class=\"params\"></span>) </span>&#123; &#125;</div><div class=\"line\">        Fn.prototype.name = <span class=\"string\">'王福朋'</span>;</div><div class=\"line\">        Fn.prototype.getYear = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1988</span>;</div><div class=\"line\">        &#125;;</div></pre></td></tr></table></figure></p>\n<p>看到没有，这样就变成了<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-3-prototype原型/3-3.png\" alt=\"3-3.png\" title=\"\"><br>没问题！<br>","more":"</p>\n<p>但是，这样做有何用呢？ —— 解决这个问题，咱们还是先说说jQuery吧。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> $div = $(<span class=\"string\">'div'</span>);</div><div class=\"line\">$div.attr(<span class=\"string\">'myName'</span>, <span class=\"string\">'王福朋'</span>);</div></pre></td></tr></table></figure></p>\n<p>以上代码中，$(‘div’)返回的是一个对象，对象——被函数创建的。假设创建这一对象的函数是 myjQuery。它其实是这样实现的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">myjQuery.prototype.attr = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"comment\">//……</span></div><div class=\"line\">        &#125;;</div><div class=\"line\">        $(<span class=\"string\">'div'</span>) = <span class=\"keyword\">new</span> myjQuery();</div></pre></td></tr></table></figure></p>\n<p>不知道大家有没有看明白。</p>\n<p>如果用咱们自己的代码来演示，就是这样<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fn</span>(<span class=\"params\"></span>) </span>&#123; &#125;</div><div class=\"line\">        Fn.prototype.name = <span class=\"string\">'王福朋'</span>;</div><div class=\"line\">        Fn.prototype.getYear = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1988</span>;</div><div class=\"line\">        &#125;;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">var</span> fn = <span class=\"keyword\">new</span> Fn();</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(fn.name);</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(fn.getYear());</div></pre></td></tr></table></figure></p>\n<p>即，Fn是一个函数，fn对象是从Fn函数new出来的，这样fn对象就可以调用Fn.prototype中的属性。</p>\n<p>因为每个对象都有一个隐藏的属性——“<strong>proto</strong>”，这个属性引用了创建这个对象的函数的prototype。即：fn.<strong>proto</strong> === Fn.prototype</p>\n<p>这里的”<strong>proto</strong>“成为“隐式原型”，下回继续分解。</p>"},{"title":"深入理解javascript原型和闭包(4)--隐式原型","date":"2017-04-16T14:34:28.000Z","_content":"{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3979290.html 深入理解javascript原型和闭包（4）——隐式原型 %}\n{% endblockquote %}\n{% raw %}\n   <span style=\"color: #ff0000;\">注意：本文不是javascript基础教程，如果你没有接触过原型的基本知识，应该先去了解一下，推荐看《javascript高级程序设计（第三版）》第6章：面向对象的程序设计。</span>\n{% endraw %}\n\n\n上节已经提到，{% raw %}\n                  <span style=\"background-color: #87daff;\">每个函数function都有一个prototype</span>\n              {% endraw %}，即原型。这里再加一句话——{% raw %}\n                                                          <span style=\"background-color: #87daff;\">每个对象都有一个__proto__</span>\n                                                      {% endraw %}，可成为隐式原型。\n\n这个__proto__是一个隐藏的属性，javascript不希望开发者用到这个属性值，有的低版本浏览器甚至不支持这个属性值。所以你在Visual Studio 2012这样很高级很智能的编辑器中，都不会有__proto__的智能提示，但是你不用管它，直接写出来就是了。\n```javascript\nvar obj = {};\nconsole.log(obj.__proto__);\n```\n{% asset_img '4-1.png' %}\n上面截图看来，obj.__proto__和Object.prototype的属性一样！这么巧！\n\n答案就是一样。\n\nobj这个对象本质上是被Object函数创建的，因此obj.__proto__=== Object.prototype。我们可以用一个图来表示。\n{% asset_img '4-2.png' %}\n即，{% raw %}\n        <span style=\"background-color: #87daff;\">每个对象都有一个__proto__属性，指向创建该对象的函数的prototype</span>\n    {% endraw %}。\n<!-- more -->\n\n\n\n那么上图中的“Object prototype”也是一个对象，它的__proto__指向哪里？\n\n好问题！\n\n在说明“Object prototype”之前，先说一下自定义函数的prototype。自定义函数的prototype本质上就是和 var obj = {} 是一样的，都是被Object创建，所以它的__proto__指向的就是Object.prototype。\n\n但是{% raw %}\n          <span style=\"background-color: #87daff;\">Object.prototype确实一个特例——它的__proto__指向的是null，切记切记</span>\n      {% endraw %}！\n{% asset_img '4-3.png' %}\n还有——函数也是一种对象，函数也有__proto__吗？\n\n又一个好问题！——当然有。\n\n函数也不是从石头缝里蹦出来的，函数也是被创建出来的。谁创建了函数呢？——Function——注意这个大写的“F”。\n\n且看如下代码。\n{% asset_img '4-4.png' %}\n以上代码中，第一种方式是比较传统的函数创建方式，第二种是用new Functoin创建。\n\n{% raw %}\n   <span style=\"color: #ff0000;\">首先根本不推荐用第二种方式</span>\n{% endraw %}。\n\n这里只是向大家演示，函数是被Function创建的。\n\n\n\n好了，根据上面说的一句话——对象的__proto__指向的是创建它的函数的prototype，就会出现：Object.__proto__ === Function.prototype。用一个图来表示。\n{% asset_img '4-5.png' %}\n上图中，很明显的标出了：自定义函数Foo.__proto__指向Function.prototype，Object.__proto__指向Function.prototype，唉，怎么还有一个……Function.__proto__指向Function.prototype？这不成了循环引用了？\n\n对！是一个环形结构。\n\n其实稍微想一下就明白了。Function也是一个函数，函数是一种对象，也有__proto__属性。既然是函数，那么它一定是被Function创建。所以——Function是被自身创建的。所以它的__proto__指向了自身的Prototype。\n\n\n\n篇幅不少了，估计也都看烦了。快结束了。\n\n最后一个问题：Function.prototype指向的对象，它的__proto__是不是也指向Object.prototype？\n\n答案是肯定的。因为Function.prototype指向的对象也是一个普通的被Object创建的对象，所以也遵循基本的规则。\n{% asset_img '4-6.png' %}\nOK 本节结束，是不是很乱？\n\n乱很正常。那这一节就让它先乱着，下一节我们将请另一个老朋友来帮忙，把它理清楚。这位老朋友就是——instanceof。\n\n具体内容，请看下节分解。\n","source":"_posts/2017-04-16-深入理解javascript原型和闭包-4-隐式原型.md","raw":"---\ntitle: 深入理解javascript原型和闭包(4)--隐式原型\ncategories: 王福朋-深入理解javascript原型和闭包系列\ntags:\n  - javascript\n  - 原型链\n  - 闭包\ndate: 2017-04-16 22:34:28\n---\n{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3979290.html 深入理解javascript原型和闭包（4）——隐式原型 %}\n{% endblockquote %}\n{% raw %}\n   <span style=\"color: #ff0000;\">注意：本文不是javascript基础教程，如果你没有接触过原型的基本知识，应该先去了解一下，推荐看《javascript高级程序设计（第三版）》第6章：面向对象的程序设计。</span>\n{% endraw %}\n\n\n上节已经提到，{% raw %}\n                  <span style=\"background-color: #87daff;\">每个函数function都有一个prototype</span>\n              {% endraw %}，即原型。这里再加一句话——{% raw %}\n                                                          <span style=\"background-color: #87daff;\">每个对象都有一个__proto__</span>\n                                                      {% endraw %}，可成为隐式原型。\n\n这个__proto__是一个隐藏的属性，javascript不希望开发者用到这个属性值，有的低版本浏览器甚至不支持这个属性值。所以你在Visual Studio 2012这样很高级很智能的编辑器中，都不会有__proto__的智能提示，但是你不用管它，直接写出来就是了。\n```javascript\nvar obj = {};\nconsole.log(obj.__proto__);\n```\n{% asset_img '4-1.png' %}\n上面截图看来，obj.__proto__和Object.prototype的属性一样！这么巧！\n\n答案就是一样。\n\nobj这个对象本质上是被Object函数创建的，因此obj.__proto__=== Object.prototype。我们可以用一个图来表示。\n{% asset_img '4-2.png' %}\n即，{% raw %}\n        <span style=\"background-color: #87daff;\">每个对象都有一个__proto__属性，指向创建该对象的函数的prototype</span>\n    {% endraw %}。\n<!-- more -->\n\n\n\n那么上图中的“Object prototype”也是一个对象，它的__proto__指向哪里？\n\n好问题！\n\n在说明“Object prototype”之前，先说一下自定义函数的prototype。自定义函数的prototype本质上就是和 var obj = {} 是一样的，都是被Object创建，所以它的__proto__指向的就是Object.prototype。\n\n但是{% raw %}\n          <span style=\"background-color: #87daff;\">Object.prototype确实一个特例——它的__proto__指向的是null，切记切记</span>\n      {% endraw %}！\n{% asset_img '4-3.png' %}\n还有——函数也是一种对象，函数也有__proto__吗？\n\n又一个好问题！——当然有。\n\n函数也不是从石头缝里蹦出来的，函数也是被创建出来的。谁创建了函数呢？——Function——注意这个大写的“F”。\n\n且看如下代码。\n{% asset_img '4-4.png' %}\n以上代码中，第一种方式是比较传统的函数创建方式，第二种是用new Functoin创建。\n\n{% raw %}\n   <span style=\"color: #ff0000;\">首先根本不推荐用第二种方式</span>\n{% endraw %}。\n\n这里只是向大家演示，函数是被Function创建的。\n\n\n\n好了，根据上面说的一句话——对象的__proto__指向的是创建它的函数的prototype，就会出现：Object.__proto__ === Function.prototype。用一个图来表示。\n{% asset_img '4-5.png' %}\n上图中，很明显的标出了：自定义函数Foo.__proto__指向Function.prototype，Object.__proto__指向Function.prototype，唉，怎么还有一个……Function.__proto__指向Function.prototype？这不成了循环引用了？\n\n对！是一个环形结构。\n\n其实稍微想一下就明白了。Function也是一个函数，函数是一种对象，也有__proto__属性。既然是函数，那么它一定是被Function创建。所以——Function是被自身创建的。所以它的__proto__指向了自身的Prototype。\n\n\n\n篇幅不少了，估计也都看烦了。快结束了。\n\n最后一个问题：Function.prototype指向的对象，它的__proto__是不是也指向Object.prototype？\n\n答案是肯定的。因为Function.prototype指向的对象也是一个普通的被Object创建的对象，所以也遵循基本的规则。\n{% asset_img '4-6.png' %}\nOK 本节结束，是不是很乱？\n\n乱很正常。那这一节就让它先乱着，下一节我们将请另一个老朋友来帮忙，把它理清楚。这位老朋友就是——instanceof。\n\n具体内容，请看下节分解。\n","slug":"深入理解javascript原型和闭包-4-隐式原型","published":1,"updated":"2017-04-16T17:39:37.962Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1lk6eac0008youarpkwhfhh","content":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3979290.html\" target=\"_blank\" rel=\"external\">深入理解javascript原型和闭包（4）——隐式原型</a></cite></footer></blockquote>\n\n   <span style=\"color: #ff0000;\">注意：本文不是javascript基础教程，如果你没有接触过原型的基本知识，应该先去了解一下，推荐看《javascript高级程序设计（第三版）》第6章：面向对象的程序设计。</span>\n\n<p>上节已经提到，\n                  <span style=\"background-color: #87daff;\">每个函数function都有一个prototype</span>\n              ，即原型。这里再加一句话——\n                                                          <span style=\"background-color: #87daff;\">每个对象都有一个__proto__</span>\n                                                      ，可成为隐式原型。</p>\n<p>这个<strong>proto</strong>是一个隐藏的属性，javascript不希望开发者用到这个属性值，有的低版本浏览器甚至不支持这个属性值。所以你在Visual Studio 2012这样很高级很智能的编辑器中，都不会有<strong>proto</strong>的智能提示，但是你不用管它，直接写出来就是了。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(obj.__proto__);</div></pre></td></tr></table></figure></p>\n<img src=\"/2017/04/16/深入理解javascript原型和闭包-4-隐式原型/4-1.png\" alt=\"4-1.png\" title=\"\">\n<p>上面截图看来，obj.<strong>proto</strong>和Object.prototype的属性一样！这么巧！</p>\n<p>答案就是一样。</p>\n<p>obj这个对象本质上是被Object函数创建的，因此obj.<strong>proto</strong>=== Object.prototype。我们可以用一个图来表示。<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-4-隐式原型/4-2.png\" alt=\"4-2.png\" title=\"\"><br>即，\n        <span style=\"background-color: #87daff;\">每个对象都有一个__proto__属性，指向创建该对象的函数的prototype</span>\n    。<br><a id=\"more\"></a></p>\n<p>那么上图中的“Object prototype”也是一个对象，它的<strong>proto</strong>指向哪里？</p>\n<p>好问题！</p>\n<p>在说明“Object prototype”之前，先说一下自定义函数的prototype。自定义函数的prototype本质上就是和 var obj = {} 是一样的，都是被Object创建，所以它的<strong>proto</strong>指向的就是Object.prototype。</p>\n<p>但是\n          <span style=\"background-color: #87daff;\">Object.prototype确实一个特例——它的__proto__指向的是null，切记切记</span>\n      ！<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-4-隐式原型/4-3.png\" alt=\"4-3.png\" title=\"\"><br>还有——函数也是一种对象，函数也有<strong>proto</strong>吗？</p>\n<p>又一个好问题！——当然有。</p>\n<p>函数也不是从石头缝里蹦出来的，函数也是被创建出来的。谁创建了函数呢？——Function——注意这个大写的“F”。</p>\n<p>且看如下代码。<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-4-隐式原型/4-4.png\" alt=\"4-4.png\" title=\"\"><br>以上代码中，第一种方式是比较传统的函数创建方式，第二种是用new Functoin创建。</p>\n\n   <span style=\"color: #ff0000;\">首先根本不推荐用第二种方式</span>\n。<br><br>这里只是向大家演示，函数是被Function创建的。<br><br><br><br>好了，根据上面说的一句话——对象的<strong>proto</strong>指向的是创建它的函数的prototype，就会出现：Object.<strong>proto</strong> === Function.prototype。用一个图来表示。<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-4-隐式原型/4-5.png\" alt=\"4-5.png\" title=\"\">\n<p>上图中，很明显的标出了：自定义函数Foo.<strong>proto</strong>指向Function.prototype，Object.<strong>proto</strong>指向Function.prototype，唉，怎么还有一个……Function.<strong>proto</strong>指向Function.prototype？这不成了循环引用了？</p>\n<p>对！是一个环形结构。</p>\n<p>其实稍微想一下就明白了。Function也是一个函数，函数是一种对象，也有<strong>proto</strong>属性。既然是函数，那么它一定是被Function创建。所以——Function是被自身创建的。所以它的<strong>proto</strong>指向了自身的Prototype。</p>\n<p>篇幅不少了，估计也都看烦了。快结束了。</p>\n<p>最后一个问题：Function.prototype指向的对象，它的<strong>proto</strong>是不是也指向Object.prototype？</p>\n<p>答案是肯定的。因为Function.prototype指向的对象也是一个普通的被Object创建的对象，所以也遵循基本的规则。<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-4-隐式原型/4-6.png\" alt=\"4-6.png\" title=\"\"><br>OK 本节结束，是不是很乱？</p>\n<p>乱很正常。那这一节就让它先乱着，下一节我们将请另一个老朋友来帮忙，把它理清楚。这位老朋友就是——instanceof。</p>\n<p>具体内容，请看下节分解。</p>\n","site":{"data":{}},"excerpt":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3979290.html\">深入理解javascript原型和闭包（4）——隐式原型</a></cite></footer></blockquote>\n\n   <span style=\"color: #ff0000;\">注意：本文不是javascript基础教程，如果你没有接触过原型的基本知识，应该先去了解一下，推荐看《javascript高级程序设计（第三版）》第6章：面向对象的程序设计。</span>\n\n<p>上节已经提到，\n                  <span style=\"background-color: #87daff;\">每个函数function都有一个prototype</span>\n              ，即原型。这里再加一句话——\n                                                          <span style=\"background-color: #87daff;\">每个对象都有一个__proto__</span>\n                                                      ，可成为隐式原型。</p>\n<p>这个<strong>proto</strong>是一个隐藏的属性，javascript不希望开发者用到这个属性值，有的低版本浏览器甚至不支持这个属性值。所以你在Visual Studio 2012这样很高级很智能的编辑器中，都不会有<strong>proto</strong>的智能提示，但是你不用管它，直接写出来就是了。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(obj.__proto__);</div></pre></td></tr></table></figure></p>\n<img src=\"/2017/04/16/深入理解javascript原型和闭包-4-隐式原型/4-1.png\" alt=\"4-1.png\" title=\"\">\n<p>上面截图看来，obj.<strong>proto</strong>和Object.prototype的属性一样！这么巧！</p>\n<p>答案就是一样。</p>\n<p>obj这个对象本质上是被Object函数创建的，因此obj.<strong>proto</strong>=== Object.prototype。我们可以用一个图来表示。<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-4-隐式原型/4-2.png\" alt=\"4-2.png\" title=\"\"><br>即，\n        <span style=\"background-color: #87daff;\">每个对象都有一个__proto__属性，指向创建该对象的函数的prototype</span>\n    。<br>","more":"</p>\n<p>那么上图中的“Object prototype”也是一个对象，它的<strong>proto</strong>指向哪里？</p>\n<p>好问题！</p>\n<p>在说明“Object prototype”之前，先说一下自定义函数的prototype。自定义函数的prototype本质上就是和 var obj = {} 是一样的，都是被Object创建，所以它的<strong>proto</strong>指向的就是Object.prototype。</p>\n<p>但是\n          <span style=\"background-color: #87daff;\">Object.prototype确实一个特例——它的__proto__指向的是null，切记切记</span>\n      ！<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-4-隐式原型/4-3.png\" alt=\"4-3.png\" title=\"\"><br>还有——函数也是一种对象，函数也有<strong>proto</strong>吗？</p>\n<p>又一个好问题！——当然有。</p>\n<p>函数也不是从石头缝里蹦出来的，函数也是被创建出来的。谁创建了函数呢？——Function——注意这个大写的“F”。</p>\n<p>且看如下代码。<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-4-隐式原型/4-4.png\" alt=\"4-4.png\" title=\"\"><br>以上代码中，第一种方式是比较传统的函数创建方式，第二种是用new Functoin创建。</p>\n\n   <span style=\"color: #ff0000;\">首先根本不推荐用第二种方式</span>\n。<br><br>这里只是向大家演示，函数是被Function创建的。<br><br><br><br>好了，根据上面说的一句话——对象的<strong>proto</strong>指向的是创建它的函数的prototype，就会出现：Object.<strong>proto</strong> === Function.prototype。用一个图来表示。<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-4-隐式原型/4-5.png\" alt=\"4-5.png\" title=\"\">\n<p>上图中，很明显的标出了：自定义函数Foo.<strong>proto</strong>指向Function.prototype，Object.<strong>proto</strong>指向Function.prototype，唉，怎么还有一个……Function.<strong>proto</strong>指向Function.prototype？这不成了循环引用了？</p>\n<p>对！是一个环形结构。</p>\n<p>其实稍微想一下就明白了。Function也是一个函数，函数是一种对象，也有<strong>proto</strong>属性。既然是函数，那么它一定是被Function创建。所以——Function是被自身创建的。所以它的<strong>proto</strong>指向了自身的Prototype。</p>\n<p>篇幅不少了，估计也都看烦了。快结束了。</p>\n<p>最后一个问题：Function.prototype指向的对象，它的<strong>proto</strong>是不是也指向Object.prototype？</p>\n<p>答案是肯定的。因为Function.prototype指向的对象也是一个普通的被Object创建的对象，所以也遵循基本的规则。<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-4-隐式原型/4-6.png\" alt=\"4-6.png\" title=\"\"><br>OK 本节结束，是不是很乱？</p>\n<p>乱很正常。那这一节就让它先乱着，下一节我们将请另一个老朋友来帮忙，把它理清楚。这位老朋友就是——instanceof。</p>\n<p>具体内容，请看下节分解。</p>"},{"title":"深入理解javascript原型和闭包(5)--instanceof","date":"2017-04-16T14:54:44.000Z","_content":"{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3979533.html 深入理解javascript原型和闭包（5）——instanceof %}\n{% endblockquote %}\n又介绍一个老朋友——instanceof。\n\n对于值类型，你可以通过typeof判断，string/number/boolean都很清楚，但是typeof在判断到引用类型的时候，返回值只有object/function，你不知道它到底是一个object对象，还是数组，还是new Number等等。\n\n这个时候就需要用到instanceof。例如：\n```javascript\nfunction Foo() {}\nvar f1 = new Foo()\nconsole.log(f1 instanceof Foo); //  true\nconsole.log(f1 instanceof Object); //  true\n```\n上图中，f1这个对象是被Foo创建，但是“f1 instanceof Object”为什么是true呢？\n\n\n\n至于为什么过会儿再说，先把instanceof判断的规则告诉大家。根据以上代码看下图：\n{% asset_img '5-1.png' %}\nInstanceof运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。\n\nInstanceof的判断队则是：{% raw %}\n                            <span style=\"background-color: #87daff;\">沿着A的__proto__这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false</span>\n                        {% endraw %}。\n\n按照以上规则，大家看看“ f1 instanceof Object ”这句代码是不是true？ 根据上图很容易就能看出来，就是true。\n\n\n\n通过上以规则，你可以解释很多比较怪异的现象，例如：\n```javascript\nconsole.log(Object instanceof Function); //  true\nconsole.log(Function instanceof Object); //  true\nconsole.log(Function instanceof Function); //  true\n```\n这些看似很混乱的东西，答案却都是true，这是为何？\n<!-- more -->\n\n正好，这里也接上了咱们上一节说的“乱”。\n\n上一节咱们贴了好多的图片，其实那些图片是可以联合成一个整体的，即：\n{% asset_img '5-2.png' %}\n看这个图片，千万不要嫌烦，必须一条线一条线挨着分析。如果上一节你看的比较仔细，再结合刚才咱们介绍的instanceof的概念，相信能看懂这个图片的内容。\n\n看看这个图片，你也就知道为何上面三个看似混乱的语句返回的是true了。\n\n\n\n问题又出来了。Instanceof这样设计，到底有什么用？到底instanceof想表达什么呢？\n\n重点就这样被这位老朋友给引出来了——{% raw %}\n                                      <span style=\"background-color: #87daff;\">继承</span>\n                                  {% endraw %}——{% raw %}\n                                                      <span style=\"background-color: #87daff;\">原型链</span>\n                                                  {% endraw %}。\n\n即，{% raw %}\n        <span style=\"background-color: #87daff;\">instanceof表示的就是一种继承关系，或者原型链的结构</span>\n    {% endraw %}。请看下节分解。\n\n（注：本节的图片来源于http://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/figure1.jpg）","source":"_posts/2017-04-16-深入理解javascript原型和闭包-5-instanceof.md","raw":"---\ntitle: 深入理解javascript原型和闭包(5)--instanceof\ncategories: 王福朋-深入理解javascript原型和闭包系列\ntags:\n  - javascript\n  - 原型链\n  - 闭包\ndate: 2017-04-16 22:54:44\n---\n{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3979533.html 深入理解javascript原型和闭包（5）——instanceof %}\n{% endblockquote %}\n又介绍一个老朋友——instanceof。\n\n对于值类型，你可以通过typeof判断，string/number/boolean都很清楚，但是typeof在判断到引用类型的时候，返回值只有object/function，你不知道它到底是一个object对象，还是数组，还是new Number等等。\n\n这个时候就需要用到instanceof。例如：\n```javascript\nfunction Foo() {}\nvar f1 = new Foo()\nconsole.log(f1 instanceof Foo); //  true\nconsole.log(f1 instanceof Object); //  true\n```\n上图中，f1这个对象是被Foo创建，但是“f1 instanceof Object”为什么是true呢？\n\n\n\n至于为什么过会儿再说，先把instanceof判断的规则告诉大家。根据以上代码看下图：\n{% asset_img '5-1.png' %}\nInstanceof运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。\n\nInstanceof的判断队则是：{% raw %}\n                            <span style=\"background-color: #87daff;\">沿着A的__proto__这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false</span>\n                        {% endraw %}。\n\n按照以上规则，大家看看“ f1 instanceof Object ”这句代码是不是true？ 根据上图很容易就能看出来，就是true。\n\n\n\n通过上以规则，你可以解释很多比较怪异的现象，例如：\n```javascript\nconsole.log(Object instanceof Function); //  true\nconsole.log(Function instanceof Object); //  true\nconsole.log(Function instanceof Function); //  true\n```\n这些看似很混乱的东西，答案却都是true，这是为何？\n<!-- more -->\n\n正好，这里也接上了咱们上一节说的“乱”。\n\n上一节咱们贴了好多的图片，其实那些图片是可以联合成一个整体的，即：\n{% asset_img '5-2.png' %}\n看这个图片，千万不要嫌烦，必须一条线一条线挨着分析。如果上一节你看的比较仔细，再结合刚才咱们介绍的instanceof的概念，相信能看懂这个图片的内容。\n\n看看这个图片，你也就知道为何上面三个看似混乱的语句返回的是true了。\n\n\n\n问题又出来了。Instanceof这样设计，到底有什么用？到底instanceof想表达什么呢？\n\n重点就这样被这位老朋友给引出来了——{% raw %}\n                                      <span style=\"background-color: #87daff;\">继承</span>\n                                  {% endraw %}——{% raw %}\n                                                      <span style=\"background-color: #87daff;\">原型链</span>\n                                                  {% endraw %}。\n\n即，{% raw %}\n        <span style=\"background-color: #87daff;\">instanceof表示的就是一种继承关系，或者原型链的结构</span>\n    {% endraw %}。请看下节分解。\n\n（注：本节的图片来源于http://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/figure1.jpg）","slug":"深入理解javascript原型和闭包-5-instanceof","published":1,"updated":"2017-04-16T17:39:50.500Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1lk6eak000ayouahdlqrw5i","content":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3979533.html\" target=\"_blank\" rel=\"external\">深入理解javascript原型和闭包（5）——instanceof</a></cite></footer></blockquote>\n<p>又介绍一个老朋友——instanceof。</p>\n<p>对于值类型，你可以通过typeof判断，string/number/boolean都很清楚，但是typeof在判断到引用类型的时候，返回值只有object/function，你不知道它到底是一个object对象，还是数组，还是new Number等等。</p>\n<p>这个时候就需要用到instanceof。例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> f1 = <span class=\"keyword\">new</span> Foo()</div><div class=\"line\"><span class=\"built_in\">console</span>.log(f1 <span class=\"keyword\">instanceof</span> Foo); <span class=\"comment\">//  true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(f1 <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>); <span class=\"comment\">//  true</span></div></pre></td></tr></table></figure></p>\n<p>上图中，f1这个对象是被Foo创建，但是“f1 instanceof Object”为什么是true呢？</p>\n<p>至于为什么过会儿再说，先把instanceof判断的规则告诉大家。根据以上代码看下图：<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-5-instanceof/5-1.png\" alt=\"5-1.png\" title=\"\"><br>Instanceof运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。</p>\n<p>Instanceof的判断队则是：\n                            <span style=\"background-color: #87daff;\">沿着A的__proto__这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false</span>\n                        。</p>\n<p>按照以上规则，大家看看“ f1 instanceof Object ”这句代码是不是true？ 根据上图很容易就能看出来，就是true。</p>\n<p>通过上以规则，你可以解释很多比较怪异的现象，例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span>); <span class=\"comment\">//  true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Function</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>); <span class=\"comment\">//  true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Function</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span>); <span class=\"comment\">//  true</span></div></pre></td></tr></table></figure></p>\n<p>这些看似很混乱的东西，答案却都是true，这是为何？<br><a id=\"more\"></a></p>\n<p>正好，这里也接上了咱们上一节说的“乱”。</p>\n<p>上一节咱们贴了好多的图片，其实那些图片是可以联合成一个整体的，即：<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-5-instanceof/5-2.png\" alt=\"5-2.png\" title=\"\"><br>看这个图片，千万不要嫌烦，必须一条线一条线挨着分析。如果上一节你看的比较仔细，再结合刚才咱们介绍的instanceof的概念，相信能看懂这个图片的内容。</p>\n<p>看看这个图片，你也就知道为何上面三个看似混乱的语句返回的是true了。</p>\n<p>问题又出来了。Instanceof这样设计，到底有什么用？到底instanceof想表达什么呢？</p>\n<p>重点就这样被这位老朋友给引出来了——\n                                      <span style=\"background-color: #87daff;\">继承</span>\n                                  ——\n                                                      <span style=\"background-color: #87daff;\">原型链</span>\n                                                  。</p>\n<p>即，\n        <span style=\"background-color: #87daff;\">instanceof表示的就是一种继承关系，或者原型链的结构</span>\n    。请看下节分解。</p>\n<p>（注：本节的图片来源于<a href=\"http://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/figure1.jpg）\" target=\"_blank\" rel=\"external\">http://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/figure1.jpg）</a></p>\n","site":{"data":{}},"excerpt":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3979533.html\">深入理解javascript原型和闭包（5）——instanceof</a></cite></footer></blockquote>\n<p>又介绍一个老朋友——instanceof。</p>\n<p>对于值类型，你可以通过typeof判断，string/number/boolean都很清楚，但是typeof在判断到引用类型的时候，返回值只有object/function，你不知道它到底是一个object对象，还是数组，还是new Number等等。</p>\n<p>这个时候就需要用到instanceof。例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> f1 = <span class=\"keyword\">new</span> Foo()</div><div class=\"line\"><span class=\"built_in\">console</span>.log(f1 <span class=\"keyword\">instanceof</span> Foo); <span class=\"comment\">//  true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(f1 <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>); <span class=\"comment\">//  true</span></div></pre></td></tr></table></figure></p>\n<p>上图中，f1这个对象是被Foo创建，但是“f1 instanceof Object”为什么是true呢？</p>\n<p>至于为什么过会儿再说，先把instanceof判断的规则告诉大家。根据以上代码看下图：<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-5-instanceof/5-1.png\" alt=\"5-1.png\" title=\"\"><br>Instanceof运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。</p>\n<p>Instanceof的判断队则是：\n                            <span style=\"background-color: #87daff;\">沿着A的__proto__这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false</span>\n                        。</p>\n<p>按照以上规则，大家看看“ f1 instanceof Object ”这句代码是不是true？ 根据上图很容易就能看出来，就是true。</p>\n<p>通过上以规则，你可以解释很多比较怪异的现象，例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span>); <span class=\"comment\">//  true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Function</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>); <span class=\"comment\">//  true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Function</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span>); <span class=\"comment\">//  true</span></div></pre></td></tr></table></figure></p>\n<p>这些看似很混乱的东西，答案却都是true，这是为何？<br>","more":"</p>\n<p>正好，这里也接上了咱们上一节说的“乱”。</p>\n<p>上一节咱们贴了好多的图片，其实那些图片是可以联合成一个整体的，即：<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-5-instanceof/5-2.png\" alt=\"5-2.png\" title=\"\"><br>看这个图片，千万不要嫌烦，必须一条线一条线挨着分析。如果上一节你看的比较仔细，再结合刚才咱们介绍的instanceof的概念，相信能看懂这个图片的内容。</p>\n<p>看看这个图片，你也就知道为何上面三个看似混乱的语句返回的是true了。</p>\n<p>问题又出来了。Instanceof这样设计，到底有什么用？到底instanceof想表达什么呢？</p>\n<p>重点就这样被这位老朋友给引出来了——\n                                      <span style=\"background-color: #87daff;\">继承</span>\n                                  ——\n                                                      <span style=\"background-color: #87daff;\">原型链</span>\n                                                  。</p>\n<p>即，\n        <span style=\"background-color: #87daff;\">instanceof表示的就是一种继承关系，或者原型链的结构</span>\n    。请看下节分解。</p>\n<p>（注：本节的图片来源于<a href=\"http://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/figure1.jpg）\">http://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/figure1.jpg）</a></p>"},{"title":"深入理解javascript原型和闭包(6)--继承","date":"2017-04-16T15:06:21.000Z","_content":"{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3979985.html 深入理解javascript原型和闭包（6）——继承 %}\n{% endblockquote %}\n为何用“继承”为标题，而不用“原型链”？\n\n原型链如果解释清楚了很容易理解，不会与常用的java/C#产生混淆。而“继承”确实常用面向对象语言中最基本的概念，但是java中的继承与javascript中的继承又完全是两回事儿。因此，这里把“继承”着重拿出来，就为了体现这个不同。\n\n\n\njavascript中的继承是通过原型链来体现的。先看几句代码\n```javascript\nfunction Foo() { }\nvar f1 = new Foo()\n\nf1.a = 10\n\nFoo.prototype.a = 100\nFoo.prototype.b = 200\n\nconsole.log(f1.a) //  10\nconsole.log(f1.b) //  200\n```\n以上代码中，f1是Foo函数new出来的对象，f1.a是f1对象的基本属性，f1.b是怎么来的呢？——从Foo.prototype得来，因为f1.__proto__指向的是Foo.prototype\n\n{% raw %}\n  <span style=\"background-color: #87daff;\">访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找，这就是原型链</span>\n{% endraw %}。\n\n看图说话：\n{% asset_img '6-1.png' %}\n上图中，访问f1.b时，f1的基本属性中没有b，于是沿着__proto__找到了Foo.prototype.b。\n<!-- more -->\n\n\n\n那么我们在实际应用中如何区分一个属性到底是基本的还是从原型中找到的呢？大家可能都知道答案了——hasOwnProperty，特别是在for…in…循环中，一定要注意。\n{% asset_img '6-2.png' %}\n等等，不对！ f1的这个hasOwnProperty方法是从哪里来的？ f1本身没有，Foo.prototype中也没有，哪儿来的？\n\n好问题。\n\n它是从Object.prototype中来的，请看图：\n{% asset_img '6-3.png' %}\n对象的原型链是沿着__proto__这条线走的，因此在查找f1.hasOwnProperty属性时，就会顺着原型链一直查找到Object.prototype。\n\n\n\n由于所有的对象的原型链都会找到Object.prototype，因此所有的对象都会有Object.prototype的方法。这就是所谓的“继承”。\n\n当然这只是一个例子，你可以自定义函数和对象来实现自己的继承。\n\n\n\n说一个函数的例子吧。\n\n我们都知道每个函数都有call，apply方法，都有length，arguments，caller等属性。为什么每个函数都有？这肯定是“继承”的。函数由Function函数创建，因此继承的Function.prototype中的方法。不信可以请微软的Visual Studio老师给我们验证一下：\n{% asset_img '6-4.png' %}\n看到了吧，有call、length等这些属性。\n\n那怎么还有hasOwnProperty呢？——那是Function.prototype继承自Object.prototype的方法。有疑问可以看看上一节将instanceof时候那个大图，看看Function.prototype.__proto__是否指向Object.prototype。\n\n\n\n原型、原型链，大家都明白了吗？","source":"_posts/2017-04-16-深入理解javascript原型和闭包-6-继承.md","raw":"---\ntitle: 深入理解javascript原型和闭包(6)--继承\ncategories: 王福朋-深入理解javascript原型和闭包系列\ntags:\n  - javascript\n  - 原型链\n  - 闭包\ndate: 2017-04-16 23:06:21\n---\n{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3979985.html 深入理解javascript原型和闭包（6）——继承 %}\n{% endblockquote %}\n为何用“继承”为标题，而不用“原型链”？\n\n原型链如果解释清楚了很容易理解，不会与常用的java/C#产生混淆。而“继承”确实常用面向对象语言中最基本的概念，但是java中的继承与javascript中的继承又完全是两回事儿。因此，这里把“继承”着重拿出来，就为了体现这个不同。\n\n\n\njavascript中的继承是通过原型链来体现的。先看几句代码\n```javascript\nfunction Foo() { }\nvar f1 = new Foo()\n\nf1.a = 10\n\nFoo.prototype.a = 100\nFoo.prototype.b = 200\n\nconsole.log(f1.a) //  10\nconsole.log(f1.b) //  200\n```\n以上代码中，f1是Foo函数new出来的对象，f1.a是f1对象的基本属性，f1.b是怎么来的呢？——从Foo.prototype得来，因为f1.__proto__指向的是Foo.prototype\n\n{% raw %}\n  <span style=\"background-color: #87daff;\">访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找，这就是原型链</span>\n{% endraw %}。\n\n看图说话：\n{% asset_img '6-1.png' %}\n上图中，访问f1.b时，f1的基本属性中没有b，于是沿着__proto__找到了Foo.prototype.b。\n<!-- more -->\n\n\n\n那么我们在实际应用中如何区分一个属性到底是基本的还是从原型中找到的呢？大家可能都知道答案了——hasOwnProperty，特别是在for…in…循环中，一定要注意。\n{% asset_img '6-2.png' %}\n等等，不对！ f1的这个hasOwnProperty方法是从哪里来的？ f1本身没有，Foo.prototype中也没有，哪儿来的？\n\n好问题。\n\n它是从Object.prototype中来的，请看图：\n{% asset_img '6-3.png' %}\n对象的原型链是沿着__proto__这条线走的，因此在查找f1.hasOwnProperty属性时，就会顺着原型链一直查找到Object.prototype。\n\n\n\n由于所有的对象的原型链都会找到Object.prototype，因此所有的对象都会有Object.prototype的方法。这就是所谓的“继承”。\n\n当然这只是一个例子，你可以自定义函数和对象来实现自己的继承。\n\n\n\n说一个函数的例子吧。\n\n我们都知道每个函数都有call，apply方法，都有length，arguments，caller等属性。为什么每个函数都有？这肯定是“继承”的。函数由Function函数创建，因此继承的Function.prototype中的方法。不信可以请微软的Visual Studio老师给我们验证一下：\n{% asset_img '6-4.png' %}\n看到了吧，有call、length等这些属性。\n\n那怎么还有hasOwnProperty呢？——那是Function.prototype继承自Object.prototype的方法。有疑问可以看看上一节将instanceof时候那个大图，看看Function.prototype.__proto__是否指向Object.prototype。\n\n\n\n原型、原型链，大家都明白了吗？","slug":"深入理解javascript原型和闭包-6-继承","published":1,"updated":"2017-04-16T17:40:00.937Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1lk6ear000dyouanp1nuhby","content":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3979985.html\" target=\"_blank\" rel=\"external\">深入理解javascript原型和闭包（6）——继承</a></cite></footer></blockquote>\n<p>为何用“继承”为标题，而不用“原型链”？</p>\n<p>原型链如果解释清楚了很容易理解，不会与常用的java/C#产生混淆。而“继承”确实常用面向对象语言中最基本的概念，但是java中的继承与javascript中的继承又完全是两回事儿。因此，这里把“继承”着重拿出来，就为了体现这个不同。</p>\n<p>javascript中的继承是通过原型链来体现的。先看几句代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123; &#125;</div><div class=\"line\"><span class=\"keyword\">var</span> f1 = <span class=\"keyword\">new</span> Foo()</div><div class=\"line\"></div><div class=\"line\">f1.a = <span class=\"number\">10</span></div><div class=\"line\"></div><div class=\"line\">Foo.prototype.a = <span class=\"number\">100</span></div><div class=\"line\">Foo.prototype.b = <span class=\"number\">200</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(f1.a) <span class=\"comment\">//  10</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(f1.b) <span class=\"comment\">//  200</span></div></pre></td></tr></table></figure></p>\n<p>以上代码中，f1是Foo函数new出来的对象，f1.a是f1对象的基本属性，f1.b是怎么来的呢？——从Foo.prototype得来，因为f1.<strong>proto</strong>指向的是Foo.prototype</p>\n\n  <span style=\"background-color: #87daff;\">访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找，这就是原型链</span>\n。<br><br>看图说话：<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-6-继承/6-1.png\" alt=\"6-1.png\" title=\"\">\n<p>上图中，访问f1.b时，f1的基本属性中没有b，于是沿着<strong>proto</strong>找到了Foo.prototype.b。<br><a id=\"more\"></a></p>\n<p>那么我们在实际应用中如何区分一个属性到底是基本的还是从原型中找到的呢？大家可能都知道答案了——hasOwnProperty，特别是在for…in…循环中，一定要注意。<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-6-继承/6-2.png\" alt=\"6-2.png\" title=\"\"><br>等等，不对！ f1的这个hasOwnProperty方法是从哪里来的？ f1本身没有，Foo.prototype中也没有，哪儿来的？</p>\n<p>好问题。</p>\n<p>它是从Object.prototype中来的，请看图：<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-6-继承/6-3.png\" alt=\"6-3.png\" title=\"\"><br>对象的原型链是沿着<strong>proto</strong>这条线走的，因此在查找f1.hasOwnProperty属性时，就会顺着原型链一直查找到Object.prototype。</p>\n<p>由于所有的对象的原型链都会找到Object.prototype，因此所有的对象都会有Object.prototype的方法。这就是所谓的“继承”。</p>\n<p>当然这只是一个例子，你可以自定义函数和对象来实现自己的继承。</p>\n<p>说一个函数的例子吧。</p>\n<p>我们都知道每个函数都有call，apply方法，都有length，arguments，caller等属性。为什么每个函数都有？这肯定是“继承”的。函数由Function函数创建，因此继承的Function.prototype中的方法。不信可以请微软的Visual Studio老师给我们验证一下：<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-6-继承/6-4.png\" alt=\"6-4.png\" title=\"\"><br>看到了吧，有call、length等这些属性。</p>\n<p>那怎么还有hasOwnProperty呢？——那是Function.prototype继承自Object.prototype的方法。有疑问可以看看上一节将instanceof时候那个大图，看看Function.prototype.<strong>proto</strong>是否指向Object.prototype。</p>\n<p>原型、原型链，大家都明白了吗？</p>\n","site":{"data":{}},"excerpt":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3979985.html\">深入理解javascript原型和闭包（6）——继承</a></cite></footer></blockquote>\n<p>为何用“继承”为标题，而不用“原型链”？</p>\n<p>原型链如果解释清楚了很容易理解，不会与常用的java/C#产生混淆。而“继承”确实常用面向对象语言中最基本的概念，但是java中的继承与javascript中的继承又完全是两回事儿。因此，这里把“继承”着重拿出来，就为了体现这个不同。</p>\n<p>javascript中的继承是通过原型链来体现的。先看几句代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123; &#125;</div><div class=\"line\"><span class=\"keyword\">var</span> f1 = <span class=\"keyword\">new</span> Foo()</div><div class=\"line\"></div><div class=\"line\">f1.a = <span class=\"number\">10</span></div><div class=\"line\"></div><div class=\"line\">Foo.prototype.a = <span class=\"number\">100</span></div><div class=\"line\">Foo.prototype.b = <span class=\"number\">200</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(f1.a) <span class=\"comment\">//  10</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(f1.b) <span class=\"comment\">//  200</span></div></pre></td></tr></table></figure></p>\n<p>以上代码中，f1是Foo函数new出来的对象，f1.a是f1对象的基本属性，f1.b是怎么来的呢？——从Foo.prototype得来，因为f1.<strong>proto</strong>指向的是Foo.prototype</p>\n\n  <span style=\"background-color: #87daff;\">访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找，这就是原型链</span>\n。<br><br>看图说话：<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-6-继承/6-1.png\" alt=\"6-1.png\" title=\"\">\n<p>上图中，访问f1.b时，f1的基本属性中没有b，于是沿着<strong>proto</strong>找到了Foo.prototype.b。<br>","more":"</p>\n<p>那么我们在实际应用中如何区分一个属性到底是基本的还是从原型中找到的呢？大家可能都知道答案了——hasOwnProperty，特别是在for…in…循环中，一定要注意。<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-6-继承/6-2.png\" alt=\"6-2.png\" title=\"\"><br>等等，不对！ f1的这个hasOwnProperty方法是从哪里来的？ f1本身没有，Foo.prototype中也没有，哪儿来的？</p>\n<p>好问题。</p>\n<p>它是从Object.prototype中来的，请看图：<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-6-继承/6-3.png\" alt=\"6-3.png\" title=\"\"><br>对象的原型链是沿着<strong>proto</strong>这条线走的，因此在查找f1.hasOwnProperty属性时，就会顺着原型链一直查找到Object.prototype。</p>\n<p>由于所有的对象的原型链都会找到Object.prototype，因此所有的对象都会有Object.prototype的方法。这就是所谓的“继承”。</p>\n<p>当然这只是一个例子，你可以自定义函数和对象来实现自己的继承。</p>\n<p>说一个函数的例子吧。</p>\n<p>我们都知道每个函数都有call，apply方法，都有length，arguments，caller等属性。为什么每个函数都有？这肯定是“继承”的。函数由Function函数创建，因此继承的Function.prototype中的方法。不信可以请微软的Visual Studio老师给我们验证一下：<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-6-继承/6-4.png\" alt=\"6-4.png\" title=\"\"><br>看到了吧，有call、length等这些属性。</p>\n<p>那怎么还有hasOwnProperty呢？——那是Function.prototype继承自Object.prototype的方法。有疑问可以看看上一节将instanceof时候那个大图，看看Function.prototype.<strong>proto</strong>是否指向Object.prototype。</p>\n<p>原型、原型链，大家都明白了吗？</p>"},{"title":"深入理解javascript原型和闭包(7)--原型的灵活性","date":"2017-04-16T15:15:19.000Z","_content":"{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3980065.html 深入理解javascript原型和闭包（7）——原型的灵活性 %}\n{% endblockquote %}\n在Java和C#中，你可以简单的理解class是一个模子，对象就是被这个模子压出来的一批一批月饼（中秋节刚过完）。压个啥样，就得是个啥样，不能随便动，动一动就坏了。\n\n而在javascript中，就没有模子了，月饼被换成了面团，你可以捏成自己想要的样子。\n\n\n\n首先，对象属性可以随时改动。\n\n对象或者函数，刚开始new出来之后，可能啥属性都没有。但是你可以这会儿加一个，过一会儿在加两个，非常灵活。\n\n在jQuery的源码中，对象被创建时什么属性都没有，都是代码一步一步执行时，一个一个加上的。\n{% asset_img '7-1.png' %}\n其次，如果继承的方法不合适，可以做出修改。\n```javascript\nvar obj = {a: 10, b: 20}\nconsole.log(obj.toString()) //  [object Object]\n\nvar arr = [1, 2, true]\nconsole.log(arr.toString()) //  1,2,true\n```\n如上代码，Object和Array的toString()方法不一样。肯定是Array.prototype.toString()方法做了修改。\n<!-- more -->\n\n同理，我也可以自定义一个函数，并自己去修改prototype.toString()方法。\n```javascript\nfunction Foo() { }\nvar f1 = new Foo()\n\nFoo.prototype.toString = function() {\n  return '王福朋'\n}\nconsole.log(f1.toString()) //  王福朋\n```\n最后，如果感觉当前缺少你要用的方法，可以自己去创建。\n\n例如在json2.js源码中，为Date、String、Number、Boolean方法添加一个toJSON的属性。\n{% asset_img '7-2.png' %}\n如果你要添加内置方法的原型属性，最好做一步判断，如果该属性不存在，则添加。如果本来就存在，就没必要再添加了。","source":"_posts/2017-04-16-深入理解javascript原型和闭包-7-原型的灵活性.md","raw":"---\ntitle: 深入理解javascript原型和闭包(7)--原型的灵活性\ncategories: 王福朋-深入理解javascript原型和闭包系列\ntags:\n  - javascript\n  - 原型链\n  - 闭包\ndate: 2017-04-16 23:15:19\n---\n{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3980065.html 深入理解javascript原型和闭包（7）——原型的灵活性 %}\n{% endblockquote %}\n在Java和C#中，你可以简单的理解class是一个模子，对象就是被这个模子压出来的一批一批月饼（中秋节刚过完）。压个啥样，就得是个啥样，不能随便动，动一动就坏了。\n\n而在javascript中，就没有模子了，月饼被换成了面团，你可以捏成自己想要的样子。\n\n\n\n首先，对象属性可以随时改动。\n\n对象或者函数，刚开始new出来之后，可能啥属性都没有。但是你可以这会儿加一个，过一会儿在加两个，非常灵活。\n\n在jQuery的源码中，对象被创建时什么属性都没有，都是代码一步一步执行时，一个一个加上的。\n{% asset_img '7-1.png' %}\n其次，如果继承的方法不合适，可以做出修改。\n```javascript\nvar obj = {a: 10, b: 20}\nconsole.log(obj.toString()) //  [object Object]\n\nvar arr = [1, 2, true]\nconsole.log(arr.toString()) //  1,2,true\n```\n如上代码，Object和Array的toString()方法不一样。肯定是Array.prototype.toString()方法做了修改。\n<!-- more -->\n\n同理，我也可以自定义一个函数，并自己去修改prototype.toString()方法。\n```javascript\nfunction Foo() { }\nvar f1 = new Foo()\n\nFoo.prototype.toString = function() {\n  return '王福朋'\n}\nconsole.log(f1.toString()) //  王福朋\n```\n最后，如果感觉当前缺少你要用的方法，可以自己去创建。\n\n例如在json2.js源码中，为Date、String、Number、Boolean方法添加一个toJSON的属性。\n{% asset_img '7-2.png' %}\n如果你要添加内置方法的原型属性，最好做一步判断，如果该属性不存在，则添加。如果本来就存在，就没必要再添加了。","slug":"深入理解javascript原型和闭包-7-原型的灵活性","published":1,"updated":"2017-04-16T17:40:17.673Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1lk6eaz000fyoua1wo63mqw","content":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3980065.html\" target=\"_blank\" rel=\"external\">深入理解javascript原型和闭包（7）——原型的灵活性</a></cite></footer></blockquote>\n<p>在Java和C#中，你可以简单的理解class是一个模子，对象就是被这个模子压出来的一批一批月饼（中秋节刚过完）。压个啥样，就得是个啥样，不能随便动，动一动就坏了。</p>\n<p>而在javascript中，就没有模子了，月饼被换成了面团，你可以捏成自己想要的样子。</p>\n<p>首先，对象属性可以随时改动。</p>\n<p>对象或者函数，刚开始new出来之后，可能啥属性都没有。但是你可以这会儿加一个，过一会儿在加两个，非常灵活。</p>\n<p>在jQuery的源码中，对象被创建时什么属性都没有，都是代码一步一步执行时，一个一个加上的。<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-7-原型的灵活性/7-1.png\" alt=\"7-1.png\" title=\"\"><br>其次，如果继承的方法不合适，可以做出修改。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">a</span>: <span class=\"number\">10</span>, <span class=\"attr\">b</span>: <span class=\"number\">20</span>&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(obj.toString()) <span class=\"comment\">//  [object Object]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"literal\">true</span>]</div><div class=\"line\"><span class=\"built_in\">console</span>.log(arr.toString()) <span class=\"comment\">//  1,2,true</span></div></pre></td></tr></table></figure></p>\n<p>如上代码，Object和Array的toString()方法不一样。肯定是Array.prototype.toString()方法做了修改。<br><a id=\"more\"></a></p>\n<p>同理，我也可以自定义一个函数，并自己去修改prototype.toString()方法。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123; &#125;</div><div class=\"line\"><span class=\"keyword\">var</span> f1 = <span class=\"keyword\">new</span> Foo()</div><div class=\"line\"></div><div class=\"line\">Foo.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'王福朋'</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(f1.toString()) <span class=\"comment\">//  王福朋</span></div></pre></td></tr></table></figure></p>\n<p>最后，如果感觉当前缺少你要用的方法，可以自己去创建。</p>\n<p>例如在json2.js源码中，为Date、String、Number、Boolean方法添加一个toJSON的属性。<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-7-原型的灵活性/7-2.png\" alt=\"7-2.png\" title=\"\"><br>如果你要添加内置方法的原型属性，最好做一步判断，如果该属性不存在，则添加。如果本来就存在，就没必要再添加了。</p>\n","site":{"data":{}},"excerpt":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3980065.html\">深入理解javascript原型和闭包（7）——原型的灵活性</a></cite></footer></blockquote>\n<p>在Java和C#中，你可以简单的理解class是一个模子，对象就是被这个模子压出来的一批一批月饼（中秋节刚过完）。压个啥样，就得是个啥样，不能随便动，动一动就坏了。</p>\n<p>而在javascript中，就没有模子了，月饼被换成了面团，你可以捏成自己想要的样子。</p>\n<p>首先，对象属性可以随时改动。</p>\n<p>对象或者函数，刚开始new出来之后，可能啥属性都没有。但是你可以这会儿加一个，过一会儿在加两个，非常灵活。</p>\n<p>在jQuery的源码中，对象被创建时什么属性都没有，都是代码一步一步执行时，一个一个加上的。<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-7-原型的灵活性/7-1.png\" alt=\"7-1.png\" title=\"\"><br>其次，如果继承的方法不合适，可以做出修改。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">a</span>: <span class=\"number\">10</span>, <span class=\"attr\">b</span>: <span class=\"number\">20</span>&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(obj.toString()) <span class=\"comment\">//  [object Object]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"literal\">true</span>]</div><div class=\"line\"><span class=\"built_in\">console</span>.log(arr.toString()) <span class=\"comment\">//  1,2,true</span></div></pre></td></tr></table></figure></p>\n<p>如上代码，Object和Array的toString()方法不一样。肯定是Array.prototype.toString()方法做了修改。<br>","more":"</p>\n<p>同理，我也可以自定义一个函数，并自己去修改prototype.toString()方法。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123; &#125;</div><div class=\"line\"><span class=\"keyword\">var</span> f1 = <span class=\"keyword\">new</span> Foo()</div><div class=\"line\"></div><div class=\"line\">Foo.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'王福朋'</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(f1.toString()) <span class=\"comment\">//  王福朋</span></div></pre></td></tr></table></figure></p>\n<p>最后，如果感觉当前缺少你要用的方法，可以自己去创建。</p>\n<p>例如在json2.js源码中，为Date、String、Number、Boolean方法添加一个toJSON的属性。<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-7-原型的灵活性/7-2.png\" alt=\"7-2.png\" title=\"\"><br>如果你要添加内置方法的原型属性，最好做一步判断，如果该属性不存在，则添加。如果本来就存在，就没必要再添加了。</p>"},{"title":"深入理解javascript原型和闭包(8)--简述【执行上下文】上","date":"2017-04-16T15:23:47.000Z","_content":"{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3986420.html 深入理解javascript原型和闭包（8）——简述【执行上下文】上 %}\n{% endblockquote %}\n什么是“执行上下文”（也叫做“执行上下文环境”）？暂且不下定义，先看一段代码：\n{% asset_img '8-1.png' %}\n第一句报错，a未定义，很正常。第二句、第三句输出都是undefined，说明浏览器在执行console.log(a)时，已经知道了a是undefined，但却不知道a是10（第三句中）。\n\n在一段js代码拿过来真正一句一句运行之前，浏览器已经做了一些“准备工作”，其中就包括对变量的声明，而不是赋值。变量赋值是在赋值语句执行的时候进行的。可用下图模拟：\n{% asset_img '8-2.png' %}\n这是第一种情况。\n\n\n\n下面还有。先来个简单的。\n{% asset_img '8-3.png' %}\n有js开发经验的朋友应该都知道，你无论在哪个位置获取this，都是有值的。至于this的取值情况，比较复杂，会专门拿出一篇文章来讲解。\n\n与第一种情况不同的是：第一种情况只是对变量进行声明（并没有赋值），而此种情况直接给this赋值。这也是“准备工作”情况要做的事情之一。\n\n\n\n下面还有。。。第三种情况。\n<!-- more -->\n\n在第三种情况中，需要注意代码注释中的两个名词——“函数表达式”和“函数声明”。虽然两者都很常用，但是这两者在“准备工作”时，却是两种待遇。\n{% asset_img '8-4.png' %}\n看以上代码。“函数声明”时我们看到了第二种情况的影子，而“函数表达式”时我们看到了第一种情况的影子。\n\n没错。在“准备工作”中，对待函数表达式就像对待“ var a = 10 ”这样的变量一样，只是声明。而对待函数声明时，却把函数整个赋值了。\n\n\n\n好了，“准备工作”介绍完毕。\n\n我们总结一下，在“准备工作”中完成了哪些工作：\n* {% raw %}\n    <span style=\"background-color: #87daff;\">变量、函数表达式——变量声明，默认赋值为undefined</span>\n  {% endraw %}；\n* {% raw %}\n    <span style=\"background-color: #87daff;\">this——赋值</span>\n  {% endraw %}；\n* {% raw %}\n    <span style=\"background-color: #87daff;\">函数声明——赋值</span>\n  {% endraw %}；\n\n{% raw %}\n  <span style=\"background-color: #87daff;\">这三种数据的准备情况我们称之为“执行上下文”或者“执行上下文环境”</span>\n{% endraw %}。\n\n{% raw %}\n<small>这里插一句题外话：通过以上三种情况，你可能会联想到网上的有些考js语法的题目/面试题。的确，几乎每个js语法题中都有这种题目出现。之前你遇到这种题目是不是靠背诵来解决？背过了，隔几天又忘记了。——<span style=\"background-color: #87daff;\">任何问题，都要去追根溯源，要知道这个问题是真正出自哪一块知识点，要真正去理解。光靠背诵是没用的</span>。</small>\n{% endraw %}\n\n细心的朋友可能会发现，我们上面所有的例子都是在全局环境下执行的。\n\n其实，javascript在执行一个代码段之前，都会进行这些“准备工作”来生成执行上下文。{% raw %}\n                                               <span style=\"background-color: #87daff;\">这个“代码段”其实分三种情况——全局代码，函数体，eval代码</span>\n                                             {% endraw %}。\n\n\n\n这里解释一下为什么代码段分为这三种。\n\n所谓“代码段”就是一段文本形式的代码。\n\n首先，全局代码是一种，这个应该没有非议，本来就是手写文本到script标签里面的。\n{% asset_img '8-5.png' %}\n其次，eval代码接收的也是一段文本形式的代码。\n```javascript\neval(\"alert(123)\")\n```\n最后，函数体是代码段是因为函数在创建时，本质上是 new Function(…) 得来的，其中需要传入一个文本形式的参数作为函数体。\n{% asset_img '8-6.png' %}\n这样解释应该能理解了。\n\n\n\n最后，eval不常用，也不推荐大家用。\n\n下一节我们介绍函数的情况，并一起总结一下执行上下文到底包含哪些内容。敬请期待。","source":"_posts/2017-04-16-深入理解javascript原型和闭包-8-简述【执行上下文】上.md","raw":"---\ntitle: 深入理解javascript原型和闭包(8)--简述【执行上下文】上\ncategories: 王福朋-深入理解javascript原型和闭包系列\ntags:\n  - javascript\n  - 原型链\n  - 闭包\ndate: 2017-04-16 23:23:47\n---\n{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3986420.html 深入理解javascript原型和闭包（8）——简述【执行上下文】上 %}\n{% endblockquote %}\n什么是“执行上下文”（也叫做“执行上下文环境”）？暂且不下定义，先看一段代码：\n{% asset_img '8-1.png' %}\n第一句报错，a未定义，很正常。第二句、第三句输出都是undefined，说明浏览器在执行console.log(a)时，已经知道了a是undefined，但却不知道a是10（第三句中）。\n\n在一段js代码拿过来真正一句一句运行之前，浏览器已经做了一些“准备工作”，其中就包括对变量的声明，而不是赋值。变量赋值是在赋值语句执行的时候进行的。可用下图模拟：\n{% asset_img '8-2.png' %}\n这是第一种情况。\n\n\n\n下面还有。先来个简单的。\n{% asset_img '8-3.png' %}\n有js开发经验的朋友应该都知道，你无论在哪个位置获取this，都是有值的。至于this的取值情况，比较复杂，会专门拿出一篇文章来讲解。\n\n与第一种情况不同的是：第一种情况只是对变量进行声明（并没有赋值），而此种情况直接给this赋值。这也是“准备工作”情况要做的事情之一。\n\n\n\n下面还有。。。第三种情况。\n<!-- more -->\n\n在第三种情况中，需要注意代码注释中的两个名词——“函数表达式”和“函数声明”。虽然两者都很常用，但是这两者在“准备工作”时，却是两种待遇。\n{% asset_img '8-4.png' %}\n看以上代码。“函数声明”时我们看到了第二种情况的影子，而“函数表达式”时我们看到了第一种情况的影子。\n\n没错。在“准备工作”中，对待函数表达式就像对待“ var a = 10 ”这样的变量一样，只是声明。而对待函数声明时，却把函数整个赋值了。\n\n\n\n好了，“准备工作”介绍完毕。\n\n我们总结一下，在“准备工作”中完成了哪些工作：\n* {% raw %}\n    <span style=\"background-color: #87daff;\">变量、函数表达式——变量声明，默认赋值为undefined</span>\n  {% endraw %}；\n* {% raw %}\n    <span style=\"background-color: #87daff;\">this——赋值</span>\n  {% endraw %}；\n* {% raw %}\n    <span style=\"background-color: #87daff;\">函数声明——赋值</span>\n  {% endraw %}；\n\n{% raw %}\n  <span style=\"background-color: #87daff;\">这三种数据的准备情况我们称之为“执行上下文”或者“执行上下文环境”</span>\n{% endraw %}。\n\n{% raw %}\n<small>这里插一句题外话：通过以上三种情况，你可能会联想到网上的有些考js语法的题目/面试题。的确，几乎每个js语法题中都有这种题目出现。之前你遇到这种题目是不是靠背诵来解决？背过了，隔几天又忘记了。——<span style=\"background-color: #87daff;\">任何问题，都要去追根溯源，要知道这个问题是真正出自哪一块知识点，要真正去理解。光靠背诵是没用的</span>。</small>\n{% endraw %}\n\n细心的朋友可能会发现，我们上面所有的例子都是在全局环境下执行的。\n\n其实，javascript在执行一个代码段之前，都会进行这些“准备工作”来生成执行上下文。{% raw %}\n                                               <span style=\"background-color: #87daff;\">这个“代码段”其实分三种情况——全局代码，函数体，eval代码</span>\n                                             {% endraw %}。\n\n\n\n这里解释一下为什么代码段分为这三种。\n\n所谓“代码段”就是一段文本形式的代码。\n\n首先，全局代码是一种，这个应该没有非议，本来就是手写文本到script标签里面的。\n{% asset_img '8-5.png' %}\n其次，eval代码接收的也是一段文本形式的代码。\n```javascript\neval(\"alert(123)\")\n```\n最后，函数体是代码段是因为函数在创建时，本质上是 new Function(…) 得来的，其中需要传入一个文本形式的参数作为函数体。\n{% asset_img '8-6.png' %}\n这样解释应该能理解了。\n\n\n\n最后，eval不常用，也不推荐大家用。\n\n下一节我们介绍函数的情况，并一起总结一下执行上下文到底包含哪些内容。敬请期待。","slug":"深入理解javascript原型和闭包-8-简述【执行上下文】上","published":1,"updated":"2017-04-16T17:40:37.429Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1lk6eb6000jyouaosyp2ywy","content":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3986420.html\" target=\"_blank\" rel=\"external\">深入理解javascript原型和闭包（8）——简述【执行上下文】上</a></cite></footer></blockquote>\n<p>什么是“执行上下文”（也叫做“执行上下文环境”）？暂且不下定义，先看一段代码：<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-8-简述【执行上下文】上/8-1.png\" alt=\"8-1.png\" title=\"\"><br>第一句报错，a未定义，很正常。第二句、第三句输出都是undefined，说明浏览器在执行console.log(a)时，已经知道了a是undefined，但却不知道a是10（第三句中）。</p>\n<p>在一段js代码拿过来真正一句一句运行之前，浏览器已经做了一些“准备工作”，其中就包括对变量的声明，而不是赋值。变量赋值是在赋值语句执行的时候进行的。可用下图模拟：<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-8-简述【执行上下文】上/8-2.png\" alt=\"8-2.png\" title=\"\"><br>这是第一种情况。</p>\n<p>下面还有。先来个简单的。<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-8-简述【执行上下文】上/8-3.png\" alt=\"8-3.png\" title=\"\"><br>有js开发经验的朋友应该都知道，你无论在哪个位置获取this，都是有值的。至于this的取值情况，比较复杂，会专门拿出一篇文章来讲解。</p>\n<p>与第一种情况不同的是：第一种情况只是对变量进行声明（并没有赋值），而此种情况直接给this赋值。这也是“准备工作”情况要做的事情之一。</p>\n<p>下面还有。。。第三种情况。<br><a id=\"more\"></a></p>\n<p>在第三种情况中，需要注意代码注释中的两个名词——“函数表达式”和“函数声明”。虽然两者都很常用，但是这两者在“准备工作”时，却是两种待遇。<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-8-简述【执行上下文】上/8-4.png\" alt=\"8-4.png\" title=\"\"><br>看以上代码。“函数声明”时我们看到了第二种情况的影子，而“函数表达式”时我们看到了第一种情况的影子。</p>\n<p>没错。在“准备工作”中，对待函数表达式就像对待“ var a = 10 ”这样的变量一样，只是声明。而对待函数声明时，却把函数整个赋值了。</p>\n<p>好了，“准备工作”介绍完毕。</p>\n<p>我们总结一下，在“准备工作”中完成了哪些工作：</p>\n<ul>\n<li>\n    <span style=\"background-color: #87daff;\">变量、函数表达式——变量声明，默认赋值为undefined</span>\n  ；</li>\n<li>\n    <span style=\"background-color: #87daff;\">this——赋值</span>\n  ；</li>\n<li>\n    <span style=\"background-color: #87daff;\">函数声明——赋值</span>\n  ；</li>\n</ul>\n\n  <span style=\"background-color: #87daff;\">这三种数据的准备情况我们称之为“执行上下文”或者“执行上下文环境”</span>\n。<br><br>\n<small>这里插一句题外话：通过以上三种情况，你可能会联想到网上的有些考js语法的题目/面试题。的确，几乎每个js语法题中都有这种题目出现。之前你遇到这种题目是不是靠背诵来解决？背过了，隔几天又忘记了。——<span style=\"background-color: #87daff;\">任何问题，都要去追根溯源，要知道这个问题是真正出自哪一块知识点，要真正去理解。光靠背诵是没用的</span>。</small>\n\n<p>细心的朋友可能会发现，我们上面所有的例子都是在全局环境下执行的。</p>\n<p>其实，javascript在执行一个代码段之前，都会进行这些“准备工作”来生成执行上下文。\n                                               <span style=\"background-color: #87daff;\">这个“代码段”其实分三种情况——全局代码，函数体，eval代码</span>\n                                             。</p>\n<p>这里解释一下为什么代码段分为这三种。</p>\n<p>所谓“代码段”就是一段文本形式的代码。</p>\n<p>首先，全局代码是一种，这个应该没有非议，本来就是手写文本到script标签里面的。<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-8-简述【执行上下文】上/8-5.png\" alt=\"8-5.png\" title=\"\"><br>其次，eval代码接收的也是一段文本形式的代码。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">eval</span>(<span class=\"string\">\"alert(123)\"</span>)</div></pre></td></tr></table></figure></p>\n<p>最后，函数体是代码段是因为函数在创建时，本质上是 new Function(…) 得来的，其中需要传入一个文本形式的参数作为函数体。<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-8-简述【执行上下文】上/8-6.png\" alt=\"8-6.png\" title=\"\"><br>这样解释应该能理解了。</p>\n<p>最后，eval不常用，也不推荐大家用。</p>\n<p>下一节我们介绍函数的情况，并一起总结一下执行上下文到底包含哪些内容。敬请期待。</p>\n","site":{"data":{}},"excerpt":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3986420.html\">深入理解javascript原型和闭包（8）——简述【执行上下文】上</a></cite></footer></blockquote>\n<p>什么是“执行上下文”（也叫做“执行上下文环境”）？暂且不下定义，先看一段代码：<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-8-简述【执行上下文】上/8-1.png\" alt=\"8-1.png\" title=\"\"><br>第一句报错，a未定义，很正常。第二句、第三句输出都是undefined，说明浏览器在执行console.log(a)时，已经知道了a是undefined，但却不知道a是10（第三句中）。</p>\n<p>在一段js代码拿过来真正一句一句运行之前，浏览器已经做了一些“准备工作”，其中就包括对变量的声明，而不是赋值。变量赋值是在赋值语句执行的时候进行的。可用下图模拟：<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-8-简述【执行上下文】上/8-2.png\" alt=\"8-2.png\" title=\"\"><br>这是第一种情况。</p>\n<p>下面还有。先来个简单的。<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-8-简述【执行上下文】上/8-3.png\" alt=\"8-3.png\" title=\"\"><br>有js开发经验的朋友应该都知道，你无论在哪个位置获取this，都是有值的。至于this的取值情况，比较复杂，会专门拿出一篇文章来讲解。</p>\n<p>与第一种情况不同的是：第一种情况只是对变量进行声明（并没有赋值），而此种情况直接给this赋值。这也是“准备工作”情况要做的事情之一。</p>\n<p>下面还有。。。第三种情况。<br>","more":"</p>\n<p>在第三种情况中，需要注意代码注释中的两个名词——“函数表达式”和“函数声明”。虽然两者都很常用，但是这两者在“准备工作”时，却是两种待遇。<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-8-简述【执行上下文】上/8-4.png\" alt=\"8-4.png\" title=\"\"><br>看以上代码。“函数声明”时我们看到了第二种情况的影子，而“函数表达式”时我们看到了第一种情况的影子。</p>\n<p>没错。在“准备工作”中，对待函数表达式就像对待“ var a = 10 ”这样的变量一样，只是声明。而对待函数声明时，却把函数整个赋值了。</p>\n<p>好了，“准备工作”介绍完毕。</p>\n<p>我们总结一下，在“准备工作”中完成了哪些工作：</p>\n<ul>\n<li>\n    <span style=\"background-color: #87daff;\">变量、函数表达式——变量声明，默认赋值为undefined</span>\n  ；</li>\n<li>\n    <span style=\"background-color: #87daff;\">this——赋值</span>\n  ；</li>\n<li>\n    <span style=\"background-color: #87daff;\">函数声明——赋值</span>\n  ；</li>\n</ul>\n\n  <span style=\"background-color: #87daff;\">这三种数据的准备情况我们称之为“执行上下文”或者“执行上下文环境”</span>\n。<br><br>\n<small>这里插一句题外话：通过以上三种情况，你可能会联想到网上的有些考js语法的题目/面试题。的确，几乎每个js语法题中都有这种题目出现。之前你遇到这种题目是不是靠背诵来解决？背过了，隔几天又忘记了。——<span style=\"background-color: #87daff;\">任何问题，都要去追根溯源，要知道这个问题是真正出自哪一块知识点，要真正去理解。光靠背诵是没用的</span>。</small>\n\n<p>细心的朋友可能会发现，我们上面所有的例子都是在全局环境下执行的。</p>\n<p>其实，javascript在执行一个代码段之前，都会进行这些“准备工作”来生成执行上下文。\n                                               <span style=\"background-color: #87daff;\">这个“代码段”其实分三种情况——全局代码，函数体，eval代码</span>\n                                             。</p>\n<p>这里解释一下为什么代码段分为这三种。</p>\n<p>所谓“代码段”就是一段文本形式的代码。</p>\n<p>首先，全局代码是一种，这个应该没有非议，本来就是手写文本到script标签里面的。<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-8-简述【执行上下文】上/8-5.png\" alt=\"8-5.png\" title=\"\"><br>其次，eval代码接收的也是一段文本形式的代码。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">eval</span>(<span class=\"string\">\"alert(123)\"</span>)</div></pre></td></tr></table></figure></p>\n<p>最后，函数体是代码段是因为函数在创建时，本质上是 new Function(…) 得来的，其中需要传入一个文本形式的参数作为函数体。<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-8-简述【执行上下文】上/8-6.png\" alt=\"8-6.png\" title=\"\"><br>这样解释应该能理解了。</p>\n<p>最后，eval不常用，也不推荐大家用。</p>\n<p>下一节我们介绍函数的情况，并一起总结一下执行上下文到底包含哪些内容。敬请期待。</p>"},{"title":"深入理解javascript原型和闭包(9)--简述【执行上下文】下","date":"2017-04-16T15:41:40.000Z","_content":"{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3987563.html 深入理解javascript原型和闭包（9）——简述【执行上下文】下 %}\n{% endblockquote %}\n继续上一篇文章（{% post_link 深入理解javascript原型和闭包-8-简述【执行上下文】上 深入理解javascript原型和闭包-8-简述【执行上下文】上 %}）的内容。\n\n上一篇我们讲到在全局环境下的代码段中，执行上下文环境中有如何数据：\n\n变量、函数表达式——变量声明，默认赋值为undefined；\nthis——赋值；\n函数声明——赋值；\n\n\n如果在函数中，除了以上数据之外，还会有其他数据。先看以下代码：\n{% asset_img '9-1.png' %}\n以上代码展示了在函数体的语句执行之前，arguments变量和函数的参数都已经被赋值。从这里可以看出，{% raw %}\n                                                       <span style=\"background-color: #87daff;\">函数每被调用一次，都会产生一个新的执行上下文环境。因为不同的调用可能就会有不同的参数</span>\n                                                     {% endraw %}。\n\n\n\n另外一点不同在于，{% raw %}\n                    <span style=\"background-color: #87daff;\">函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域</span>\n                  {% endraw %}。至于“自由变量”和“作用域”是后面要专门拿出来讲述的重点，这里就先点到为止。用一个例子说明一下：\n{% asset_img '9-2.png' %}\n好了，总结完了函数的附加内容，我们就此要全面总结一下上下文环境的数据内容。\n<!-- more -->\n\n全局代码的上下文环境数据内容为：\n{% raw %}\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"0\">\n    <tbody>\n        <tr>\n            <td valign=\"top\" width=\"217\">\n            <p>普通变量（包括函数表达式），</p>\n            <p>如： var a = 10;</p>\n            </td>\n            <td valign=\"top\" width=\"236\">\n            <p>声明（默认赋值为undefined）</p>\n            </td>\n        </tr>\n        <tr>\n            <td valign=\"top\" width=\"217\">\n            <p>函数声明，</p>\n            <p>如： function fn() { }</p>\n            </td>\n            <td valign=\"top\" width=\"236\">\n            <p>赋值</p>\n            </td>\n        </tr>\n        <tr>\n            <td valign=\"top\" width=\"217\">\n            <p>this</p>\n            </td>\n            <td valign=\"top\" width=\"236\">\n            <p>赋值</p>\n            </td>\n        </tr>\n    </tbody>\n</table>\n{% endraw %}\n\n如果代码段是函数体，那么在此基础上需要附加：\n\n{% raw %}\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"0\">\n    <tbody>\n        <tr>\n            <td valign=\"top\" width=\"217\">\n            <p>参数</p>\n            </td>\n            <td valign=\"top\" width=\"236\">\n            <p>赋值</p>\n            </td>\n        </tr>\n        <tr>\n            <td valign=\"top\" width=\"217\">\n            <p>arguments</p>\n            </td>\n            <td valign=\"top\" width=\"236\">\n            <p>赋值</p>\n            </td>\n        </tr>\n        <tr>\n            <td valign=\"top\" width=\"217\">\n            <p>自由变量的取值作用域</p>\n            </td>\n            <td valign=\"top\" width=\"236\">\n            <p>赋值</p>\n            </td>\n        </tr>\n    </tbody>\n</table>\n{% endraw %}\n\n给执行上下文环境下一个通俗的定义——{% raw %}\n                                      <span style=\"background-color: #87daff;\">在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空</span>\n                                    {% endraw %}。\n{% raw %}\n  <small>了解了执行上下文环境中的数据信息，你就不用再去死记硬背那些可恶的面试题了。理解了就不用背诵！</small>\n{% endraw %}。\n\n讲完了上下文环境，又来了新的问题——在执行js代码时，会有数不清的函数调用次数，会产生许多个上下文环境。这么多上下文环境该如何管理，以及如何销毁而释放内存呢？下一节将通过“执行上下文栈”来解释这个问题。\n\n\n\n不过别着急，在解释“执行上下文栈”之前，还需要把this说一下，this还是挺重要的。\n\n说完this，接着说执行上下文栈。","source":"_posts/2017-04-16-深入理解javascript原型和闭包-9-简述【执行上下文】下.md","raw":"---\ntitle: 深入理解javascript原型和闭包(9)--简述【执行上下文】下\ncategories: 王福朋-深入理解javascript原型和闭包系列\ntags:\n  - javascript\n  - 原型链\n  - 闭包\ndate: 2017-04-16 23:41:40\n---\n{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3987563.html 深入理解javascript原型和闭包（9）——简述【执行上下文】下 %}\n{% endblockquote %}\n继续上一篇文章（{% post_link 深入理解javascript原型和闭包-8-简述【执行上下文】上 深入理解javascript原型和闭包-8-简述【执行上下文】上 %}）的内容。\n\n上一篇我们讲到在全局环境下的代码段中，执行上下文环境中有如何数据：\n\n变量、函数表达式——变量声明，默认赋值为undefined；\nthis——赋值；\n函数声明——赋值；\n\n\n如果在函数中，除了以上数据之外，还会有其他数据。先看以下代码：\n{% asset_img '9-1.png' %}\n以上代码展示了在函数体的语句执行之前，arguments变量和函数的参数都已经被赋值。从这里可以看出，{% raw %}\n                                                       <span style=\"background-color: #87daff;\">函数每被调用一次，都会产生一个新的执行上下文环境。因为不同的调用可能就会有不同的参数</span>\n                                                     {% endraw %}。\n\n\n\n另外一点不同在于，{% raw %}\n                    <span style=\"background-color: #87daff;\">函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域</span>\n                  {% endraw %}。至于“自由变量”和“作用域”是后面要专门拿出来讲述的重点，这里就先点到为止。用一个例子说明一下：\n{% asset_img '9-2.png' %}\n好了，总结完了函数的附加内容，我们就此要全面总结一下上下文环境的数据内容。\n<!-- more -->\n\n全局代码的上下文环境数据内容为：\n{% raw %}\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"0\">\n    <tbody>\n        <tr>\n            <td valign=\"top\" width=\"217\">\n            <p>普通变量（包括函数表达式），</p>\n            <p>如： var a = 10;</p>\n            </td>\n            <td valign=\"top\" width=\"236\">\n            <p>声明（默认赋值为undefined）</p>\n            </td>\n        </tr>\n        <tr>\n            <td valign=\"top\" width=\"217\">\n            <p>函数声明，</p>\n            <p>如： function fn() { }</p>\n            </td>\n            <td valign=\"top\" width=\"236\">\n            <p>赋值</p>\n            </td>\n        </tr>\n        <tr>\n            <td valign=\"top\" width=\"217\">\n            <p>this</p>\n            </td>\n            <td valign=\"top\" width=\"236\">\n            <p>赋值</p>\n            </td>\n        </tr>\n    </tbody>\n</table>\n{% endraw %}\n\n如果代码段是函数体，那么在此基础上需要附加：\n\n{% raw %}\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"0\">\n    <tbody>\n        <tr>\n            <td valign=\"top\" width=\"217\">\n            <p>参数</p>\n            </td>\n            <td valign=\"top\" width=\"236\">\n            <p>赋值</p>\n            </td>\n        </tr>\n        <tr>\n            <td valign=\"top\" width=\"217\">\n            <p>arguments</p>\n            </td>\n            <td valign=\"top\" width=\"236\">\n            <p>赋值</p>\n            </td>\n        </tr>\n        <tr>\n            <td valign=\"top\" width=\"217\">\n            <p>自由变量的取值作用域</p>\n            </td>\n            <td valign=\"top\" width=\"236\">\n            <p>赋值</p>\n            </td>\n        </tr>\n    </tbody>\n</table>\n{% endraw %}\n\n给执行上下文环境下一个通俗的定义——{% raw %}\n                                      <span style=\"background-color: #87daff;\">在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空</span>\n                                    {% endraw %}。\n{% raw %}\n  <small>了解了执行上下文环境中的数据信息，你就不用再去死记硬背那些可恶的面试题了。理解了就不用背诵！</small>\n{% endraw %}。\n\n讲完了上下文环境，又来了新的问题——在执行js代码时，会有数不清的函数调用次数，会产生许多个上下文环境。这么多上下文环境该如何管理，以及如何销毁而释放内存呢？下一节将通过“执行上下文栈”来解释这个问题。\n\n\n\n不过别着急，在解释“执行上下文栈”之前，还需要把this说一下，this还是挺重要的。\n\n说完this，接着说执行上下文栈。","slug":"深入理解javascript原型和闭包-9-简述【执行上下文】下","published":1,"updated":"2017-04-16T17:40:49.435Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1lk6ebq000lyouazfpxlbmv","content":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3987563.html\" target=\"_blank\" rel=\"external\">深入理解javascript原型和闭包（9）——简述【执行上下文】下</a></cite></footer></blockquote>\n<p>继续上一篇文章（<a href=\"/2017/04/16/深入理解javascript原型和闭包-8-简述【执行上下文】上/\" title=\"深入理解javascript原型和闭包-8-简述【执行上下文】上\">深入理解javascript原型和闭包-8-简述【执行上下文】上</a>）的内容。</p>\n<p>上一篇我们讲到在全局环境下的代码段中，执行上下文环境中有如何数据：</p>\n<p>变量、函数表达式——变量声明，默认赋值为undefined；<br>this——赋值；<br>函数声明——赋值；</p>\n<p>如果在函数中，除了以上数据之外，还会有其他数据。先看以下代码：<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-9-简述【执行上下文】下/9-1.png\" alt=\"9-1.png\" title=\"\"><br>以上代码展示了在函数体的语句执行之前，arguments变量和函数的参数都已经被赋值。从这里可以看出，\n                                                       <span style=\"background-color: #87daff;\">函数每被调用一次，都会产生一个新的执行上下文环境。因为不同的调用可能就会有不同的参数</span>\n                                                     。</p>\n<p>另外一点不同在于，\n                    <span style=\"background-color: #87daff;\">函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域</span>\n                  。至于“自由变量”和“作用域”是后面要专门拿出来讲述的重点，这里就先点到为止。用一个例子说明一下：<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-9-简述【执行上下文】下/9-2.png\" alt=\"9-2.png\" title=\"\"><br>好了，总结完了函数的附加内容，我们就此要全面总结一下上下文环境的数据内容。<br><a id=\"more\"></a></p>\n<p>全局代码的上下文环境数据内容为：<br>\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"0\">\n    <tbody>\n        <tr>\n            <td valign=\"top\" width=\"217\">\n            <p>普通变量（包括函数表达式），</p>\n            <p>如： var a = 10;</p>\n            </td>\n            <td valign=\"top\" width=\"236\">\n            <p>声明（默认赋值为undefined）</p>\n            </td>\n        </tr>\n        <tr>\n            <td valign=\"top\" width=\"217\">\n            <p>函数声明，</p>\n            <p>如： function fn() { }</p>\n            </td>\n            <td valign=\"top\" width=\"236\">\n            <p>赋值</p>\n            </td>\n        </tr>\n        <tr>\n            <td valign=\"top\" width=\"217\">\n            <p>this</p>\n            </td>\n            <td valign=\"top\" width=\"236\">\n            <p>赋值</p>\n            </td>\n        </tr>\n    </tbody>\n</table>\n</p>\n<p>如果代码段是函数体，那么在此基础上需要附加：</p>\n\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"0\">\n    <tbody>\n        <tr>\n            <td valign=\"top\" width=\"217\">\n            <p>参数</p>\n            </td>\n            <td valign=\"top\" width=\"236\">\n            <p>赋值</p>\n            </td>\n        </tr>\n        <tr>\n            <td valign=\"top\" width=\"217\">\n            <p>arguments</p>\n            </td>\n            <td valign=\"top\" width=\"236\">\n            <p>赋值</p>\n            </td>\n        </tr>\n        <tr>\n            <td valign=\"top\" width=\"217\">\n            <p>自由变量的取值作用域</p>\n            </td>\n            <td valign=\"top\" width=\"236\">\n            <p>赋值</p>\n            </td>\n        </tr>\n    </tbody>\n</table>\n\n<p>给执行上下文环境下一个通俗的定义——\n                                      <span style=\"background-color: #87daff;\">在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空</span>\n                                    。<br>\n  <small>了解了执行上下文环境中的数据信息，你就不用再去死记硬背那些可恶的面试题了。理解了就不用背诵！</small>\n。</p>\n<p>讲完了上下文环境，又来了新的问题——在执行js代码时，会有数不清的函数调用次数，会产生许多个上下文环境。这么多上下文环境该如何管理，以及如何销毁而释放内存呢？下一节将通过“执行上下文栈”来解释这个问题。</p>\n<p>不过别着急，在解释“执行上下文栈”之前，还需要把this说一下，this还是挺重要的。</p>\n<p>说完this，接着说执行上下文栈。</p>\n","site":{"data":{}},"excerpt":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3987563.html\">深入理解javascript原型和闭包（9）——简述【执行上下文】下</a></cite></footer></blockquote>\n<p>继续上一篇文章（<a href=\"/2017/04/16/深入理解javascript原型和闭包-8-简述【执行上下文】上/\" title=\"深入理解javascript原型和闭包-8-简述【执行上下文】上\">深入理解javascript原型和闭包-8-简述【执行上下文】上</a>）的内容。</p>\n<p>上一篇我们讲到在全局环境下的代码段中，执行上下文环境中有如何数据：</p>\n<p>变量、函数表达式——变量声明，默认赋值为undefined；<br>this——赋值；<br>函数声明——赋值；</p>\n<p>如果在函数中，除了以上数据之外，还会有其他数据。先看以下代码：<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-9-简述【执行上下文】下/9-1.png\" alt=\"9-1.png\" title=\"\"><br>以上代码展示了在函数体的语句执行之前，arguments变量和函数的参数都已经被赋值。从这里可以看出，\n                                                       <span style=\"background-color: #87daff;\">函数每被调用一次，都会产生一个新的执行上下文环境。因为不同的调用可能就会有不同的参数</span>\n                                                     。</p>\n<p>另外一点不同在于，\n                    <span style=\"background-color: #87daff;\">函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域</span>\n                  。至于“自由变量”和“作用域”是后面要专门拿出来讲述的重点，这里就先点到为止。用一个例子说明一下：<br><img src=\"/2017/04/16/深入理解javascript原型和闭包-9-简述【执行上下文】下/9-2.png\" alt=\"9-2.png\" title=\"\"><br>好了，总结完了函数的附加内容，我们就此要全面总结一下上下文环境的数据内容。<br>","more":"</p>\n<p>全局代码的上下文环境数据内容为：<br>\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"0\">\n    <tbody>\n        <tr>\n            <td valign=\"top\" width=\"217\">\n            <p>普通变量（包括函数表达式），</p>\n            <p>如： var a = 10;</p>\n            </td>\n            <td valign=\"top\" width=\"236\">\n            <p>声明（默认赋值为undefined）</p>\n            </td>\n        </tr>\n        <tr>\n            <td valign=\"top\" width=\"217\">\n            <p>函数声明，</p>\n            <p>如： function fn() { }</p>\n            </td>\n            <td valign=\"top\" width=\"236\">\n            <p>赋值</p>\n            </td>\n        </tr>\n        <tr>\n            <td valign=\"top\" width=\"217\">\n            <p>this</p>\n            </td>\n            <td valign=\"top\" width=\"236\">\n            <p>赋值</p>\n            </td>\n        </tr>\n    </tbody>\n</table>\n</p>\n<p>如果代码段是函数体，那么在此基础上需要附加：</p>\n\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"0\">\n    <tbody>\n        <tr>\n            <td valign=\"top\" width=\"217\">\n            <p>参数</p>\n            </td>\n            <td valign=\"top\" width=\"236\">\n            <p>赋值</p>\n            </td>\n        </tr>\n        <tr>\n            <td valign=\"top\" width=\"217\">\n            <p>arguments</p>\n            </td>\n            <td valign=\"top\" width=\"236\">\n            <p>赋值</p>\n            </td>\n        </tr>\n        <tr>\n            <td valign=\"top\" width=\"217\">\n            <p>自由变量的取值作用域</p>\n            </td>\n            <td valign=\"top\" width=\"236\">\n            <p>赋值</p>\n            </td>\n        </tr>\n    </tbody>\n</table>\n\n<p>给执行上下文环境下一个通俗的定义——\n                                      <span style=\"background-color: #87daff;\">在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空</span>\n                                    。<br>\n  <small>了解了执行上下文环境中的数据信息，你就不用再去死记硬背那些可恶的面试题了。理解了就不用背诵！</small>\n。</p>\n<p>讲完了上下文环境，又来了新的问题——在执行js代码时，会有数不清的函数调用次数，会产生许多个上下文环境。这么多上下文环境该如何管理，以及如何销毁而释放内存呢？下一节将通过“执行上下文栈”来解释这个问题。</p>\n<p>不过别着急，在解释“执行上下文栈”之前，还需要把this说一下，this还是挺重要的。</p>\n<p>说完this，接着说执行上下文栈。</p>"},{"title":"深入理解javascript原型和闭包(10)--this","date":"2017-04-16T16:07:37.000Z","_content":"{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3988422.html 深入理解javascript原型和闭包（10）——this %}\n{% endblockquote %}\n接着上一节讲的话，应该轮到“执行上下文栈”了，但是这里不得不插入一节，把this说一下。因为this很重要，js的面试题如果不出几个与this有关的，那出题者都不合格。\n\n\n\n其实，this的取值，分四种情况。我们来挨个看一下。\n\n在此再强调一遍一个非常重要的知识点：{% raw %}\n                                     <span style=\"background-color: #87daff;\">在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了</span>\n                                   {% endraw %}。因为this的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。\n\n<!-- more -->\n\n###### 情况1：构造函数\n所谓构造函数就是用来new对象的函数。其实严格来说，所有的函数都可以new一个对象，但是有些函数的定义是为了new一个对象，而有些函数则不是。另外注意，构造函数的函数名第一个字母大写（规则约定）。例如：Object、Array、Function等。\n{% asset_img '10-1.png' %}\n以上代码中，如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象。\n\n\n\n注意，以上仅限new Foo()的情况，即Foo函数作为构造函数的情况。如果直接调用Foo函数，而不是new Foo()，情况就大不一样了。\n{% asset_img '10-2.png' %}\n这种情况下this是window，我们后文中会说到。\n\n\n\n情况2：函数作为对象的一个属性\n\n如果函数作为对象的一个属性时，{% raw %}\n                                <span style=\"background-color: #87daff;\">并且作为对象的一个属性被调用时</span>\n                              {% endraw %}，函数中的this指向该对象。\n{% asset_img '10-3.png' %}\n以上代码中，fn不仅作为一个对象的一个属性，而且的确是作为对象的一个属性被调用。结果this就是obj对象。\n\n\n\n{% raw %}\n    <span style=\"background-color: #87daff;\">注意</span>\n{% endraw %}，如果fn函数不作为obj的一个属性被调用，会是什么结果呢？\n{% asset_img '10-4.png' %}\n如上代码，如果fn函数被赋值到了另一个变量中，并没有作为obj的一个属性被调用，那么this的值就是window，this.x为undefined。\n\n\n###### 情况3：函数用call或者apply调用\n当一个函数被call和apply调用时，this的值就取传入的对象的值。至于call和apply如何使用，不会的朋友可以去查查其他资料，本系列教程不做讲解。\n{% asset_img '10-5.png' %}\n\n\n###### 情况4：全局 & 调用普通函数\n在全局环境下，this永远是window，这个应该没有非议。\n```javascript\nconsole.log(this === window) //  true\n```\n普通函数在调用时，其中的this也都是window。\n{% asset_img '10-6.png' %}\n以上代码很好理解。\n\n不过{% raw %}\n      <span style=\"background-color: #87daff;\">下面的情况你需要注意一下</span>\n  {% endraw %}：\n{% asset_img '10-7.png' %}\n函数f虽然是在obj.fn内部定义的，但是它仍然是一个普通的函数，this仍然指向window。\n\n\n\n完了。\n\n看到了吧，this有关的知识点还是挺多的，不仅多而且非常重要。\n\n最后，既然提到了this，有必要把一个非常经典的案例介绍给大家，又是jQuery源码的。\n{% asset_img '10-8.png' %}\n以上代码是从jQuery中摘除来的部分代码。jQuery.extend和jQuery.fn.extend都指向了同一个函数，但是当执行时，函数中的this是不一样的。\n\n执行jQuery.extend(…)时，this指向jQuery；执行jQuery.fn.extend(…)时，this指向jQuery.fn。\n\n这样就巧妙的将一段代码同时共享给两个功能使用，更加符合设计原则。\n\n\n\n{% blockquote %}\n 原作者后续补充\n{% endblockquote %}\n上文中，讲解了在javascript中this的各个情况，写完之后发现还落下一种情况，就此补充。\n\n\n\n上文中this的其中一种情况是构造函数的，具体的内容可以参考原文，此处不再赘述。\n\n要补充的内容是，在构造函数的prototype中，this代表着什么。\n{% asset_img '10-9.png' %}\n如上代码，在Fn.prototype.getName函数中，this指向的是f1对象。因此可以通过this.name获取f1.name的值。\n\n{% raw %}\n      <span style=\"background-color: #87daff;\">其实，不仅仅是构造函数的prototype，即便是在整个原型链中，this代表的也都是当前对象的值</span>\n  {% endraw %}。\n\n\n好了，聊完了this。接着上一节继续说“执行上下文栈”。\n\n","source":"_posts/2017-04-17-深入理解javascript原型和闭包-10-this.md","raw":"---\ntitle: 深入理解javascript原型和闭包(10)--this\ncategories: 王福朋-深入理解javascript原型和闭包系列\ntags:\n  - javascript\n  - 原型链\n  - 闭包\ndate: 2017-04-17 00:07:37\n---\n{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3988422.html 深入理解javascript原型和闭包（10）——this %}\n{% endblockquote %}\n接着上一节讲的话，应该轮到“执行上下文栈”了，但是这里不得不插入一节，把this说一下。因为this很重要，js的面试题如果不出几个与this有关的，那出题者都不合格。\n\n\n\n其实，this的取值，分四种情况。我们来挨个看一下。\n\n在此再强调一遍一个非常重要的知识点：{% raw %}\n                                     <span style=\"background-color: #87daff;\">在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了</span>\n                                   {% endraw %}。因为this的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。\n\n<!-- more -->\n\n###### 情况1：构造函数\n所谓构造函数就是用来new对象的函数。其实严格来说，所有的函数都可以new一个对象，但是有些函数的定义是为了new一个对象，而有些函数则不是。另外注意，构造函数的函数名第一个字母大写（规则约定）。例如：Object、Array、Function等。\n{% asset_img '10-1.png' %}\n以上代码中，如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象。\n\n\n\n注意，以上仅限new Foo()的情况，即Foo函数作为构造函数的情况。如果直接调用Foo函数，而不是new Foo()，情况就大不一样了。\n{% asset_img '10-2.png' %}\n这种情况下this是window，我们后文中会说到。\n\n\n\n情况2：函数作为对象的一个属性\n\n如果函数作为对象的一个属性时，{% raw %}\n                                <span style=\"background-color: #87daff;\">并且作为对象的一个属性被调用时</span>\n                              {% endraw %}，函数中的this指向该对象。\n{% asset_img '10-3.png' %}\n以上代码中，fn不仅作为一个对象的一个属性，而且的确是作为对象的一个属性被调用。结果this就是obj对象。\n\n\n\n{% raw %}\n    <span style=\"background-color: #87daff;\">注意</span>\n{% endraw %}，如果fn函数不作为obj的一个属性被调用，会是什么结果呢？\n{% asset_img '10-4.png' %}\n如上代码，如果fn函数被赋值到了另一个变量中，并没有作为obj的一个属性被调用，那么this的值就是window，this.x为undefined。\n\n\n###### 情况3：函数用call或者apply调用\n当一个函数被call和apply调用时，this的值就取传入的对象的值。至于call和apply如何使用，不会的朋友可以去查查其他资料，本系列教程不做讲解。\n{% asset_img '10-5.png' %}\n\n\n###### 情况4：全局 & 调用普通函数\n在全局环境下，this永远是window，这个应该没有非议。\n```javascript\nconsole.log(this === window) //  true\n```\n普通函数在调用时，其中的this也都是window。\n{% asset_img '10-6.png' %}\n以上代码很好理解。\n\n不过{% raw %}\n      <span style=\"background-color: #87daff;\">下面的情况你需要注意一下</span>\n  {% endraw %}：\n{% asset_img '10-7.png' %}\n函数f虽然是在obj.fn内部定义的，但是它仍然是一个普通的函数，this仍然指向window。\n\n\n\n完了。\n\n看到了吧，this有关的知识点还是挺多的，不仅多而且非常重要。\n\n最后，既然提到了this，有必要把一个非常经典的案例介绍给大家，又是jQuery源码的。\n{% asset_img '10-8.png' %}\n以上代码是从jQuery中摘除来的部分代码。jQuery.extend和jQuery.fn.extend都指向了同一个函数，但是当执行时，函数中的this是不一样的。\n\n执行jQuery.extend(…)时，this指向jQuery；执行jQuery.fn.extend(…)时，this指向jQuery.fn。\n\n这样就巧妙的将一段代码同时共享给两个功能使用，更加符合设计原则。\n\n\n\n{% blockquote %}\n 原作者后续补充\n{% endblockquote %}\n上文中，讲解了在javascript中this的各个情况，写完之后发现还落下一种情况，就此补充。\n\n\n\n上文中this的其中一种情况是构造函数的，具体的内容可以参考原文，此处不再赘述。\n\n要补充的内容是，在构造函数的prototype中，this代表着什么。\n{% asset_img '10-9.png' %}\n如上代码，在Fn.prototype.getName函数中，this指向的是f1对象。因此可以通过this.name获取f1.name的值。\n\n{% raw %}\n      <span style=\"background-color: #87daff;\">其实，不仅仅是构造函数的prototype，即便是在整个原型链中，this代表的也都是当前对象的值</span>\n  {% endraw %}。\n\n\n好了，聊完了this。接着上一节继续说“执行上下文栈”。\n\n","slug":"深入理解javascript原型和闭包-10-this","published":1,"updated":"2017-04-16T17:40:59.188Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1lk6ebz000pyoua46g2hjbk","content":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3988422.html\" target=\"_blank\" rel=\"external\">深入理解javascript原型和闭包（10）——this</a></cite></footer></blockquote>\n<p>接着上一节讲的话，应该轮到“执行上下文栈”了，但是这里不得不插入一节，把this说一下。因为this很重要，js的面试题如果不出几个与this有关的，那出题者都不合格。</p>\n<p>其实，this的取值，分四种情况。我们来挨个看一下。</p>\n<p>在此再强调一遍一个非常重要的知识点：\n                                     <span style=\"background-color: #87daff;\">在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了</span>\n                                   。因为this的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。</p>\n<a id=\"more\"></a>\n<h6 id=\"情况1：构造函数\"><a href=\"#情况1：构造函数\" class=\"headerlink\" title=\"情况1：构造函数\"></a>情况1：构造函数</h6><p>所谓构造函数就是用来new对象的函数。其实严格来说，所有的函数都可以new一个对象，但是有些函数的定义是为了new一个对象，而有些函数则不是。另外注意，构造函数的函数名第一个字母大写（规则约定）。例如：Object、Array、Function等。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-10-this/10-1.png\" alt=\"10-1.png\" title=\"\"><br>以上代码中，如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象。</p>\n<p>注意，以上仅限new Foo()的情况，即Foo函数作为构造函数的情况。如果直接调用Foo函数，而不是new Foo()，情况就大不一样了。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-10-this/10-2.png\" alt=\"10-2.png\" title=\"\"><br>这种情况下this是window，我们后文中会说到。</p>\n<p>情况2：函数作为对象的一个属性</p>\n<p>如果函数作为对象的一个属性时，\n                                <span style=\"background-color: #87daff;\">并且作为对象的一个属性被调用时</span>\n                              ，函数中的this指向该对象。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-10-this/10-3.png\" alt=\"10-3.png\" title=\"\"><br>以上代码中，fn不仅作为一个对象的一个属性，而且的确是作为对象的一个属性被调用。结果this就是obj对象。</p>\n\n    <span style=\"background-color: #87daff;\">注意</span>\n，如果fn函数不作为obj的一个属性被调用，会是什么结果呢？<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-10-this/10-4.png\" alt=\"10-4.png\" title=\"\">\n<p>如上代码，如果fn函数被赋值到了另一个变量中，并没有作为obj的一个属性被调用，那么this的值就是window，this.x为undefined。</p>\n<h6 id=\"情况3：函数用call或者apply调用\"><a href=\"#情况3：函数用call或者apply调用\" class=\"headerlink\" title=\"情况3：函数用call或者apply调用\"></a>情况3：函数用call或者apply调用</h6><p>当一个函数被call和apply调用时，this的值就取传入的对象的值。至于call和apply如何使用，不会的朋友可以去查查其他资料，本系列教程不做讲解。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-10-this/10-5.png\" alt=\"10-5.png\" title=\"\"></p>\n<h6 id=\"情况4：全局-amp-调用普通函数\"><a href=\"#情况4：全局-amp-调用普通函数\" class=\"headerlink\" title=\"情况4：全局 &amp; 调用普通函数\"></a>情况4：全局 &amp; 调用普通函数</h6><p>在全局环境下，this永远是window，这个应该没有非议。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === <span class=\"built_in\">window</span>) <span class=\"comment\">//  true</span></div></pre></td></tr></table></figure></p>\n<p>普通函数在调用时，其中的this也都是window。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-10-this/10-6.png\" alt=\"10-6.png\" title=\"\"><br>以上代码很好理解。</p>\n<p>不过\n      <span style=\"background-color: #87daff;\">下面的情况你需要注意一下</span>\n  ：<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-10-this/10-7.png\" alt=\"10-7.png\" title=\"\"><br>函数f虽然是在obj.fn内部定义的，但是它仍然是一个普通的函数，this仍然指向window。</p>\n<p>完了。</p>\n<p>看到了吧，this有关的知识点还是挺多的，不仅多而且非常重要。</p>\n<p>最后，既然提到了this，有必要把一个非常经典的案例介绍给大家，又是jQuery源码的。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-10-this/10-8.png\" alt=\"10-8.png\" title=\"\"><br>以上代码是从jQuery中摘除来的部分代码。jQuery.extend和jQuery.fn.extend都指向了同一个函数，但是当执行时，函数中的this是不一样的。</p>\n<p>执行jQuery.extend(…)时，this指向jQuery；执行jQuery.fn.extend(…)时，this指向jQuery.fn。</p>\n<p>这样就巧妙的将一段代码同时共享给两个功能使用，更加符合设计原则。</p>\n<blockquote><p>原作者后续补充</p>\n</blockquote>\n<p>上文中，讲解了在javascript中this的各个情况，写完之后发现还落下一种情况，就此补充。</p>\n<p>上文中this的其中一种情况是构造函数的，具体的内容可以参考原文，此处不再赘述。</p>\n<p>要补充的内容是，在构造函数的prototype中，this代表着什么。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-10-this/10-9.png\" alt=\"10-9.png\" title=\"\"><br>如上代码，在Fn.prototype.getName函数中，this指向的是f1对象。因此可以通过this.name获取f1.name的值。</p>\n<p>\n      <span style=\"background-color: #87daff;\">其实，不仅仅是构造函数的prototype，即便是在整个原型链中，this代表的也都是当前对象的值</span>\n  。</p>\n<p>好了，聊完了this。接着上一节继续说“执行上下文栈”。</p>\n","site":{"data":{}},"excerpt":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3988422.html\">深入理解javascript原型和闭包（10）——this</a></cite></footer></blockquote>\n<p>接着上一节讲的话，应该轮到“执行上下文栈”了，但是这里不得不插入一节，把this说一下。因为this很重要，js的面试题如果不出几个与this有关的，那出题者都不合格。</p>\n<p>其实，this的取值，分四种情况。我们来挨个看一下。</p>\n<p>在此再强调一遍一个非常重要的知识点：\n                                     <span style=\"background-color: #87daff;\">在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了</span>\n                                   。因为this的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。</p>","more":"<h6 id=\"情况1：构造函数\"><a href=\"#情况1：构造函数\" class=\"headerlink\" title=\"情况1：构造函数\"></a>情况1：构造函数</h6><p>所谓构造函数就是用来new对象的函数。其实严格来说，所有的函数都可以new一个对象，但是有些函数的定义是为了new一个对象，而有些函数则不是。另外注意，构造函数的函数名第一个字母大写（规则约定）。例如：Object、Array、Function等。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-10-this/10-1.png\" alt=\"10-1.png\" title=\"\"><br>以上代码中，如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象。</p>\n<p>注意，以上仅限new Foo()的情况，即Foo函数作为构造函数的情况。如果直接调用Foo函数，而不是new Foo()，情况就大不一样了。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-10-this/10-2.png\" alt=\"10-2.png\" title=\"\"><br>这种情况下this是window，我们后文中会说到。</p>\n<p>情况2：函数作为对象的一个属性</p>\n<p>如果函数作为对象的一个属性时，\n                                <span style=\"background-color: #87daff;\">并且作为对象的一个属性被调用时</span>\n                              ，函数中的this指向该对象。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-10-this/10-3.png\" alt=\"10-3.png\" title=\"\"><br>以上代码中，fn不仅作为一个对象的一个属性，而且的确是作为对象的一个属性被调用。结果this就是obj对象。</p>\n\n    <span style=\"background-color: #87daff;\">注意</span>\n，如果fn函数不作为obj的一个属性被调用，会是什么结果呢？<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-10-this/10-4.png\" alt=\"10-4.png\" title=\"\">\n<p>如上代码，如果fn函数被赋值到了另一个变量中，并没有作为obj的一个属性被调用，那么this的值就是window，this.x为undefined。</p>\n<h6 id=\"情况3：函数用call或者apply调用\"><a href=\"#情况3：函数用call或者apply调用\" class=\"headerlink\" title=\"情况3：函数用call或者apply调用\"></a>情况3：函数用call或者apply调用</h6><p>当一个函数被call和apply调用时，this的值就取传入的对象的值。至于call和apply如何使用，不会的朋友可以去查查其他资料，本系列教程不做讲解。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-10-this/10-5.png\" alt=\"10-5.png\" title=\"\"></p>\n<h6 id=\"情况4：全局-amp-调用普通函数\"><a href=\"#情况4：全局-amp-调用普通函数\" class=\"headerlink\" title=\"情况4：全局 &amp; 调用普通函数\"></a>情况4：全局 &amp; 调用普通函数</h6><p>在全局环境下，this永远是window，这个应该没有非议。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === <span class=\"built_in\">window</span>) <span class=\"comment\">//  true</span></div></pre></td></tr></table></figure></p>\n<p>普通函数在调用时，其中的this也都是window。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-10-this/10-6.png\" alt=\"10-6.png\" title=\"\"><br>以上代码很好理解。</p>\n<p>不过\n      <span style=\"background-color: #87daff;\">下面的情况你需要注意一下</span>\n  ：<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-10-this/10-7.png\" alt=\"10-7.png\" title=\"\"><br>函数f虽然是在obj.fn内部定义的，但是它仍然是一个普通的函数，this仍然指向window。</p>\n<p>完了。</p>\n<p>看到了吧，this有关的知识点还是挺多的，不仅多而且非常重要。</p>\n<p>最后，既然提到了this，有必要把一个非常经典的案例介绍给大家，又是jQuery源码的。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-10-this/10-8.png\" alt=\"10-8.png\" title=\"\"><br>以上代码是从jQuery中摘除来的部分代码。jQuery.extend和jQuery.fn.extend都指向了同一个函数，但是当执行时，函数中的this是不一样的。</p>\n<p>执行jQuery.extend(…)时，this指向jQuery；执行jQuery.fn.extend(…)时，this指向jQuery.fn。</p>\n<p>这样就巧妙的将一段代码同时共享给两个功能使用，更加符合设计原则。</p>\n<blockquote><p>原作者后续补充</p>\n</blockquote>\n<p>上文中，讲解了在javascript中this的各个情况，写完之后发现还落下一种情况，就此补充。</p>\n<p>上文中this的其中一种情况是构造函数的，具体的内容可以参考原文，此处不再赘述。</p>\n<p>要补充的内容是，在构造函数的prototype中，this代表着什么。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-10-this/10-9.png\" alt=\"10-9.png\" title=\"\"><br>如上代码，在Fn.prototype.getName函数中，this指向的是f1对象。因此可以通过this.name获取f1.name的值。</p>\n<p>\n      <span style=\"background-color: #87daff;\">其实，不仅仅是构造函数的prototype，即便是在整个原型链中，this代表的也都是当前对象的值</span>\n  。</p>\n<p>好了，聊完了this。接着上一节继续说“执行上下文栈”。</p>"},{"title":"深入理解javascript原型和闭包(11)--执行上下文栈","date":"2017-04-16T16:27:02.000Z","_content":"{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3989357.html 深入理解javascript原型和闭包（11）——执行上下文栈 %}\n{% endblockquote %}\n继续上文的内容。\n\n执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。{% raw %}\n                                                                                                                       <span style=\"background-color: #87daff;\">处于活动状态的执行上下文环境只有一个</span>\n                                                                                                                     {% endraw %}。\n\n{% raw %}\n <span style=\"background-color: #87daff;\">其实这是一个压栈出栈的过程——执行上下文栈</span>\n{% endraw %}。如下图：\n{% asset_img '11-1.png' %}\n可根据以下代码来详细介绍上下文栈的压栈、出栈过程。\n{% asset_img '11-2.png' %}\n如上代码。\n<!-- more -->\n\n在执行代码之前，首先将创建全局上下文环境。\n{% asset_img '11-3.png' %}\n然后是代码执行。代码执行到第12行之前，上下文环境中的变量都在执行过程中被赋值。\n{% asset_img '11-4.png' %}\n执行到第13行，调用bar函数。\n\n跳转到bar函数内部，执行函数体语句之前，会创建一个新的执行上下文环境。\n{% asset_img '11-5.png' %}\n并将这个执行上下文环境压栈，设置为活动状态。\n{% asset_img '11-6.png' %}\n执行到第5行，又调用了fn函数。进入fn函数，在执行函数体语句之前，会创建fn函数的执行上下文环境，并压栈，设置为活动状态。\n{% asset_img '11-7.png' %}\n待第5行执行完毕，即fn函数执行完毕后，此次调用fn所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。\n{% asset_img '11-8.png' %}\n同理，待第13行执行完毕，即bar函数执行完毕后，调用bar函数所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。\n{% asset_img '11-9.png' %}\n好了，我很耐心的给大家介绍了一段简短代码的执行上下文环境的变化过程，一个完整的闭环。其中上下文环境的变量赋值过程我省略了许多，因为那些并不难，一看就知道。\n\n\n\n讲到这里，我不得不很遗憾的跟大家说：其实以上我们所演示的是一种比较理想的情况。有一种情况，而且是很常用的一种情况，无法做到这样干净利落的说销毁就销毁。这种情况就是伟大的——闭包。\n\n要说闭包，咱们还得先从自由变量和作用域说起。","source":"_posts/2017-04-17-深入理解javascript原型和闭包-11-执行上下文栈.md","raw":"---\ntitle: 深入理解javascript原型和闭包(11)--执行上下文栈\ncategories: 王福朋-深入理解javascript原型和闭包系列\ntags:\n  - javascript\n  - 原型链\n  - 闭包\ndate: 2017-04-17 00:27:02\n---\n{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3989357.html 深入理解javascript原型和闭包（11）——执行上下文栈 %}\n{% endblockquote %}\n继续上文的内容。\n\n执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。{% raw %}\n                                                                                                                       <span style=\"background-color: #87daff;\">处于活动状态的执行上下文环境只有一个</span>\n                                                                                                                     {% endraw %}。\n\n{% raw %}\n <span style=\"background-color: #87daff;\">其实这是一个压栈出栈的过程——执行上下文栈</span>\n{% endraw %}。如下图：\n{% asset_img '11-1.png' %}\n可根据以下代码来详细介绍上下文栈的压栈、出栈过程。\n{% asset_img '11-2.png' %}\n如上代码。\n<!-- more -->\n\n在执行代码之前，首先将创建全局上下文环境。\n{% asset_img '11-3.png' %}\n然后是代码执行。代码执行到第12行之前，上下文环境中的变量都在执行过程中被赋值。\n{% asset_img '11-4.png' %}\n执行到第13行，调用bar函数。\n\n跳转到bar函数内部，执行函数体语句之前，会创建一个新的执行上下文环境。\n{% asset_img '11-5.png' %}\n并将这个执行上下文环境压栈，设置为活动状态。\n{% asset_img '11-6.png' %}\n执行到第5行，又调用了fn函数。进入fn函数，在执行函数体语句之前，会创建fn函数的执行上下文环境，并压栈，设置为活动状态。\n{% asset_img '11-7.png' %}\n待第5行执行完毕，即fn函数执行完毕后，此次调用fn所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。\n{% asset_img '11-8.png' %}\n同理，待第13行执行完毕，即bar函数执行完毕后，调用bar函数所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。\n{% asset_img '11-9.png' %}\n好了，我很耐心的给大家介绍了一段简短代码的执行上下文环境的变化过程，一个完整的闭环。其中上下文环境的变量赋值过程我省略了许多，因为那些并不难，一看就知道。\n\n\n\n讲到这里，我不得不很遗憾的跟大家说：其实以上我们所演示的是一种比较理想的情况。有一种情况，而且是很常用的一种情况，无法做到这样干净利落的说销毁就销毁。这种情况就是伟大的——闭包。\n\n要说闭包，咱们还得先从自由变量和作用域说起。","slug":"深入理解javascript原型和闭包-11-执行上下文栈","published":1,"updated":"2017-04-16T17:41:12.722Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1lk6ec3000syouafgunqzqu","content":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3989357.html\" target=\"_blank\" rel=\"external\">深入理解javascript原型和闭包（11）——执行上下文栈</a></cite></footer></blockquote>\n<p>继续上文的内容。</p>\n<p>执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。\n                                                                                                                       <span style=\"background-color: #87daff;\">处于活动状态的执行上下文环境只有一个</span>\n                                                                                                                     。</p>\n\n <span style=\"background-color: #87daff;\">其实这是一个压栈出栈的过程——执行上下文栈</span>\n。如下图：<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-11-执行上下文栈/11-1.png\" alt=\"11-1.png\" title=\"\">\n<p>可根据以下代码来详细介绍上下文栈的压栈、出栈过程。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-11-执行上下文栈/11-2.png\" alt=\"11-2.png\" title=\"\"><br>如上代码。<br><a id=\"more\"></a></p>\n<p>在执行代码之前，首先将创建全局上下文环境。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-11-执行上下文栈/11-3.png\" alt=\"11-3.png\" title=\"\"><br>然后是代码执行。代码执行到第12行之前，上下文环境中的变量都在执行过程中被赋值。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-11-执行上下文栈/11-4.png\" alt=\"11-4.png\" title=\"\"><br>执行到第13行，调用bar函数。</p>\n<p>跳转到bar函数内部，执行函数体语句之前，会创建一个新的执行上下文环境。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-11-执行上下文栈/11-5.png\" alt=\"11-5.png\" title=\"\"><br>并将这个执行上下文环境压栈，设置为活动状态。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-11-执行上下文栈/11-6.png\" alt=\"11-6.png\" title=\"\"><br>执行到第5行，又调用了fn函数。进入fn函数，在执行函数体语句之前，会创建fn函数的执行上下文环境，并压栈，设置为活动状态。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-11-执行上下文栈/11-7.png\" alt=\"11-7.png\" title=\"\"><br>待第5行执行完毕，即fn函数执行完毕后，此次调用fn所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-11-执行上下文栈/11-8.png\" alt=\"11-8.png\" title=\"\"><br>同理，待第13行执行完毕，即bar函数执行完毕后，调用bar函数所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-11-执行上下文栈/11-9.png\" alt=\"11-9.png\" title=\"\"><br>好了，我很耐心的给大家介绍了一段简短代码的执行上下文环境的变化过程，一个完整的闭环。其中上下文环境的变量赋值过程我省略了许多，因为那些并不难，一看就知道。</p>\n<p>讲到这里，我不得不很遗憾的跟大家说：其实以上我们所演示的是一种比较理想的情况。有一种情况，而且是很常用的一种情况，无法做到这样干净利落的说销毁就销毁。这种情况就是伟大的——闭包。</p>\n<p>要说闭包，咱们还得先从自由变量和作用域说起。</p>\n","site":{"data":{}},"excerpt":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3989357.html\">深入理解javascript原型和闭包（11）——执行上下文栈</a></cite></footer></blockquote>\n<p>继续上文的内容。</p>\n<p>执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。\n                                                                                                                       <span style=\"background-color: #87daff;\">处于活动状态的执行上下文环境只有一个</span>\n                                                                                                                     。</p>\n\n <span style=\"background-color: #87daff;\">其实这是一个压栈出栈的过程——执行上下文栈</span>\n。如下图：<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-11-执行上下文栈/11-1.png\" alt=\"11-1.png\" title=\"\">\n<p>可根据以下代码来详细介绍上下文栈的压栈、出栈过程。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-11-执行上下文栈/11-2.png\" alt=\"11-2.png\" title=\"\"><br>如上代码。<br>","more":"</p>\n<p>在执行代码之前，首先将创建全局上下文环境。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-11-执行上下文栈/11-3.png\" alt=\"11-3.png\" title=\"\"><br>然后是代码执行。代码执行到第12行之前，上下文环境中的变量都在执行过程中被赋值。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-11-执行上下文栈/11-4.png\" alt=\"11-4.png\" title=\"\"><br>执行到第13行，调用bar函数。</p>\n<p>跳转到bar函数内部，执行函数体语句之前，会创建一个新的执行上下文环境。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-11-执行上下文栈/11-5.png\" alt=\"11-5.png\" title=\"\"><br>并将这个执行上下文环境压栈，设置为活动状态。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-11-执行上下文栈/11-6.png\" alt=\"11-6.png\" title=\"\"><br>执行到第5行，又调用了fn函数。进入fn函数，在执行函数体语句之前，会创建fn函数的执行上下文环境，并压栈，设置为活动状态。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-11-执行上下文栈/11-7.png\" alt=\"11-7.png\" title=\"\"><br>待第5行执行完毕，即fn函数执行完毕后，此次调用fn所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-11-执行上下文栈/11-8.png\" alt=\"11-8.png\" title=\"\"><br>同理，待第13行执行完毕，即bar函数执行完毕后，调用bar函数所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-11-执行上下文栈/11-9.png\" alt=\"11-9.png\" title=\"\"><br>好了，我很耐心的给大家介绍了一段简短代码的执行上下文环境的变化过程，一个完整的闭环。其中上下文环境的变量赋值过程我省略了许多，因为那些并不难，一看就知道。</p>\n<p>讲到这里，我不得不很遗憾的跟大家说：其实以上我们所演示的是一种比较理想的情况。有一种情况，而且是很常用的一种情况，无法做到这样干净利落的说销毁就销毁。这种情况就是伟大的——闭包。</p>\n<p>要说闭包，咱们还得先从自由变量和作用域说起。</p>"},{"title":"深入理解javascript原型和闭包(12)--简介【作用域】","date":"2017-04-16T16:40:13.000Z","_content":"{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3991151.html 深入理解javascript原型和闭包（12）——简介【作用域】 %}\n{% endblockquote %}\n提到作用域，有一句话大家（有js开发经验者）可能比较熟悉：“javascript没有块级作用域”。所谓“块”，就是大括号“｛｝”中间的语句。例如if语句：\n```javascript\nvar i = 10\nif (i > 1) {\n    var name = '王福朋'\n}\nconsole.log(name) //  王福朋\n```\n再比如for语句：\n```javascript\nfor(var i = 0; i < 10; i++){\n    //...\n}\nconsole.log(i) //  10\n```\n所以，我们在编写代码的时候，不要在“块”里面声明变量，要在代码的一开始就声明好了。以避免发生歧义。如：\n```javascript\nvar i\nfor(i = 0; i < 10; i++){\n    //...\n}\nconsole.log(i) //  10\n```\n其实，你光知道“javascript没有块级作用域”是完全不够的，你需要知道的是——{% raw %}\n                                                                               <span style=\"background-color: #87daff;\">javascript除了全局作用域之外，只有函数可以创建的作用域</span>\n                                                                             {% endraw %}。\n\n所以，{% raw %}\n      <span style=\"background-color: #87daff;\">我们在声明变量时，全局代码要在代码前端声明，函数中要在函数体一开始就声明好。除了这两个地方，其他地方都不要出现变量声明。而且建议用“单var”形式</span>\n    {% endraw %}。\n\njQuery就是一个很好的示例：\n{% asset_img '12-1.png' %}\n<!-- more -->\n\n下面继续说作用域。作用域是一个很抽象的概念，类似于一个“地盘”\n{% asset_img '12-2.png' %}\n如上图，全局代码和fn、bar两个函数都会形成一个作用域。而且，{% raw %}\n                                      <span style=\"background-color: #87daff;\">作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的</span>\n                                    {% endraw %}。例如，fn作用域下创建了bar函数，那么“fn作用域”就是“bar作用域”的上级。\n\n\n\n{% raw %}\n  <span style=\"background-color: #87daff;\">作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突</span>\n{% endraw %}。例如以上代码中，三个作用域下都声明了“a”这个变量，但是他们不会有冲突。各自的作用域下，用各自的“a”。\n\n说到这里，咱们又可以拿出jquery源码来讲讲了。\n\njQuery源码的最外层是一个自动执行的匿名函数：\n{% asset_img '12-3.png' %}\n为什么要这样做呢？\n\n原因就是在jQuery源码中，声明了大量的变量，这些变量将通过一个函数被限制在一个独立的作用域中，而不会与全局作用域或者其他函数作用域的同名变量产生冲突。\n\n全世界的开发者都在用jQuery，如果不这样做，很可能导致jQuery源码中的变量与外部javascript代码中的变量重名，从而产生冲突。\n\n\n\n作用域这块只是很不好解释，咱们就小步快跑，一步一步慢慢展示给大家。\n\n下一节将把作用域和执行上下文环境结合起来说一说。\n\n可见，要理解闭包，不是一两句话能说清楚的。。。","source":"_posts/2017-04-17-深入理解javascript原型和闭包-12-简介【作用域】.md","raw":"---\ntitle: 深入理解javascript原型和闭包(12)--简介【作用域】\ncategories: 王福朋-深入理解javascript原型和闭包系列\ntags:\n  - javascript\n  - 原型链\n  - 闭包\ndate: 2017-04-17 00:40:13\n---\n{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3991151.html 深入理解javascript原型和闭包（12）——简介【作用域】 %}\n{% endblockquote %}\n提到作用域，有一句话大家（有js开发经验者）可能比较熟悉：“javascript没有块级作用域”。所谓“块”，就是大括号“｛｝”中间的语句。例如if语句：\n```javascript\nvar i = 10\nif (i > 1) {\n    var name = '王福朋'\n}\nconsole.log(name) //  王福朋\n```\n再比如for语句：\n```javascript\nfor(var i = 0; i < 10; i++){\n    //...\n}\nconsole.log(i) //  10\n```\n所以，我们在编写代码的时候，不要在“块”里面声明变量，要在代码的一开始就声明好了。以避免发生歧义。如：\n```javascript\nvar i\nfor(i = 0; i < 10; i++){\n    //...\n}\nconsole.log(i) //  10\n```\n其实，你光知道“javascript没有块级作用域”是完全不够的，你需要知道的是——{% raw %}\n                                                                               <span style=\"background-color: #87daff;\">javascript除了全局作用域之外，只有函数可以创建的作用域</span>\n                                                                             {% endraw %}。\n\n所以，{% raw %}\n      <span style=\"background-color: #87daff;\">我们在声明变量时，全局代码要在代码前端声明，函数中要在函数体一开始就声明好。除了这两个地方，其他地方都不要出现变量声明。而且建议用“单var”形式</span>\n    {% endraw %}。\n\njQuery就是一个很好的示例：\n{% asset_img '12-1.png' %}\n<!-- more -->\n\n下面继续说作用域。作用域是一个很抽象的概念，类似于一个“地盘”\n{% asset_img '12-2.png' %}\n如上图，全局代码和fn、bar两个函数都会形成一个作用域。而且，{% raw %}\n                                      <span style=\"background-color: #87daff;\">作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的</span>\n                                    {% endraw %}。例如，fn作用域下创建了bar函数，那么“fn作用域”就是“bar作用域”的上级。\n\n\n\n{% raw %}\n  <span style=\"background-color: #87daff;\">作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突</span>\n{% endraw %}。例如以上代码中，三个作用域下都声明了“a”这个变量，但是他们不会有冲突。各自的作用域下，用各自的“a”。\n\n说到这里，咱们又可以拿出jquery源码来讲讲了。\n\njQuery源码的最外层是一个自动执行的匿名函数：\n{% asset_img '12-3.png' %}\n为什么要这样做呢？\n\n原因就是在jQuery源码中，声明了大量的变量，这些变量将通过一个函数被限制在一个独立的作用域中，而不会与全局作用域或者其他函数作用域的同名变量产生冲突。\n\n全世界的开发者都在用jQuery，如果不这样做，很可能导致jQuery源码中的变量与外部javascript代码中的变量重名，从而产生冲突。\n\n\n\n作用域这块只是很不好解释，咱们就小步快跑，一步一步慢慢展示给大家。\n\n下一节将把作用域和执行上下文环境结合起来说一说。\n\n可见，要理解闭包，不是一两句话能说清楚的。。。","slug":"深入理解javascript原型和闭包-12-简介【作用域】","published":1,"updated":"2017-04-16T17:41:33.236Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1lk6ec8000wyouauc1065wf","content":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3991151.html\" target=\"_blank\" rel=\"external\">深入理解javascript原型和闭包（12）——简介【作用域】</a></cite></footer></blockquote>\n<p>提到作用域，有一句话大家（有js开发经验者）可能比较熟悉：“javascript没有块级作用域”。所谓“块”，就是大括号“｛｝”中间的语句。例如if语句：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"number\">10</span></div><div class=\"line\"><span class=\"keyword\">if</span> (i &gt; <span class=\"number\">1</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">'王福朋'</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(name) <span class=\"comment\">//  王福朋</span></div></pre></td></tr></table></figure></p>\n<p>再比如for语句：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)&#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(i) <span class=\"comment\">//  10</span></div></pre></td></tr></table></figure></p>\n<p>所以，我们在编写代码的时候，不要在“块”里面声明变量，要在代码的一开始就声明好了。以避免发生歧义。如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> i</div><div class=\"line\"><span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)&#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(i) <span class=\"comment\">//  10</span></div></pre></td></tr></table></figure></p>\n<p>其实，你光知道“javascript没有块级作用域”是完全不够的，你需要知道的是——\n                                                                               <span style=\"background-color: #87daff;\">javascript除了全局作用域之外，只有函数可以创建的作用域</span>\n                                                                             。</p>\n<p>所以，\n      <span style=\"background-color: #87daff;\">我们在声明变量时，全局代码要在代码前端声明，函数中要在函数体一开始就声明好。除了这两个地方，其他地方都不要出现变量声明。而且建议用“单var”形式</span>\n    。</p>\n<p>jQuery就是一个很好的示例：<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-12-简介【作用域】/12-1.png\" alt=\"12-1.png\" title=\"\"><br><a id=\"more\"></a></p>\n<p>下面继续说作用域。作用域是一个很抽象的概念，类似于一个“地盘”<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-12-简介【作用域】/12-2.png\" alt=\"12-2.png\" title=\"\"><br>如上图，全局代码和fn、bar两个函数都会形成一个作用域。而且，\n                                      <span style=\"background-color: #87daff;\">作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的</span>\n                                    。例如，fn作用域下创建了bar函数，那么“fn作用域”就是“bar作用域”的上级。</p>\n\n  <span style=\"background-color: #87daff;\">作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突</span>\n。例如以上代码中，三个作用域下都声明了“a”这个变量，但是他们不会有冲突。各自的作用域下，用各自的“a”。<br><br>说到这里，咱们又可以拿出jquery源码来讲讲了。<br><br>jQuery源码的最外层是一个自动执行的匿名函数：<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-12-简介【作用域】/12-3.png\" alt=\"12-3.png\" title=\"\">\n<p>为什么要这样做呢？</p>\n<p>原因就是在jQuery源码中，声明了大量的变量，这些变量将通过一个函数被限制在一个独立的作用域中，而不会与全局作用域或者其他函数作用域的同名变量产生冲突。</p>\n<p>全世界的开发者都在用jQuery，如果不这样做，很可能导致jQuery源码中的变量与外部javascript代码中的变量重名，从而产生冲突。</p>\n<p>作用域这块只是很不好解释，咱们就小步快跑，一步一步慢慢展示给大家。</p>\n<p>下一节将把作用域和执行上下文环境结合起来说一说。</p>\n<p>可见，要理解闭包，不是一两句话能说清楚的。。。</p>\n","site":{"data":{}},"excerpt":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3991151.html\">深入理解javascript原型和闭包（12）——简介【作用域】</a></cite></footer></blockquote>\n<p>提到作用域，有一句话大家（有js开发经验者）可能比较熟悉：“javascript没有块级作用域”。所谓“块”，就是大括号“｛｝”中间的语句。例如if语句：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"number\">10</span></div><div class=\"line\"><span class=\"keyword\">if</span> (i &gt; <span class=\"number\">1</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">'王福朋'</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(name) <span class=\"comment\">//  王福朋</span></div></pre></td></tr></table></figure></p>\n<p>再比如for语句：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)&#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(i) <span class=\"comment\">//  10</span></div></pre></td></tr></table></figure></p>\n<p>所以，我们在编写代码的时候，不要在“块”里面声明变量，要在代码的一开始就声明好了。以避免发生歧义。如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> i</div><div class=\"line\"><span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)&#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(i) <span class=\"comment\">//  10</span></div></pre></td></tr></table></figure></p>\n<p>其实，你光知道“javascript没有块级作用域”是完全不够的，你需要知道的是——\n                                                                               <span style=\"background-color: #87daff;\">javascript除了全局作用域之外，只有函数可以创建的作用域</span>\n                                                                             。</p>\n<p>所以，\n      <span style=\"background-color: #87daff;\">我们在声明变量时，全局代码要在代码前端声明，函数中要在函数体一开始就声明好。除了这两个地方，其他地方都不要出现变量声明。而且建议用“单var”形式</span>\n    。</p>\n<p>jQuery就是一个很好的示例：<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-12-简介【作用域】/12-1.png\" alt=\"12-1.png\" title=\"\"><br>","more":"</p>\n<p>下面继续说作用域。作用域是一个很抽象的概念，类似于一个“地盘”<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-12-简介【作用域】/12-2.png\" alt=\"12-2.png\" title=\"\"><br>如上图，全局代码和fn、bar两个函数都会形成一个作用域。而且，\n                                      <span style=\"background-color: #87daff;\">作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的</span>\n                                    。例如，fn作用域下创建了bar函数，那么“fn作用域”就是“bar作用域”的上级。</p>\n\n  <span style=\"background-color: #87daff;\">作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突</span>\n。例如以上代码中，三个作用域下都声明了“a”这个变量，但是他们不会有冲突。各自的作用域下，用各自的“a”。<br><br>说到这里，咱们又可以拿出jquery源码来讲讲了。<br><br>jQuery源码的最外层是一个自动执行的匿名函数：<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-12-简介【作用域】/12-3.png\" alt=\"12-3.png\" title=\"\">\n<p>为什么要这样做呢？</p>\n<p>原因就是在jQuery源码中，声明了大量的变量，这些变量将通过一个函数被限制在一个独立的作用域中，而不会与全局作用域或者其他函数作用域的同名变量产生冲突。</p>\n<p>全世界的开发者都在用jQuery，如果不这样做，很可能导致jQuery源码中的变量与外部javascript代码中的变量重名，从而产生冲突。</p>\n<p>作用域这块只是很不好解释，咱们就小步快跑，一步一步慢慢展示给大家。</p>\n<p>下一节将把作用域和执行上下文环境结合起来说一说。</p>\n<p>可见，要理解闭包，不是一两句话能说清楚的。。。</p>"},{"title":"深入理解javascript原型和闭包(13)--【作用域】和【上下文环境】","date":"2017-04-16T16:51:26.000Z","_content":"{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3991995.html 深入理解javascript原型和闭包（13）——【作用域】和【上下文环境】 %}\n{% endblockquote %}\n\n上文简单介绍了作用域，本文把作用域和上下文环境结合起来说一下，会理解的更深一些。\n{% asset_img '13-1.png' %}\n如上图，我们在上文中已经介绍了，除了全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时确定。\n\n下面我们将按照程序执行的顺序，一步一步把各个上下文环境加上。另外，对上下文环境不了解的朋友，可以去看看之前的两篇文章：\n{% post_link 深入理解javascript原型和闭包-8-简述【执行上下文】上 深入理解javascript原型和闭包-8-简述【执行上下文】上 %}\n{% post_link 深入理解javascript原型和闭包-9-简述【执行上下文】下 深入理解javascript原型和闭包-9-简述【执行上下文】下 %}\n<!-- more -->\n\n\n第一步，在加载程序时，已经确定了全局上下文环境，并随着程序的执行而对变量就行赋值。\n{% asset_img '13-2.png' %}\n\n第二步，程序执行到第27行，调用fn(10)，此时生成此次调用fn函数时的上下文环境，压栈，并将此上下文环境设置为活动状态。\n{% asset_img '13-3.png' %}\n\n第三步，执行到第23行时，调用bar(100)，生成此次调用的上下文环境，压栈，并设置为活动状态。\n{% asset_img '13-4.png' %}\n\n第四步，执行完第23行，bar(100)调用完成。则bar(100)上下文环境被销毁。接着执行第24行，调用bar(200)，则又生成bar(200)的上下文环境，压栈，设置为活动状态。\n{% asset_img '13-5.png' %}\n\n第五步，执行完第24行，则bar(200)调用结束，其上下文环境被销毁。此时会回到fn(10)上下文环境，变为活动状态。\n{% asset_img '13-6.png' %}\n\n第六步，执行完第27行代码，fn(10)执行完成之后，fn(10)上下文环境被销毁，全局上下文环境又回到活动状态。\n{% asset_img '13-7.png' %}\n\n\n结束了。像老太太的裹脚布——又臭又长！\n\n\n\n最后我们可以把以上这几个图片连接起来看看。\n{% asset_img '13-8.png' %}\n\n连接起来看，还是挺有意思的。{% raw %}\n                             <span style=\"background-color: #87daff;\">作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值</span>\n                           {% endraw %}。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，{% raw %}\n                                                                                                               <span style=\"background-color: #87daff;\">作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了</span>\n                                                                                                             {% endraw %}。\n\n所以，{% raw %}\n          <span style=\"background-color: #87daff;\">如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值</span>\n        {% endraw %}。\n\n\n\n虽然本文很长，但是文字较少，图片居多，图片都有形象的展示，大家花十几分钟也能慢慢看完。但是，这节内容真的很重要。\n\n以上代码中，咱们还没有设计到跨作用域取值的情况，即——自由变量。详细内容且听下回分解。","source":"_posts/2017-04-17-深入理解javascript原型和闭包-13-【作用域】和【上下文环境】.md","raw":"---\ntitle: 深入理解javascript原型和闭包(13)--【作用域】和【上下文环境】\ncategories: 王福朋-深入理解javascript原型和闭包系列\ntags:\n  - javascript\n  - 原型链\n  - 闭包\ndate: 2017-04-17 00:51:26\n---\n{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3991995.html 深入理解javascript原型和闭包（13）——【作用域】和【上下文环境】 %}\n{% endblockquote %}\n\n上文简单介绍了作用域，本文把作用域和上下文环境结合起来说一下，会理解的更深一些。\n{% asset_img '13-1.png' %}\n如上图，我们在上文中已经介绍了，除了全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时确定。\n\n下面我们将按照程序执行的顺序，一步一步把各个上下文环境加上。另外，对上下文环境不了解的朋友，可以去看看之前的两篇文章：\n{% post_link 深入理解javascript原型和闭包-8-简述【执行上下文】上 深入理解javascript原型和闭包-8-简述【执行上下文】上 %}\n{% post_link 深入理解javascript原型和闭包-9-简述【执行上下文】下 深入理解javascript原型和闭包-9-简述【执行上下文】下 %}\n<!-- more -->\n\n\n第一步，在加载程序时，已经确定了全局上下文环境，并随着程序的执行而对变量就行赋值。\n{% asset_img '13-2.png' %}\n\n第二步，程序执行到第27行，调用fn(10)，此时生成此次调用fn函数时的上下文环境，压栈，并将此上下文环境设置为活动状态。\n{% asset_img '13-3.png' %}\n\n第三步，执行到第23行时，调用bar(100)，生成此次调用的上下文环境，压栈，并设置为活动状态。\n{% asset_img '13-4.png' %}\n\n第四步，执行完第23行，bar(100)调用完成。则bar(100)上下文环境被销毁。接着执行第24行，调用bar(200)，则又生成bar(200)的上下文环境，压栈，设置为活动状态。\n{% asset_img '13-5.png' %}\n\n第五步，执行完第24行，则bar(200)调用结束，其上下文环境被销毁。此时会回到fn(10)上下文环境，变为活动状态。\n{% asset_img '13-6.png' %}\n\n第六步，执行完第27行代码，fn(10)执行完成之后，fn(10)上下文环境被销毁，全局上下文环境又回到活动状态。\n{% asset_img '13-7.png' %}\n\n\n结束了。像老太太的裹脚布——又臭又长！\n\n\n\n最后我们可以把以上这几个图片连接起来看看。\n{% asset_img '13-8.png' %}\n\n连接起来看，还是挺有意思的。{% raw %}\n                             <span style=\"background-color: #87daff;\">作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值</span>\n                           {% endraw %}。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，{% raw %}\n                                                                                                               <span style=\"background-color: #87daff;\">作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了</span>\n                                                                                                             {% endraw %}。\n\n所以，{% raw %}\n          <span style=\"background-color: #87daff;\">如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值</span>\n        {% endraw %}。\n\n\n\n虽然本文很长，但是文字较少，图片居多，图片都有形象的展示，大家花十几分钟也能慢慢看完。但是，这节内容真的很重要。\n\n以上代码中，咱们还没有设计到跨作用域取值的情况，即——自由变量。详细内容且听下回分解。","slug":"深入理解javascript原型和闭包-13-【作用域】和【上下文环境】","published":1,"updated":"2017-04-16T17:41:48.209Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1lk6ecf000zyouansemwoui","content":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3991995.html\" target=\"_blank\" rel=\"external\">深入理解javascript原型和闭包（13）——【作用域】和【上下文环境】</a></cite></footer></blockquote>\n<p>上文简单介绍了作用域，本文把作用域和上下文环境结合起来说一下，会理解的更深一些。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-1.png\" alt=\"13-1.png\" title=\"\"><br>如上图，我们在上文中已经介绍了，除了全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时确定。</p>\n<p>下面我们将按照程序执行的顺序，一步一步把各个上下文环境加上。另外，对上下文环境不了解的朋友，可以去看看之前的两篇文章：<br><a href=\"/2017/04/16/深入理解javascript原型和闭包-8-简述【执行上下文】上/\" title=\"深入理解javascript原型和闭包-8-简述【执行上下文】上\">深入理解javascript原型和闭包-8-简述【执行上下文】上</a><br><a href=\"/2017/04/16/深入理解javascript原型和闭包-9-简述【执行上下文】下/\" title=\"深入理解javascript原型和闭包-9-简述【执行上下文】下\">深入理解javascript原型和闭包-9-简述【执行上下文】下</a><br><a id=\"more\"></a></p>\n<p>第一步，在加载程序时，已经确定了全局上下文环境，并随着程序的执行而对变量就行赋值。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-2.png\" alt=\"13-2.png\" title=\"\"></p>\n<p>第二步，程序执行到第27行，调用fn(10)，此时生成此次调用fn函数时的上下文环境，压栈，并将此上下文环境设置为活动状态。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-3.png\" alt=\"13-3.png\" title=\"\"></p>\n<p>第三步，执行到第23行时，调用bar(100)，生成此次调用的上下文环境，压栈，并设置为活动状态。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-4.png\" alt=\"13-4.png\" title=\"\"></p>\n<p>第四步，执行完第23行，bar(100)调用完成。则bar(100)上下文环境被销毁。接着执行第24行，调用bar(200)，则又生成bar(200)的上下文环境，压栈，设置为活动状态。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-5.png\" alt=\"13-5.png\" title=\"\"></p>\n<p>第五步，执行完第24行，则bar(200)调用结束，其上下文环境被销毁。此时会回到fn(10)上下文环境，变为活动状态。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-6.png\" alt=\"13-6.png\" title=\"\"></p>\n<p>第六步，执行完第27行代码，fn(10)执行完成之后，fn(10)上下文环境被销毁，全局上下文环境又回到活动状态。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-7.png\" alt=\"13-7.png\" title=\"\"></p>\n<p>结束了。像老太太的裹脚布——又臭又长！</p>\n<p>最后我们可以把以上这几个图片连接起来看看。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-8.png\" alt=\"13-8.png\" title=\"\"></p>\n<p>连接起来看，还是挺有意思的。\n                             <span style=\"background-color: #87daff;\">作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值</span>\n                           。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，\n                                                                                                               <span style=\"background-color: #87daff;\">作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了</span>\n                                                                                                             。</p>\n<p>所以，\n          <span style=\"background-color: #87daff;\">如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值</span>\n        。</p>\n<p>虽然本文很长，但是文字较少，图片居多，图片都有形象的展示，大家花十几分钟也能慢慢看完。但是，这节内容真的很重要。</p>\n<p>以上代码中，咱们还没有设计到跨作用域取值的情况，即——自由变量。详细内容且听下回分解。</p>\n","site":{"data":{}},"excerpt":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3991995.html\">深入理解javascript原型和闭包（13）——【作用域】和【上下文环境】</a></cite></footer></blockquote>\n<p>上文简单介绍了作用域，本文把作用域和上下文环境结合起来说一下，会理解的更深一些。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-1.png\" alt=\"13-1.png\" title=\"\"><br>如上图，我们在上文中已经介绍了，除了全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时确定。</p>\n<p>下面我们将按照程序执行的顺序，一步一步把各个上下文环境加上。另外，对上下文环境不了解的朋友，可以去看看之前的两篇文章：<br><a href=\"/2017/04/16/深入理解javascript原型和闭包-8-简述【执行上下文】上/\" title=\"深入理解javascript原型和闭包-8-简述【执行上下文】上\">深入理解javascript原型和闭包-8-简述【执行上下文】上</a><br><a href=\"/2017/04/16/深入理解javascript原型和闭包-9-简述【执行上下文】下/\" title=\"深入理解javascript原型和闭包-9-简述【执行上下文】下\">深入理解javascript原型和闭包-9-简述【执行上下文】下</a><br>","more":"</p>\n<p>第一步，在加载程序时，已经确定了全局上下文环境，并随着程序的执行而对变量就行赋值。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-2.png\" alt=\"13-2.png\" title=\"\"></p>\n<p>第二步，程序执行到第27行，调用fn(10)，此时生成此次调用fn函数时的上下文环境，压栈，并将此上下文环境设置为活动状态。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-3.png\" alt=\"13-3.png\" title=\"\"></p>\n<p>第三步，执行到第23行时，调用bar(100)，生成此次调用的上下文环境，压栈，并设置为活动状态。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-4.png\" alt=\"13-4.png\" title=\"\"></p>\n<p>第四步，执行完第23行，bar(100)调用完成。则bar(100)上下文环境被销毁。接着执行第24行，调用bar(200)，则又生成bar(200)的上下文环境，压栈，设置为活动状态。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-5.png\" alt=\"13-5.png\" title=\"\"></p>\n<p>第五步，执行完第24行，则bar(200)调用结束，其上下文环境被销毁。此时会回到fn(10)上下文环境，变为活动状态。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-6.png\" alt=\"13-6.png\" title=\"\"></p>\n<p>第六步，执行完第27行代码，fn(10)执行完成之后，fn(10)上下文环境被销毁，全局上下文环境又回到活动状态。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-7.png\" alt=\"13-7.png\" title=\"\"></p>\n<p>结束了。像老太太的裹脚布——又臭又长！</p>\n<p>最后我们可以把以上这几个图片连接起来看看。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-8.png\" alt=\"13-8.png\" title=\"\"></p>\n<p>连接起来看，还是挺有意思的。\n                             <span style=\"background-color: #87daff;\">作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值</span>\n                           。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，\n                                                                                                               <span style=\"background-color: #87daff;\">作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了</span>\n                                                                                                             。</p>\n<p>所以，\n          <span style=\"background-color: #87daff;\">如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值</span>\n        。</p>\n<p>虽然本文很长，但是文字较少，图片居多，图片都有形象的展示，大家花十几分钟也能慢慢看完。但是，这节内容真的很重要。</p>\n<p>以上代码中，咱们还没有设计到跨作用域取值的情况，即——自由变量。详细内容且听下回分解。</p>"},{"title":"深入理解javascript原型和闭包(14)--从【自由变量】和【作用域链】","date":"2017-04-16T17:05:41.000Z","_content":"{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3992795.html 深入理解javascript原型和闭包（14）——从【自由变量】和【作用域链】 %}\n{% endblockquote %}\n\n先解释一下什么是“自由变量”。\n\n在A作用域中使用的变量x，却没有在A作用域中声明（即在其他作用域中声明的），对于A作用域来说，x就是一个自由变量。如下图\n{% asset_img '14-1.png' %}\n\n如上程序中，在调用fn()函数时，函数体中第6行。取b的值就直接可以在fn作用域中取，因为b就是在这里定义的。而取x的值时，就需要到另一个作用域中取。到哪个作用域中取呢？\n\n{% raw %}\n <span style=\"background-color: #87daff;\">有人说过要到父作用域中取，其实有时候这种解释会产生歧义</span>\n{% endraw %}。例如：\n{% asset_img '14-2.png' %}\n所以，不要在用以上说法了。相比而言，用这句话描述会更加贴切——{% raw %}\n                                <span style=\"background-color: #87daff;\">要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”，切记切记</span>\n                               {% endraw %}——其实这就是所谓的“静态作用域”。\n\n对于本文第一段代码，在fn函数中，取自由变量x的值时，要到哪个作用域中取？——要到创建fn函数的那个作用域中取——无论fn函数将在哪里调用。\n<!-- more -->\n\n\n\n上面描述的只是跨一步作用域去寻找。\n\n如果跨了一步，还没找到呢？——接着跨！——一直跨到全局作用域为止。要是在全局作用域中都没有找到，那就是真的没有了。\n\n这个一步一步“跨”的路线，我们称之为——{% raw %}\n                                        <span style=\"background-color: #87daff;\">作用域链</span>\n                                       {% endraw %}。\n\n我们拿文字总结一下取自由变量时的这个“作用域链”过程：（假设a是自由量）\n{% raw %}\n<p><span style=\"font-family: 幼圆;\">第一步，现在当前作用域查找a，如果有则获取并结束。如果没有则继续；</span></p>\n<p><span style=\"font-family: 幼圆;\">第二步，如果当前作用域是全局作用域，则证明a未定义，结束；否则继续；</span></p>\n<p><span style=\"font-family: 幼圆;\">第三步，（不是全局作用域，那就是函数作用域）将创建该函数的作用域作为当前作用域；</span></p>\n<p><span style=\"font-family: 幼圆;\">第四步，跳转到第一步。</span></p>\n{% endraw %}\n\n{% asset_img '14-3.png' %}\n以上代码中：第13行，fn()返回的是bar函数，赋值给x。执行x()，即执行bar函数代码。取b的值时，直接在fn作用域取出。取a的值时，试图在fn作用域取，但是取不到，只能转向创建fn的那个作用域中去查找，结果找到了。\n\n\n\n这一节看似很轻松的把作用域链引出来，并讲完了。之所有轻松是有前几节的基础，否则将很难解释。\n\n接下来咱们开始正式说说一直期待依旧的朋友——闭包。敬请期待下一节。","source":"_posts/2017-04-17-深入理解javascript原型和闭包-14-从【自由变量】和【作用域链】.md","raw":"---\ntitle: 深入理解javascript原型和闭包(14)--从【自由变量】和【作用域链】\ncategories: 王福朋-深入理解javascript原型和闭包系列\ntags:\n  - javascript\n  - 原型链\n  - 闭包\ndate: 2017-04-17 01:05:41\n---\n{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3992795.html 深入理解javascript原型和闭包（14）——从【自由变量】和【作用域链】 %}\n{% endblockquote %}\n\n先解释一下什么是“自由变量”。\n\n在A作用域中使用的变量x，却没有在A作用域中声明（即在其他作用域中声明的），对于A作用域来说，x就是一个自由变量。如下图\n{% asset_img '14-1.png' %}\n\n如上程序中，在调用fn()函数时，函数体中第6行。取b的值就直接可以在fn作用域中取，因为b就是在这里定义的。而取x的值时，就需要到另一个作用域中取。到哪个作用域中取呢？\n\n{% raw %}\n <span style=\"background-color: #87daff;\">有人说过要到父作用域中取，其实有时候这种解释会产生歧义</span>\n{% endraw %}。例如：\n{% asset_img '14-2.png' %}\n所以，不要在用以上说法了。相比而言，用这句话描述会更加贴切——{% raw %}\n                                <span style=\"background-color: #87daff;\">要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”，切记切记</span>\n                               {% endraw %}——其实这就是所谓的“静态作用域”。\n\n对于本文第一段代码，在fn函数中，取自由变量x的值时，要到哪个作用域中取？——要到创建fn函数的那个作用域中取——无论fn函数将在哪里调用。\n<!-- more -->\n\n\n\n上面描述的只是跨一步作用域去寻找。\n\n如果跨了一步，还没找到呢？——接着跨！——一直跨到全局作用域为止。要是在全局作用域中都没有找到，那就是真的没有了。\n\n这个一步一步“跨”的路线，我们称之为——{% raw %}\n                                        <span style=\"background-color: #87daff;\">作用域链</span>\n                                       {% endraw %}。\n\n我们拿文字总结一下取自由变量时的这个“作用域链”过程：（假设a是自由量）\n{% raw %}\n<p><span style=\"font-family: 幼圆;\">第一步，现在当前作用域查找a，如果有则获取并结束。如果没有则继续；</span></p>\n<p><span style=\"font-family: 幼圆;\">第二步，如果当前作用域是全局作用域，则证明a未定义，结束；否则继续；</span></p>\n<p><span style=\"font-family: 幼圆;\">第三步，（不是全局作用域，那就是函数作用域）将创建该函数的作用域作为当前作用域；</span></p>\n<p><span style=\"font-family: 幼圆;\">第四步，跳转到第一步。</span></p>\n{% endraw %}\n\n{% asset_img '14-3.png' %}\n以上代码中：第13行，fn()返回的是bar函数，赋值给x。执行x()，即执行bar函数代码。取b的值时，直接在fn作用域取出。取a的值时，试图在fn作用域取，但是取不到，只能转向创建fn的那个作用域中去查找，结果找到了。\n\n\n\n这一节看似很轻松的把作用域链引出来，并讲完了。之所有轻松是有前几节的基础，否则将很难解释。\n\n接下来咱们开始正式说说一直期待依旧的朋友——闭包。敬请期待下一节。","slug":"深入理解javascript原型和闭包-14-从【自由变量】和【作用域链】","published":1,"updated":"2017-04-16T17:41:59.457Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1lk6ecs0013youayswt32ib","content":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3992795.html\" target=\"_blank\" rel=\"external\">深入理解javascript原型和闭包（14）——从【自由变量】和【作用域链】</a></cite></footer></blockquote>\n<p>先解释一下什么是“自由变量”。</p>\n<p>在A作用域中使用的变量x，却没有在A作用域中声明（即在其他作用域中声明的），对于A作用域来说，x就是一个自由变量。如下图<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-14-从【自由变量】和【作用域链】/14-1.png\" alt=\"14-1.png\" title=\"\"></p>\n<p>如上程序中，在调用fn()函数时，函数体中第6行。取b的值就直接可以在fn作用域中取，因为b就是在这里定义的。而取x的值时，就需要到另一个作用域中取。到哪个作用域中取呢？</p>\n\n <span style=\"background-color: #87daff;\">有人说过要到父作用域中取，其实有时候这种解释会产生歧义</span>\n。例如：<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-14-从【自由变量】和【作用域链】/14-2.png\" alt=\"14-2.png\" title=\"\">\n<p>所以，不要在用以上说法了。相比而言，用这句话描述会更加贴切——\n                                <span style=\"background-color: #87daff;\">要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”，切记切记</span>\n                               ——其实这就是所谓的“静态作用域”。</p>\n<p>对于本文第一段代码，在fn函数中，取自由变量x的值时，要到哪个作用域中取？——要到创建fn函数的那个作用域中取——无论fn函数将在哪里调用。<br><a id=\"more\"></a></p>\n<p>上面描述的只是跨一步作用域去寻找。</p>\n<p>如果跨了一步，还没找到呢？——接着跨！——一直跨到全局作用域为止。要是在全局作用域中都没有找到，那就是真的没有了。</p>\n<p>这个一步一步“跨”的路线，我们称之为——\n                                        <span style=\"background-color: #87daff;\">作用域链</span>\n                                       。</p>\n<p>我们拿文字总结一下取自由变量时的这个“作用域链”过程：（假设a是自由量）<br>\n</p><p><span style=\"font-family: 幼圆;\">第一步，现在当前作用域查找a，如果有则获取并结束。如果没有则继续；</span></p>\n<p><span style=\"font-family: 幼圆;\">第二步，如果当前作用域是全局作用域，则证明a未定义，结束；否则继续；</span></p>\n<p><span style=\"font-family: 幼圆;\">第三步，（不是全局作用域，那就是函数作用域）将创建该函数的作用域作为当前作用域；</span></p>\n<p><span style=\"font-family: 幼圆;\">第四步，跳转到第一步。</span></p>\n<p></p>\n<img src=\"/2017/04/17/深入理解javascript原型和闭包-14-从【自由变量】和【作用域链】/14-3.png\" alt=\"14-3.png\" title=\"\">\n<p>以上代码中：第13行，fn()返回的是bar函数，赋值给x。执行x()，即执行bar函数代码。取b的值时，直接在fn作用域取出。取a的值时，试图在fn作用域取，但是取不到，只能转向创建fn的那个作用域中去查找，结果找到了。</p>\n<p>这一节看似很轻松的把作用域链引出来，并讲完了。之所有轻松是有前几节的基础，否则将很难解释。</p>\n<p>接下来咱们开始正式说说一直期待依旧的朋友——闭包。敬请期待下一节。</p>\n","site":{"data":{}},"excerpt":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3992795.html\">深入理解javascript原型和闭包（14）——从【自由变量】和【作用域链】</a></cite></footer></blockquote>\n<p>先解释一下什么是“自由变量”。</p>\n<p>在A作用域中使用的变量x，却没有在A作用域中声明（即在其他作用域中声明的），对于A作用域来说，x就是一个自由变量。如下图<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-14-从【自由变量】和【作用域链】/14-1.png\" alt=\"14-1.png\" title=\"\"></p>\n<p>如上程序中，在调用fn()函数时，函数体中第6行。取b的值就直接可以在fn作用域中取，因为b就是在这里定义的。而取x的值时，就需要到另一个作用域中取。到哪个作用域中取呢？</p>\n\n <span style=\"background-color: #87daff;\">有人说过要到父作用域中取，其实有时候这种解释会产生歧义</span>\n。例如：<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-14-从【自由变量】和【作用域链】/14-2.png\" alt=\"14-2.png\" title=\"\">\n<p>所以，不要在用以上说法了。相比而言，用这句话描述会更加贴切——\n                                <span style=\"background-color: #87daff;\">要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”，切记切记</span>\n                               ——其实这就是所谓的“静态作用域”。</p>\n<p>对于本文第一段代码，在fn函数中，取自由变量x的值时，要到哪个作用域中取？——要到创建fn函数的那个作用域中取——无论fn函数将在哪里调用。<br>","more":"</p>\n<p>上面描述的只是跨一步作用域去寻找。</p>\n<p>如果跨了一步，还没找到呢？——接着跨！——一直跨到全局作用域为止。要是在全局作用域中都没有找到，那就是真的没有了。</p>\n<p>这个一步一步“跨”的路线，我们称之为——\n                                        <span style=\"background-color: #87daff;\">作用域链</span>\n                                       。</p>\n<p>我们拿文字总结一下取自由变量时的这个“作用域链”过程：（假设a是自由量）<br>\n<p><span style=\"font-family: 幼圆;\">第一步，现在当前作用域查找a，如果有则获取并结束。如果没有则继续；</span></p>\n<p><span style=\"font-family: 幼圆;\">第二步，如果当前作用域是全局作用域，则证明a未定义，结束；否则继续；</span></p>\n<p><span style=\"font-family: 幼圆;\">第三步，（不是全局作用域，那就是函数作用域）将创建该函数的作用域作为当前作用域；</span></p>\n<p><span style=\"font-family: 幼圆;\">第四步，跳转到第一步。</span></p>\n</p>\n<img src=\"/2017/04/17/深入理解javascript原型和闭包-14-从【自由变量】和【作用域链】/14-3.png\" alt=\"14-3.png\" title=\"\">\n<p>以上代码中：第13行，fn()返回的是bar函数，赋值给x。执行x()，即执行bar函数代码。取b的值时，直接在fn作用域取出。取a的值时，试图在fn作用域取，但是取不到，只能转向创建fn的那个作用域中去查找，结果找到了。</p>\n<p>这一节看似很轻松的把作用域链引出来，并讲完了。之所有轻松是有前几节的基础，否则将很难解释。</p>\n<p>接下来咱们开始正式说说一直期待依旧的朋友——闭包。敬请期待下一节。</p>"},{"title":"深入理解javascript原型和闭包(15)--闭包","date":"2017-04-16T17:14:08.000Z","_content":"{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3994065.html 深入理解javascript原型和闭包（15）——闭包 %}\n{% endblockquote %}\n\n前面提到的上下文环境和作用域的知识，除了了解这些知识之外，还是理解闭包的基础。\n\n至于“闭包”这个词的概念的文字描述，确实不好解释，我看过很多遍，但是现在还是记不住。\n\n{% raw %}\n <span style=\"background-color: #87daff;\">但是你只需要知道应用的两种情况即可——函数作为返回值，函数作为参数传递</span>\n{% endraw %}。\n<!-- more -->\n\n###### 第一，函数作为返回值\n{% asset_img '15-1.png' %}\n如上代码，bar函数作为返回值，赋值给f1变量。执行f1(15)时，用到了fn作用域下的max变量的值。至于如何跨作用域取值，可以参考上一节。\n\n###### 第二，函数作为参数被传递\n{% asset_img '15-2.png' %}\n如上代码中，fn函数作为一个参数被传递进入另一个函数，赋值给f参数。执行f(15)时，max变量的取值是10，而不是100。\n\n\n\n上一节讲到自由变量跨作用域取值时，曾经强调过：{% raw %}\n                        <span style=\"background-color: #87daff;\">要去创建这个函数的作用域取值，而不是“父作用域”</span>\n                       {% endraw %}。理解了这一点，以上两端代码中，自由变量如何取值应该比较简单。（{% raw %}\n                                                                                           <span style=\"color: #ff0000;\">不明白的朋友一定要去上一节看看，这个很重要！</span>\n                                                                                          {% endraw %}）\n\n\n\n另外，讲到闭包，除了结合着作用域之外，还需要结合着执行上下文栈来说一下。\n\n在前面讲执行上下文栈时（{% post_link 深入理解javascript原型和闭包-11-执行上下文栈 深入理解javascript原型和闭包-11-执行上下文栈 %}），我们提到当一个函数被调用完成之后，其执行上下文环境将被销毁，其中的变量也会被同时销毁。\n\n但是在当时那篇文章中留了一个问号——有些情况下，函数调用完成之后，其执行上下文环境不会接着被销毁。这就是需要理解闭包的核心内容。\n\n咱们可以拿本文的第一段代码（稍作修改）来分析一下。\n{% asset_img '15-3.png' %}\n\n第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。\n{% asset_img '15-4.png' %}\n\n第二步，执行第17行代码时，调用fn()，产生fn()执行上下文环境，压栈，并设置为活动状态。\n{% asset_img '15-5.png' %}\n\n第三步，执行完第17行，fn()调用完成。按理说应该销毁掉fn()的执行上下文环境，但是这里不能这么做。注意，重点来了：因为执行fn()时，返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。而正巧合的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn()上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。\n\n因此，这里的fn()上下文环境不能被销毁，还依然存在与执行上下文栈中。\n\n——即，执行到第18行时，全局上下文环境将变为活动状态，但是fn()上下文环境依然会在执行上下文栈中。另外，执行完第18行，全局上下文环境中的max被赋值为100。如下图：\n{% asset_img '15-6.png' %}\n\n第四步，执行到第20行，执行f1(15)，即执行bar(15)，创建bar(15)上下文环境，并将其设置为活动状态。\n{% asset_img '15-7.png' %}\n\n执行bar(15)时，max是自由变量，需要向创建bar函数的作用域中查找，找到了max的值为10。这个过程在作用域链一节已经讲过。\n\n这里的重点就在于，创建bar函数是在执行fn()时创建的。fn()早就执行结束了，但是fn()执行上下文环境还存在与栈中，因此bar(15)时，max可以查找到。如果fn()上下文环境销毁了，那么max就找不到了。\n\n{% raw %}\n    <span style=\"background-color: #87daff;\">使用闭包会增加内容开销，现在很明显了吧</span>\n{% endraw %}！\n\n\n\n第五步，执行完20行就是上下文环境的销毁过程，这里就不再赘述了。\n\n\n\n闭包和作用域、上下文环境有着密不可分的关系，真的是“想说爱你不容易”！\n\n另外，闭包在jQuery中的应用非常多，在这里就不一一举例子了。所以，无论你是想了解一个经典的框架/类库，还是想自己开发一个插件或者类库，{% raw %}\n                                                                         <span style=\"background-color: #87daff;\">像闭包、原型这些基本的理论，是一定要知道的。否则，到时候出了BUG你都不知道为什么</span>\n                                                                     {% endraw %}，因为这些BUG可能完全在你的知识范围之外。\n\n\n\n到现在闭包就简单介绍完了。","source":"_posts/2017-04-17-深入理解javascript原型和闭包-15-闭包.md","raw":"---\ntitle: 深入理解javascript原型和闭包(15)--闭包\ncategories: 王福朋-深入理解javascript原型和闭包系列\ntags:\n  - javascript\n  - 原型链\n  - 闭包\ndate: 2017-04-17 01:14:08\n---\n{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/3994065.html 深入理解javascript原型和闭包（15）——闭包 %}\n{% endblockquote %}\n\n前面提到的上下文环境和作用域的知识，除了了解这些知识之外，还是理解闭包的基础。\n\n至于“闭包”这个词的概念的文字描述，确实不好解释，我看过很多遍，但是现在还是记不住。\n\n{% raw %}\n <span style=\"background-color: #87daff;\">但是你只需要知道应用的两种情况即可——函数作为返回值，函数作为参数传递</span>\n{% endraw %}。\n<!-- more -->\n\n###### 第一，函数作为返回值\n{% asset_img '15-1.png' %}\n如上代码，bar函数作为返回值，赋值给f1变量。执行f1(15)时，用到了fn作用域下的max变量的值。至于如何跨作用域取值，可以参考上一节。\n\n###### 第二，函数作为参数被传递\n{% asset_img '15-2.png' %}\n如上代码中，fn函数作为一个参数被传递进入另一个函数，赋值给f参数。执行f(15)时，max变量的取值是10，而不是100。\n\n\n\n上一节讲到自由变量跨作用域取值时，曾经强调过：{% raw %}\n                        <span style=\"background-color: #87daff;\">要去创建这个函数的作用域取值，而不是“父作用域”</span>\n                       {% endraw %}。理解了这一点，以上两端代码中，自由变量如何取值应该比较简单。（{% raw %}\n                                                                                           <span style=\"color: #ff0000;\">不明白的朋友一定要去上一节看看，这个很重要！</span>\n                                                                                          {% endraw %}）\n\n\n\n另外，讲到闭包，除了结合着作用域之外，还需要结合着执行上下文栈来说一下。\n\n在前面讲执行上下文栈时（{% post_link 深入理解javascript原型和闭包-11-执行上下文栈 深入理解javascript原型和闭包-11-执行上下文栈 %}），我们提到当一个函数被调用完成之后，其执行上下文环境将被销毁，其中的变量也会被同时销毁。\n\n但是在当时那篇文章中留了一个问号——有些情况下，函数调用完成之后，其执行上下文环境不会接着被销毁。这就是需要理解闭包的核心内容。\n\n咱们可以拿本文的第一段代码（稍作修改）来分析一下。\n{% asset_img '15-3.png' %}\n\n第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。\n{% asset_img '15-4.png' %}\n\n第二步，执行第17行代码时，调用fn()，产生fn()执行上下文环境，压栈，并设置为活动状态。\n{% asset_img '15-5.png' %}\n\n第三步，执行完第17行，fn()调用完成。按理说应该销毁掉fn()的执行上下文环境，但是这里不能这么做。注意，重点来了：因为执行fn()时，返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。而正巧合的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn()上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。\n\n因此，这里的fn()上下文环境不能被销毁，还依然存在与执行上下文栈中。\n\n——即，执行到第18行时，全局上下文环境将变为活动状态，但是fn()上下文环境依然会在执行上下文栈中。另外，执行完第18行，全局上下文环境中的max被赋值为100。如下图：\n{% asset_img '15-6.png' %}\n\n第四步，执行到第20行，执行f1(15)，即执行bar(15)，创建bar(15)上下文环境，并将其设置为活动状态。\n{% asset_img '15-7.png' %}\n\n执行bar(15)时，max是自由变量，需要向创建bar函数的作用域中查找，找到了max的值为10。这个过程在作用域链一节已经讲过。\n\n这里的重点就在于，创建bar函数是在执行fn()时创建的。fn()早就执行结束了，但是fn()执行上下文环境还存在与栈中，因此bar(15)时，max可以查找到。如果fn()上下文环境销毁了，那么max就找不到了。\n\n{% raw %}\n    <span style=\"background-color: #87daff;\">使用闭包会增加内容开销，现在很明显了吧</span>\n{% endraw %}！\n\n\n\n第五步，执行完20行就是上下文环境的销毁过程，这里就不再赘述了。\n\n\n\n闭包和作用域、上下文环境有着密不可分的关系，真的是“想说爱你不容易”！\n\n另外，闭包在jQuery中的应用非常多，在这里就不一一举例子了。所以，无论你是想了解一个经典的框架/类库，还是想自己开发一个插件或者类库，{% raw %}\n                                                                         <span style=\"background-color: #87daff;\">像闭包、原型这些基本的理论，是一定要知道的。否则，到时候出了BUG你都不知道为什么</span>\n                                                                     {% endraw %}，因为这些BUG可能完全在你的知识范围之外。\n\n\n\n到现在闭包就简单介绍完了。","slug":"深入理解javascript原型和闭包-15-闭包","published":1,"updated":"2017-04-16T17:42:08.125Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1lk6ecy0016youaeg70g0cq","content":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3994065.html\" target=\"_blank\" rel=\"external\">深入理解javascript原型和闭包（15）——闭包</a></cite></footer></blockquote>\n<p>前面提到的上下文环境和作用域的知识，除了了解这些知识之外，还是理解闭包的基础。</p>\n<p>至于“闭包”这个词的概念的文字描述，确实不好解释，我看过很多遍，但是现在还是记不住。</p>\n\n <span style=\"background-color: #87daff;\">但是你只需要知道应用的两种情况即可——函数作为返回值，函数作为参数传递</span>\n。<br><a id=\"more\"></a>\n<h6 id=\"第一，函数作为返回值\"><a href=\"#第一，函数作为返回值\" class=\"headerlink\" title=\"第一，函数作为返回值\"></a>第一，函数作为返回值</h6><img src=\"/2017/04/17/深入理解javascript原型和闭包-15-闭包/15-1.png\" alt=\"15-1.png\" title=\"\">\n<p>如上代码，bar函数作为返回值，赋值给f1变量。执行f1(15)时，用到了fn作用域下的max变量的值。至于如何跨作用域取值，可以参考上一节。</p>\n<h6 id=\"第二，函数作为参数被传递\"><a href=\"#第二，函数作为参数被传递\" class=\"headerlink\" title=\"第二，函数作为参数被传递\"></a>第二，函数作为参数被传递</h6><img src=\"/2017/04/17/深入理解javascript原型和闭包-15-闭包/15-2.png\" alt=\"15-2.png\" title=\"\">\n<p>如上代码中，fn函数作为一个参数被传递进入另一个函数，赋值给f参数。执行f(15)时，max变量的取值是10，而不是100。</p>\n<p>上一节讲到自由变量跨作用域取值时，曾经强调过：\n                        <span style=\"background-color: #87daff;\">要去创建这个函数的作用域取值，而不是“父作用域”</span>\n                       。理解了这一点，以上两端代码中，自由变量如何取值应该比较简单。（\n                                                                                           <span style=\"color: #ff0000;\">不明白的朋友一定要去上一节看看，这个很重要！</span>\n                                                                                          ）</p>\n<p>另外，讲到闭包，除了结合着作用域之外，还需要结合着执行上下文栈来说一下。</p>\n<p>在前面讲执行上下文栈时（<a href=\"/2017/04/17/深入理解javascript原型和闭包-11-执行上下文栈/\" title=\"深入理解javascript原型和闭包-11-执行上下文栈\">深入理解javascript原型和闭包-11-执行上下文栈</a>），我们提到当一个函数被调用完成之后，其执行上下文环境将被销毁，其中的变量也会被同时销毁。</p>\n<p>但是在当时那篇文章中留了一个问号——有些情况下，函数调用完成之后，其执行上下文环境不会接着被销毁。这就是需要理解闭包的核心内容。</p>\n<p>咱们可以拿本文的第一段代码（稍作修改）来分析一下。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-15-闭包/15-3.png\" alt=\"15-3.png\" title=\"\"></p>\n<p>第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-15-闭包/15-4.png\" alt=\"15-4.png\" title=\"\"></p>\n<p>第二步，执行第17行代码时，调用fn()，产生fn()执行上下文环境，压栈，并设置为活动状态。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-15-闭包/15-5.png\" alt=\"15-5.png\" title=\"\"></p>\n<p>第三步，执行完第17行，fn()调用完成。按理说应该销毁掉fn()的执行上下文环境，但是这里不能这么做。注意，重点来了：因为执行fn()时，返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。而正巧合的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn()上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。</p>\n<p>因此，这里的fn()上下文环境不能被销毁，还依然存在与执行上下文栈中。</p>\n<p>——即，执行到第18行时，全局上下文环境将变为活动状态，但是fn()上下文环境依然会在执行上下文栈中。另外，执行完第18行，全局上下文环境中的max被赋值为100。如下图：<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-15-闭包/15-6.png\" alt=\"15-6.png\" title=\"\"></p>\n<p>第四步，执行到第20行，执行f1(15)，即执行bar(15)，创建bar(15)上下文环境，并将其设置为活动状态。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-15-闭包/15-7.png\" alt=\"15-7.png\" title=\"\"></p>\n<p>执行bar(15)时，max是自由变量，需要向创建bar函数的作用域中查找，找到了max的值为10。这个过程在作用域链一节已经讲过。</p>\n<p>这里的重点就在于，创建bar函数是在执行fn()时创建的。fn()早就执行结束了，但是fn()执行上下文环境还存在与栈中，因此bar(15)时，max可以查找到。如果fn()上下文环境销毁了，那么max就找不到了。</p>\n<p>\n    <span style=\"background-color: #87daff;\">使用闭包会增加内容开销，现在很明显了吧</span>\n！</p>\n<p>第五步，执行完20行就是上下文环境的销毁过程，这里就不再赘述了。</p>\n<p>闭包和作用域、上下文环境有着密不可分的关系，真的是“想说爱你不容易”！</p>\n<p>另外，闭包在jQuery中的应用非常多，在这里就不一一举例子了。所以，无论你是想了解一个经典的框架/类库，还是想自己开发一个插件或者类库，\n                                                                         <span style=\"background-color: #87daff;\">像闭包、原型这些基本的理论，是一定要知道的。否则，到时候出了BUG你都不知道为什么</span>\n                                                                     ，因为这些BUG可能完全在你的知识范围之外。</p>\n<p>到现在闭包就简单介绍完了。</p>\n","site":{"data":{}},"excerpt":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/3994065.html\">深入理解javascript原型和闭包（15）——闭包</a></cite></footer></blockquote>\n<p>前面提到的上下文环境和作用域的知识，除了了解这些知识之外，还是理解闭包的基础。</p>\n<p>至于“闭包”这个词的概念的文字描述，确实不好解释，我看过很多遍，但是现在还是记不住。</p>\n\n <span style=\"background-color: #87daff;\">但是你只需要知道应用的两种情况即可——函数作为返回值，函数作为参数传递</span>\n。<br>","more":"<h6 id=\"第一，函数作为返回值\"><a href=\"#第一，函数作为返回值\" class=\"headerlink\" title=\"第一，函数作为返回值\"></a>第一，函数作为返回值</h6><img src=\"/2017/04/17/深入理解javascript原型和闭包-15-闭包/15-1.png\" alt=\"15-1.png\" title=\"\">\n<p>如上代码，bar函数作为返回值，赋值给f1变量。执行f1(15)时，用到了fn作用域下的max变量的值。至于如何跨作用域取值，可以参考上一节。</p>\n<h6 id=\"第二，函数作为参数被传递\"><a href=\"#第二，函数作为参数被传递\" class=\"headerlink\" title=\"第二，函数作为参数被传递\"></a>第二，函数作为参数被传递</h6><img src=\"/2017/04/17/深入理解javascript原型和闭包-15-闭包/15-2.png\" alt=\"15-2.png\" title=\"\">\n<p>如上代码中，fn函数作为一个参数被传递进入另一个函数，赋值给f参数。执行f(15)时，max变量的取值是10，而不是100。</p>\n<p>上一节讲到自由变量跨作用域取值时，曾经强调过：\n                        <span style=\"background-color: #87daff;\">要去创建这个函数的作用域取值，而不是“父作用域”</span>\n                       。理解了这一点，以上两端代码中，自由变量如何取值应该比较简单。（\n                                                                                           <span style=\"color: #ff0000;\">不明白的朋友一定要去上一节看看，这个很重要！</span>\n                                                                                          ）</p>\n<p>另外，讲到闭包，除了结合着作用域之外，还需要结合着执行上下文栈来说一下。</p>\n<p>在前面讲执行上下文栈时（<a href=\"/2017/04/17/深入理解javascript原型和闭包-11-执行上下文栈/\" title=\"深入理解javascript原型和闭包-11-执行上下文栈\">深入理解javascript原型和闭包-11-执行上下文栈</a>），我们提到当一个函数被调用完成之后，其执行上下文环境将被销毁，其中的变量也会被同时销毁。</p>\n<p>但是在当时那篇文章中留了一个问号——有些情况下，函数调用完成之后，其执行上下文环境不会接着被销毁。这就是需要理解闭包的核心内容。</p>\n<p>咱们可以拿本文的第一段代码（稍作修改）来分析一下。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-15-闭包/15-3.png\" alt=\"15-3.png\" title=\"\"></p>\n<p>第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-15-闭包/15-4.png\" alt=\"15-4.png\" title=\"\"></p>\n<p>第二步，执行第17行代码时，调用fn()，产生fn()执行上下文环境，压栈，并设置为活动状态。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-15-闭包/15-5.png\" alt=\"15-5.png\" title=\"\"></p>\n<p>第三步，执行完第17行，fn()调用完成。按理说应该销毁掉fn()的执行上下文环境，但是这里不能这么做。注意，重点来了：因为执行fn()时，返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。而正巧合的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn()上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。</p>\n<p>因此，这里的fn()上下文环境不能被销毁，还依然存在与执行上下文栈中。</p>\n<p>——即，执行到第18行时，全局上下文环境将变为活动状态，但是fn()上下文环境依然会在执行上下文栈中。另外，执行完第18行，全局上下文环境中的max被赋值为100。如下图：<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-15-闭包/15-6.png\" alt=\"15-6.png\" title=\"\"></p>\n<p>第四步，执行到第20行，执行f1(15)，即执行bar(15)，创建bar(15)上下文环境，并将其设置为活动状态。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-15-闭包/15-7.png\" alt=\"15-7.png\" title=\"\"></p>\n<p>执行bar(15)时，max是自由变量，需要向创建bar函数的作用域中查找，找到了max的值为10。这个过程在作用域链一节已经讲过。</p>\n<p>这里的重点就在于，创建bar函数是在执行fn()时创建的。fn()早就执行结束了，但是fn()执行上下文环境还存在与栈中，因此bar(15)时，max可以查找到。如果fn()上下文环境销毁了，那么max就找不到了。</p>\n<p>\n    <span style=\"background-color: #87daff;\">使用闭包会增加内容开销，现在很明显了吧</span>\n！</p>\n<p>第五步，执行完20行就是上下文环境的销毁过程，这里就不再赘述了。</p>\n<p>闭包和作用域、上下文环境有着密不可分的关系，真的是“想说爱你不容易”！</p>\n<p>另外，闭包在jQuery中的应用非常多，在这里就不一一举例子了。所以，无论你是想了解一个经典的框架/类库，还是想自己开发一个插件或者类库，\n                                                                         <span style=\"background-color: #87daff;\">像闭包、原型这些基本的理论，是一定要知道的。否则，到时候出了BUG你都不知道为什么</span>\n                                                                     ，因为这些BUG可能完全在你的知识范围之外。</p>\n<p>到现在闭包就简单介绍完了。</p>"},{"title":"深入理解javascript原型和闭包(16)--补充：上下文环境和作用域的关系","date":"2017-04-16T17:28:52.000Z","_content":"{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/4000798.html 深入理解javascript原型和闭包（16）——补充：上下文环境和作用域的关系 %}\n{% endblockquote %}\n\n本系列用了大量的篇幅讲解了上下文环境和作用域，有些人反映这两个是一回儿事。本文就用一个小例子来说明一下，作用域和上下文环境绝对不是一回事儿。\n\n\n\n再说明之前，咱们先用简单的语言来概括一下这两个的区别。\n<!-- more -->\n\n###### 00 上下文环境：\n可以理解为一个看不见摸不着的对象（有若干个属性），虽然看不见摸不着，但确实实实在在存在的，因为所有的变量都在里面存储着，要不然咱们定义的变量在哪里存？\n\n另外，对于函数来说，上下文环境是在调用时创建的，这个很好理解。拿参数做例子，你不调用函数，我哪儿知道你要给我传什么参数？\n\n###### 01 作用域：\n首先，它很抽象。第二，记住一句话：除了全局作用域，只有函数才能创建作用域。创建一个函数就创建了一个作用域，无论你调用不调用，函数只要创建了，它就有独立的作用域，就有自己的一个“地盘”。\n\n###### 02 两者：\n一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。\n\n\n\n上面的文字不理解没关系，且看下面的例子。\n\n第一，除了全局作用域外，每个函数都要创建一个作用域。作用域之间的变量是相互独立的。因此，全局作用域中的x和fn作用域中的x，两者毫无关系，互不影响，和平相处。\n{% asset_img '16-1.png' %}\n\n第二，程序执行之前，会生成全局上下文环境，并在程序执行时，对其中的变量赋值。\n{% asset_img '16-2.png' %}\n\n第三，程序执行到第17行，调用fn(5)，会产生fn(5)的上下文环境，并压栈，并设置为活动状态。\n{% asset_img '16-3.png' %}\n\n第四，执行完第17行，fn(5)的返回值赋值给了f1。此时执行上下文环境又重新回到全局，但是fn(5)的上下文环境不能就此销毁，因为其中有闭包的引用（可翻看前面文章，此处不再赘述）。\n{% asset_img '16-4.png' %}\n\n第五，继续执行第18行，再次调用fn函数——fn(10)。产生fn(5)的上下文环境，并压栈，并设置为活动状态。{% raw %}\n                                                         <span style=\"background-color: #87daff;\">但是此时fn(5)的上下文环境还在内存中——一个作用域下同时存在两个上下文环境</span>\n                                                        {% endraw %}。\n{% asset_img '16-5.png' %}\n\n讲到这里，重点已经讲出来了，之后的场景这里就不再赘述了。\n\n目的还是希望大家能通过这个例子，来理清楚上下文环境和作用域的关系。当然，也不是非得像个学院派似的一字一文的把概念说出来，简单理解一下，对用闭包是有帮助的。","source":"_posts/2017-04-17-深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系.md","raw":"---\ntitle: 深入理解javascript原型和闭包(16)--补充：上下文环境和作用域的关系\ncategories: 王福朋-深入理解javascript原型和闭包系列\ntags:\n  - javascript\n  - 原型链\n  - 闭包\ndate: 2017-04-17 01:28:52\n---\n{% blockquote 原文地址 http://www.cnblogs.com/wangfupeng1988/p/4000798.html 深入理解javascript原型和闭包（16）——补充：上下文环境和作用域的关系 %}\n{% endblockquote %}\n\n本系列用了大量的篇幅讲解了上下文环境和作用域，有些人反映这两个是一回儿事。本文就用一个小例子来说明一下，作用域和上下文环境绝对不是一回事儿。\n\n\n\n再说明之前，咱们先用简单的语言来概括一下这两个的区别。\n<!-- more -->\n\n###### 00 上下文环境：\n可以理解为一个看不见摸不着的对象（有若干个属性），虽然看不见摸不着，但确实实实在在存在的，因为所有的变量都在里面存储着，要不然咱们定义的变量在哪里存？\n\n另外，对于函数来说，上下文环境是在调用时创建的，这个很好理解。拿参数做例子，你不调用函数，我哪儿知道你要给我传什么参数？\n\n###### 01 作用域：\n首先，它很抽象。第二，记住一句话：除了全局作用域，只有函数才能创建作用域。创建一个函数就创建了一个作用域，无论你调用不调用，函数只要创建了，它就有独立的作用域，就有自己的一个“地盘”。\n\n###### 02 两者：\n一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。\n\n\n\n上面的文字不理解没关系，且看下面的例子。\n\n第一，除了全局作用域外，每个函数都要创建一个作用域。作用域之间的变量是相互独立的。因此，全局作用域中的x和fn作用域中的x，两者毫无关系，互不影响，和平相处。\n{% asset_img '16-1.png' %}\n\n第二，程序执行之前，会生成全局上下文环境，并在程序执行时，对其中的变量赋值。\n{% asset_img '16-2.png' %}\n\n第三，程序执行到第17行，调用fn(5)，会产生fn(5)的上下文环境，并压栈，并设置为活动状态。\n{% asset_img '16-3.png' %}\n\n第四，执行完第17行，fn(5)的返回值赋值给了f1。此时执行上下文环境又重新回到全局，但是fn(5)的上下文环境不能就此销毁，因为其中有闭包的引用（可翻看前面文章，此处不再赘述）。\n{% asset_img '16-4.png' %}\n\n第五，继续执行第18行，再次调用fn函数——fn(10)。产生fn(5)的上下文环境，并压栈，并设置为活动状态。{% raw %}\n                                                         <span style=\"background-color: #87daff;\">但是此时fn(5)的上下文环境还在内存中——一个作用域下同时存在两个上下文环境</span>\n                                                        {% endraw %}。\n{% asset_img '16-5.png' %}\n\n讲到这里，重点已经讲出来了，之后的场景这里就不再赘述了。\n\n目的还是希望大家能通过这个例子，来理清楚上下文环境和作用域的关系。当然，也不是非得像个学院派似的一字一文的把概念说出来，简单理解一下，对用闭包是有帮助的。","slug":"深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系","published":1,"updated":"2017-04-16T17:42:24.144Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1lk6ed5001ayoua9z1d5yre","content":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/4000798.html\" target=\"_blank\" rel=\"external\">深入理解javascript原型和闭包（16）——补充：上下文环境和作用域的关系</a></cite></footer></blockquote>\n<p>本系列用了大量的篇幅讲解了上下文环境和作用域，有些人反映这两个是一回儿事。本文就用一个小例子来说明一下，作用域和上下文环境绝对不是一回事儿。</p>\n<p>再说明之前，咱们先用简单的语言来概括一下这两个的区别。<br><a id=\"more\"></a></p>\n<h6 id=\"00-上下文环境：\"><a href=\"#00-上下文环境：\" class=\"headerlink\" title=\"00 上下文环境：\"></a>00 上下文环境：</h6><p>可以理解为一个看不见摸不着的对象（有若干个属性），虽然看不见摸不着，但确实实实在在存在的，因为所有的变量都在里面存储着，要不然咱们定义的变量在哪里存？</p>\n<p>另外，对于函数来说，上下文环境是在调用时创建的，这个很好理解。拿参数做例子，你不调用函数，我哪儿知道你要给我传什么参数？</p>\n<h6 id=\"01-作用域：\"><a href=\"#01-作用域：\" class=\"headerlink\" title=\"01 作用域：\"></a>01 作用域：</h6><p>首先，它很抽象。第二，记住一句话：除了全局作用域，只有函数才能创建作用域。创建一个函数就创建了一个作用域，无论你调用不调用，函数只要创建了，它就有独立的作用域，就有自己的一个“地盘”。</p>\n<h6 id=\"02-两者：\"><a href=\"#02-两者：\" class=\"headerlink\" title=\"02 两者：\"></a>02 两者：</h6><p>一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。</p>\n<p>上面的文字不理解没关系，且看下面的例子。</p>\n<p>第一，除了全局作用域外，每个函数都要创建一个作用域。作用域之间的变量是相互独立的。因此，全局作用域中的x和fn作用域中的x，两者毫无关系，互不影响，和平相处。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系/16-1.png\" alt=\"16-1.png\" title=\"\"></p>\n<p>第二，程序执行之前，会生成全局上下文环境，并在程序执行时，对其中的变量赋值。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系/16-2.png\" alt=\"16-2.png\" title=\"\"></p>\n<p>第三，程序执行到第17行，调用fn(5)，会产生fn(5)的上下文环境，并压栈，并设置为活动状态。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系/16-3.png\" alt=\"16-3.png\" title=\"\"></p>\n<p>第四，执行完第17行，fn(5)的返回值赋值给了f1。此时执行上下文环境又重新回到全局，但是fn(5)的上下文环境不能就此销毁，因为其中有闭包的引用（可翻看前面文章，此处不再赘述）。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系/16-4.png\" alt=\"16-4.png\" title=\"\"></p>\n<p>第五，继续执行第18行，再次调用fn函数——fn(10)。产生fn(5)的上下文环境，并压栈，并设置为活动状态。\n                                                         <span style=\"background-color: #87daff;\">但是此时fn(5)的上下文环境还在内存中——一个作用域下同时存在两个上下文环境</span>\n                                                        。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系/16-5.png\" alt=\"16-5.png\" title=\"\"></p>\n<p>讲到这里，重点已经讲出来了，之后的场景这里就不再赘述了。</p>\n<p>目的还是希望大家能通过这个例子，来理清楚上下文环境和作用域的关系。当然，也不是非得像个学院派似的一字一文的把概念说出来，简单理解一下，对用闭包是有帮助的。</p>\n","site":{"data":{}},"excerpt":"<blockquote><footer><strong>原文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/4000798.html\">深入理解javascript原型和闭包（16）——补充：上下文环境和作用域的关系</a></cite></footer></blockquote>\n<p>本系列用了大量的篇幅讲解了上下文环境和作用域，有些人反映这两个是一回儿事。本文就用一个小例子来说明一下，作用域和上下文环境绝对不是一回事儿。</p>\n<p>再说明之前，咱们先用简单的语言来概括一下这两个的区别。<br>","more":"</p>\n<h6 id=\"00-上下文环境：\"><a href=\"#00-上下文环境：\" class=\"headerlink\" title=\"00 上下文环境：\"></a>00 上下文环境：</h6><p>可以理解为一个看不见摸不着的对象（有若干个属性），虽然看不见摸不着，但确实实实在在存在的，因为所有的变量都在里面存储着，要不然咱们定义的变量在哪里存？</p>\n<p>另外，对于函数来说，上下文环境是在调用时创建的，这个很好理解。拿参数做例子，你不调用函数，我哪儿知道你要给我传什么参数？</p>\n<h6 id=\"01-作用域：\"><a href=\"#01-作用域：\" class=\"headerlink\" title=\"01 作用域：\"></a>01 作用域：</h6><p>首先，它很抽象。第二，记住一句话：除了全局作用域，只有函数才能创建作用域。创建一个函数就创建了一个作用域，无论你调用不调用，函数只要创建了，它就有独立的作用域，就有自己的一个“地盘”。</p>\n<h6 id=\"02-两者：\"><a href=\"#02-两者：\" class=\"headerlink\" title=\"02 两者：\"></a>02 两者：</h6><p>一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。</p>\n<p>上面的文字不理解没关系，且看下面的例子。</p>\n<p>第一，除了全局作用域外，每个函数都要创建一个作用域。作用域之间的变量是相互独立的。因此，全局作用域中的x和fn作用域中的x，两者毫无关系，互不影响，和平相处。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系/16-1.png\" alt=\"16-1.png\" title=\"\"></p>\n<p>第二，程序执行之前，会生成全局上下文环境，并在程序执行时，对其中的变量赋值。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系/16-2.png\" alt=\"16-2.png\" title=\"\"></p>\n<p>第三，程序执行到第17行，调用fn(5)，会产生fn(5)的上下文环境，并压栈，并设置为活动状态。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系/16-3.png\" alt=\"16-3.png\" title=\"\"></p>\n<p>第四，执行完第17行，fn(5)的返回值赋值给了f1。此时执行上下文环境又重新回到全局，但是fn(5)的上下文环境不能就此销毁，因为其中有闭包的引用（可翻看前面文章，此处不再赘述）。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系/16-4.png\" alt=\"16-4.png\" title=\"\"></p>\n<p>第五，继续执行第18行，再次调用fn函数——fn(10)。产生fn(5)的上下文环境，并压栈，并设置为活动状态。\n                                                         <span style=\"background-color: #87daff;\">但是此时fn(5)的上下文环境还在内存中——一个作用域下同时存在两个上下文环境</span>\n                                                        。<br><img src=\"/2017/04/17/深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系/16-5.png\" alt=\"16-5.png\" title=\"\"></p>\n<p>讲到这里，重点已经讲出来了，之后的场景这里就不再赘述了。</p>\n<p>目的还是希望大家能通过这个例子，来理清楚上下文环境和作用域的关系。当然，也不是非得像个学院派似的一字一文的把概念说出来，简单理解一下，对用闭包是有帮助的。</p>"},{"title":"深入理解javascript原型和闭包引言和目录","date":"2017-04-17T03:24:48.000Z","_content":"\n花了一整夜的时间去整（chao）理（xi）王福朋的原型和闭包系列，原因是因为\n* 第一：我觉得这应该是我目前看过的最全最好的一个系列了\n* 第二：在之后有时间我希望在原有的基础上可以添加一些自己的注解，方便自己以后翻阅能更快理解\n* 第三：第一次用hexo写文章，总得找点好的东西来写一写吧\n\n好了，基于以上的几个原因，我从王福朋的博客中搬运了他的JavaScript原型与闭包系列博文（如有侵犯，我也不管，哈哈哈）\n\n这里写的文章和原作者的一模一样，就算是原文拷贝，也花了我几个小时的时间，可以看出原作者在写博客的时候是付出了多大的辛劳（在这里感谢之）\n\n如果大家是想了解JavaScript原型和闭包内容，推荐大家到王福朋的博客中去查看\n{% blockquote 博文地址 http://www.cnblogs.com/wangfupeng1988/p/4001284.html 深入理解javascript原型和闭包系列 %}\n{% endblockquote %}\n<!-- more -->\n\n下面是在本站中的目录：\n{% post_link 深入理解javascript原型和闭包-1-一切都是对象 理解javascript原型和作用域系列（1）——一切都是对象 %}\n{% post_link 深入理解javascript原型和闭包-2-函数和对象的关系 深入理解javascript原型和闭包-2-函数和对象的关系 %}\n{% post_link 深入理解javascript原型和闭包-3-prototype原型 深入理解javascript原型和闭包-3-prototype原型 %}\n{% post_link 深入理解javascript原型和闭包-4-隐式原型 深入理解javascript原型和闭包-4-隐式原型 %}\n{% post_link 深入理解javascript原型和闭包-5-instanceof 深入理解javascript原型和闭包-5-instanceof %}\n{% post_link 深入理解javascript原型和闭包-6-继承 深入理解javascript原型和闭包-6-继承 %}\n{% post_link 深入理解javascript原型和闭包-7-原型的灵活性 深入理解javascript原型和闭包-7-原型的灵活性 %}\n{% post_link 深入理解javascript原型和闭包-8-简述【执行上下文】上 深入理解javascript原型和闭包-8-简述【执行上下文】上 %}\n{% post_link 深入理解javascript原型和闭包-9-简述【执行上下文】下 深入理解javascript原型和闭包-9-简述【执行上下文】下 %}\n{% post_link 深入理解javascript原型和闭包-10-this 深入理解javascript原型和闭包-10-this %}\n{% post_link 深入理解javascript原型和闭包-11-执行上下文栈 深入理解javascript原型和闭包-11-执行上下文栈 %}\n{% post_link 深入理解javascript原型和闭包-12-简介【作用域】 深入理解javascript原型和闭包-12-简介【作用域】 %}\n{% post_link 深入理解javascript原型和闭包-13-【作用域】和【上下文环境】 深入理解javascript原型和闭包-13-【作用域】和【上下文环境】 %}\n{% post_link 深入理解javascript原型和闭包-14-从【自由变量】和【作用域链】 深入理解javascript原型和闭包-14-从【自由变量】和【作用域链】 %}\n{% post_link 深入理解javascript原型和闭包-15-闭包 深入理解javascript原型和闭包-15-闭包 %}\n{% post_link 深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系 深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系 %}\n\n在此再次感谢原作者的辛劳，感谢他的热情分享，让我对JavaScript又有了进一步的理解\n","source":"_posts/2017-04-17-深入理解javascript原型和闭包引言和目录.md","raw":"---\ntitle: 深入理解javascript原型和闭包引言和目录\ncategories: 王福朋-深入理解javascript原型和闭包系列\ntags:\n  - javascript\n  - 原型链\n  - 闭包\ndate: 2017-04-17 11:24:48\n---\n\n花了一整夜的时间去整（chao）理（xi）王福朋的原型和闭包系列，原因是因为\n* 第一：我觉得这应该是我目前看过的最全最好的一个系列了\n* 第二：在之后有时间我希望在原有的基础上可以添加一些自己的注解，方便自己以后翻阅能更快理解\n* 第三：第一次用hexo写文章，总得找点好的东西来写一写吧\n\n好了，基于以上的几个原因，我从王福朋的博客中搬运了他的JavaScript原型与闭包系列博文（如有侵犯，我也不管，哈哈哈）\n\n这里写的文章和原作者的一模一样，就算是原文拷贝，也花了我几个小时的时间，可以看出原作者在写博客的时候是付出了多大的辛劳（在这里感谢之）\n\n如果大家是想了解JavaScript原型和闭包内容，推荐大家到王福朋的博客中去查看\n{% blockquote 博文地址 http://www.cnblogs.com/wangfupeng1988/p/4001284.html 深入理解javascript原型和闭包系列 %}\n{% endblockquote %}\n<!-- more -->\n\n下面是在本站中的目录：\n{% post_link 深入理解javascript原型和闭包-1-一切都是对象 理解javascript原型和作用域系列（1）——一切都是对象 %}\n{% post_link 深入理解javascript原型和闭包-2-函数和对象的关系 深入理解javascript原型和闭包-2-函数和对象的关系 %}\n{% post_link 深入理解javascript原型和闭包-3-prototype原型 深入理解javascript原型和闭包-3-prototype原型 %}\n{% post_link 深入理解javascript原型和闭包-4-隐式原型 深入理解javascript原型和闭包-4-隐式原型 %}\n{% post_link 深入理解javascript原型和闭包-5-instanceof 深入理解javascript原型和闭包-5-instanceof %}\n{% post_link 深入理解javascript原型和闭包-6-继承 深入理解javascript原型和闭包-6-继承 %}\n{% post_link 深入理解javascript原型和闭包-7-原型的灵活性 深入理解javascript原型和闭包-7-原型的灵活性 %}\n{% post_link 深入理解javascript原型和闭包-8-简述【执行上下文】上 深入理解javascript原型和闭包-8-简述【执行上下文】上 %}\n{% post_link 深入理解javascript原型和闭包-9-简述【执行上下文】下 深入理解javascript原型和闭包-9-简述【执行上下文】下 %}\n{% post_link 深入理解javascript原型和闭包-10-this 深入理解javascript原型和闭包-10-this %}\n{% post_link 深入理解javascript原型和闭包-11-执行上下文栈 深入理解javascript原型和闭包-11-执行上下文栈 %}\n{% post_link 深入理解javascript原型和闭包-12-简介【作用域】 深入理解javascript原型和闭包-12-简介【作用域】 %}\n{% post_link 深入理解javascript原型和闭包-13-【作用域】和【上下文环境】 深入理解javascript原型和闭包-13-【作用域】和【上下文环境】 %}\n{% post_link 深入理解javascript原型和闭包-14-从【自由变量】和【作用域链】 深入理解javascript原型和闭包-14-从【自由变量】和【作用域链】 %}\n{% post_link 深入理解javascript原型和闭包-15-闭包 深入理解javascript原型和闭包-15-闭包 %}\n{% post_link 深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系 深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系 %}\n\n在此再次感谢原作者的辛劳，感谢他的热情分享，让我对JavaScript又有了进一步的理解\n","slug":"深入理解javascript原型和闭包引言和目录","published":1,"updated":"2017-04-17T03:50:37.758Z","_id":"cj1lk6edg001dyoua04q9gm6o","comments":1,"layout":"post","photos":[],"link":"","content":"<p>花了一整夜的时间去整（chao）理（xi）王福朋的原型和闭包系列，原因是因为</p>\n<ul>\n<li>第一：我觉得这应该是我目前看过的最全最好的一个系列了</li>\n<li>第二：在之后有时间我希望在原有的基础上可以添加一些自己的注解，方便自己以后翻阅能更快理解</li>\n<li>第三：第一次用hexo写文章，总得找点好的东西来写一写吧</li>\n</ul>\n<p>好了，基于以上的几个原因，我从王福朋的博客中搬运了他的JavaScript原型与闭包系列博文（如有侵犯，我也不管，哈哈哈）</p>\n<p>这里写的文章和原作者的一模一样，就算是原文拷贝，也花了我几个小时的时间，可以看出原作者在写博客的时候是付出了多大的辛劳（在这里感谢之）</p>\n<p>如果大家是想了解JavaScript原型和闭包内容，推荐大家到王福朋的博客中去查看<br><blockquote><footer><strong>博文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/4001284.html\" target=\"_blank\" rel=\"external\">深入理解javascript原型和闭包系列</a></cite></footer></blockquote><br><a id=\"more\"></a></p>\n<p>下面是在本站中的目录：<br><a href=\"/2017/04/16/深入理解javascript原型和闭包-1-一切都是对象/\" title=\"理解javascript原型和作用域系列（1）——一切都是对象\">理解javascript原型和作用域系列（1）——一切都是对象</a><br><a href=\"/2017/04/16/深入理解javascript原型和闭包-2-函数和对象的关系/\" title=\"深入理解javascript原型和闭包-2-函数和对象的关系\">深入理解javascript原型和闭包-2-函数和对象的关系</a><br><a href=\"/2017/04/16/深入理解javascript原型和闭包-3-prototype原型/\" title=\"深入理解javascript原型和闭包-3-prototype原型\">深入理解javascript原型和闭包-3-prototype原型</a><br><a href=\"/2017/04/16/深入理解javascript原型和闭包-4-隐式原型/\" title=\"深入理解javascript原型和闭包-4-隐式原型\">深入理解javascript原型和闭包-4-隐式原型</a><br><a href=\"/2017/04/16/深入理解javascript原型和闭包-5-instanceof/\" title=\"深入理解javascript原型和闭包-5-instanceof\">深入理解javascript原型和闭包-5-instanceof</a><br><a href=\"/2017/04/16/深入理解javascript原型和闭包-6-继承/\" title=\"深入理解javascript原型和闭包-6-继承\">深入理解javascript原型和闭包-6-继承</a><br><a href=\"/2017/04/16/深入理解javascript原型和闭包-7-原型的灵活性/\" title=\"深入理解javascript原型和闭包-7-原型的灵活性\">深入理解javascript原型和闭包-7-原型的灵活性</a><br><a href=\"/2017/04/16/深入理解javascript原型和闭包-8-简述【执行上下文】上/\" title=\"深入理解javascript原型和闭包-8-简述【执行上下文】上\">深入理解javascript原型和闭包-8-简述【执行上下文】上</a><br><a href=\"/2017/04/16/深入理解javascript原型和闭包-9-简述【执行上下文】下/\" title=\"深入理解javascript原型和闭包-9-简述【执行上下文】下\">深入理解javascript原型和闭包-9-简述【执行上下文】下</a><br><a href=\"/2017/04/17/深入理解javascript原型和闭包-10-this/\" title=\"深入理解javascript原型和闭包-10-this\">深入理解javascript原型和闭包-10-this</a><br><a href=\"/2017/04/17/深入理解javascript原型和闭包-11-执行上下文栈/\" title=\"深入理解javascript原型和闭包-11-执行上下文栈\">深入理解javascript原型和闭包-11-执行上下文栈</a><br><a href=\"/2017/04/17/深入理解javascript原型和闭包-12-简介【作用域】/\" title=\"深入理解javascript原型和闭包-12-简介【作用域】\">深入理解javascript原型和闭包-12-简介【作用域】</a><br><a href=\"/2017/04/17/深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/\" title=\"深入理解javascript原型和闭包-13-【作用域】和【上下文环境】\">深入理解javascript原型和闭包-13-【作用域】和【上下文环境】</a><br><a href=\"/2017/04/17/深入理解javascript原型和闭包-14-从【自由变量】和【作用域链】/\" title=\"深入理解javascript原型和闭包-14-从【自由变量】和【作用域链】\">深入理解javascript原型和闭包-14-从【自由变量】和【作用域链】</a><br><a href=\"/2017/04/17/深入理解javascript原型和闭包-15-闭包/\" title=\"深入理解javascript原型和闭包-15-闭包\">深入理解javascript原型和闭包-15-闭包</a><br><a href=\"/2017/04/17/深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系/\" title=\"深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系\">深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系</a></p>\n<p>在此再次感谢原作者的辛劳，感谢他的热情分享，让我对JavaScript又有了进一步的理解</p>\n","site":{"data":{}},"excerpt":"<p>花了一整夜的时间去整（chao）理（xi）王福朋的原型和闭包系列，原因是因为</p>\n<ul>\n<li>第一：我觉得这应该是我目前看过的最全最好的一个系列了</li>\n<li>第二：在之后有时间我希望在原有的基础上可以添加一些自己的注解，方便自己以后翻阅能更快理解</li>\n<li>第三：第一次用hexo写文章，总得找点好的东西来写一写吧</li>\n</ul>\n<p>好了，基于以上的几个原因，我从王福朋的博客中搬运了他的JavaScript原型与闭包系列博文（如有侵犯，我也不管，哈哈哈）</p>\n<p>这里写的文章和原作者的一模一样，就算是原文拷贝，也花了我几个小时的时间，可以看出原作者在写博客的时候是付出了多大的辛劳（在这里感谢之）</p>\n<p>如果大家是想了解JavaScript原型和闭包内容，推荐大家到王福朋的博客中去查看<br><blockquote><footer><strong>博文地址</strong><cite><a href=\"http://www.cnblogs.com/wangfupeng1988/p/4001284.html\">深入理解javascript原型和闭包系列</a></cite></footer></blockquote><br>","more":"</p>\n<p>下面是在本站中的目录：<br><a href=\"/2017/04/16/深入理解javascript原型和闭包-1-一切都是对象/\" title=\"理解javascript原型和作用域系列（1）——一切都是对象\">理解javascript原型和作用域系列（1）——一切都是对象</a><br><a href=\"/2017/04/16/深入理解javascript原型和闭包-2-函数和对象的关系/\" title=\"深入理解javascript原型和闭包-2-函数和对象的关系\">深入理解javascript原型和闭包-2-函数和对象的关系</a><br><a href=\"/2017/04/16/深入理解javascript原型和闭包-3-prototype原型/\" title=\"深入理解javascript原型和闭包-3-prototype原型\">深入理解javascript原型和闭包-3-prototype原型</a><br><a href=\"/2017/04/16/深入理解javascript原型和闭包-4-隐式原型/\" title=\"深入理解javascript原型和闭包-4-隐式原型\">深入理解javascript原型和闭包-4-隐式原型</a><br><a href=\"/2017/04/16/深入理解javascript原型和闭包-5-instanceof/\" title=\"深入理解javascript原型和闭包-5-instanceof\">深入理解javascript原型和闭包-5-instanceof</a><br><a href=\"/2017/04/16/深入理解javascript原型和闭包-6-继承/\" title=\"深入理解javascript原型和闭包-6-继承\">深入理解javascript原型和闭包-6-继承</a><br><a href=\"/2017/04/16/深入理解javascript原型和闭包-7-原型的灵活性/\" title=\"深入理解javascript原型和闭包-7-原型的灵活性\">深入理解javascript原型和闭包-7-原型的灵活性</a><br><a href=\"/2017/04/16/深入理解javascript原型和闭包-8-简述【执行上下文】上/\" title=\"深入理解javascript原型和闭包-8-简述【执行上下文】上\">深入理解javascript原型和闭包-8-简述【执行上下文】上</a><br><a href=\"/2017/04/16/深入理解javascript原型和闭包-9-简述【执行上下文】下/\" title=\"深入理解javascript原型和闭包-9-简述【执行上下文】下\">深入理解javascript原型和闭包-9-简述【执行上下文】下</a><br><a href=\"/2017/04/17/深入理解javascript原型和闭包-10-this/\" title=\"深入理解javascript原型和闭包-10-this\">深入理解javascript原型和闭包-10-this</a><br><a href=\"/2017/04/17/深入理解javascript原型和闭包-11-执行上下文栈/\" title=\"深入理解javascript原型和闭包-11-执行上下文栈\">深入理解javascript原型和闭包-11-执行上下文栈</a><br><a href=\"/2017/04/17/深入理解javascript原型和闭包-12-简介【作用域】/\" title=\"深入理解javascript原型和闭包-12-简介【作用域】\">深入理解javascript原型和闭包-12-简介【作用域】</a><br><a href=\"/2017/04/17/深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/\" title=\"深入理解javascript原型和闭包-13-【作用域】和【上下文环境】\">深入理解javascript原型和闭包-13-【作用域】和【上下文环境】</a><br><a href=\"/2017/04/17/深入理解javascript原型和闭包-14-从【自由变量】和【作用域链】/\" title=\"深入理解javascript原型和闭包-14-从【自由变量】和【作用域链】\">深入理解javascript原型和闭包-14-从【自由变量】和【作用域链】</a><br><a href=\"/2017/04/17/深入理解javascript原型和闭包-15-闭包/\" title=\"深入理解javascript原型和闭包-15-闭包\">深入理解javascript原型和闭包-15-闭包</a><br><a href=\"/2017/04/17/深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系/\" title=\"深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系\">深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系</a></p>\n<p>在此再次感谢原作者的辛劳，感谢他的热情分享，让我对JavaScript又有了进一步的理解</p>"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ncategories: Hello World\ntags: \n    - Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2017-04-15T15:02:59.476Z","updated":"2017-04-16T07:19:52.668Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1lk6edo001hyouahspj0rk1","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n"}],"PostAsset":[{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-5-instanceof/5-2.png","slug":"5-2.png","post":"cj1lk6eak000ayouahdlqrw5i","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-1-一切都是对象/1-1.png","slug":"1-1.png","post":"cj1lk6e9g0002youanv8y5pql","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-5-instanceof/5-1.png","slug":"5-1.png","post":"cj1lk6eak000ayouahdlqrw5i","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-7-原型的灵活性/7-1.png","slug":"7-1.png","post":"cj1lk6eaz000fyoua1wo63mqw","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-7-原型的灵活性/7-2.png","slug":"7-2.png","post":"cj1lk6eaz000fyoua1wo63mqw","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-9-简述【执行上下文】下/9-1.png","slug":"9-1.png","post":"cj1lk6ebq000lyouazfpxlbmv","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-9-简述【执行上下文】下/9-2.png","slug":"9-2.png","post":"cj1lk6ebq000lyouazfpxlbmv","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-3-prototype原型/3-1.png","slug":"3-1.png","post":"cj1lk6ea30006youa91z70jag","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-3-prototype原型/3-2.png","slug":"3-2.png","post":"cj1lk6ea30006youa91z70jag","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-3-prototype原型/3-3.png","slug":"3-3.png","post":"cj1lk6ea30006youa91z70jag","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-12-简介【作用域】/12-1.png","slug":"12-1.png","post":"cj1lk6ec8000wyouauc1065wf","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-12-简介【作用域】/12-2.png","slug":"12-2.png","post":"cj1lk6ec8000wyouauc1065wf","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-12-简介【作用域】/12-3.png","slug":"12-3.png","post":"cj1lk6ec8000wyouauc1065wf","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-14-从【自由变量】和【作用域链】/14-1.png","slug":"14-1.png","post":"cj1lk6ecs0013youayswt32ib","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-14-从【自由变量】和【作用域链】/14-2.png","slug":"14-2.png","post":"cj1lk6ecs0013youayswt32ib","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-14-从【自由变量】和【作用域链】/14-3.png","slug":"14-3.png","post":"cj1lk6ecs0013youayswt32ib","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-6-继承/6-1.png","slug":"6-1.png","post":"cj1lk6ear000dyouanp1nuhby","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-6-继承/6-2.png","slug":"6-2.png","post":"cj1lk6ear000dyouanp1nuhby","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-6-继承/6-3.png","slug":"6-3.png","post":"cj1lk6ear000dyouanp1nuhby","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-6-继承/6-4.png","slug":"6-4.png","post":"cj1lk6ear000dyouanp1nuhby","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系/16-1.png","slug":"16-1.png","post":"cj1lk6ed5001ayoua9z1d5yre","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系/16-2.png","slug":"16-2.png","post":"cj1lk6ed5001ayoua9z1d5yre","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系/16-3.png","slug":"16-3.png","post":"cj1lk6ed5001ayoua9z1d5yre","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系/16-4.png","slug":"16-4.png","post":"cj1lk6ed5001ayoua9z1d5yre","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-16-补充：上下文环境和作用域的关系/16-5.png","slug":"16-5.png","post":"cj1lk6ed5001ayoua9z1d5yre","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-4-隐式原型/4-1.png","slug":"4-1.png","post":"cj1lk6eac0008youarpkwhfhh","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-4-隐式原型/4-2.png","slug":"4-2.png","post":"cj1lk6eac0008youarpkwhfhh","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-4-隐式原型/4-3.png","slug":"4-3.png","post":"cj1lk6eac0008youarpkwhfhh","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-4-隐式原型/4-4.png","slug":"4-4.png","post":"cj1lk6eac0008youarpkwhfhh","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-4-隐式原型/4-5.png","slug":"4-5.png","post":"cj1lk6eac0008youarpkwhfhh","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-4-隐式原型/4-6.png","slug":"4-6.png","post":"cj1lk6eac0008youarpkwhfhh","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-8-简述【执行上下文】上/8-1.png","slug":"8-1.png","post":"cj1lk6eb6000jyouaosyp2ywy","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-8-简述【执行上下文】上/8-2.png","slug":"8-2.png","post":"cj1lk6eb6000jyouaosyp2ywy","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-8-简述【执行上下文】上/8-3.png","slug":"8-3.png","post":"cj1lk6eb6000jyouaosyp2ywy","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-8-简述【执行上下文】上/8-4.png","slug":"8-4.png","post":"cj1lk6eb6000jyouaosyp2ywy","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-8-简述【执行上下文】上/8-5.png","slug":"8-5.png","post":"cj1lk6eb6000jyouaosyp2ywy","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-16-深入理解javascript原型和闭包-8-简述【执行上下文】上/8-6.png","slug":"8-6.png","post":"cj1lk6eb6000jyouaosyp2ywy","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-15-闭包/15-1.png","slug":"15-1.png","post":"cj1lk6ecy0016youaeg70g0cq","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-15-闭包/15-2.png","slug":"15-2.png","post":"cj1lk6ecy0016youaeg70g0cq","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-15-闭包/15-3.png","slug":"15-3.png","post":"cj1lk6ecy0016youaeg70g0cq","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-15-闭包/15-4.png","slug":"15-4.png","post":"cj1lk6ecy0016youaeg70g0cq","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-15-闭包/15-5.png","slug":"15-5.png","post":"cj1lk6ecy0016youaeg70g0cq","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-15-闭包/15-6.png","slug":"15-6.png","post":"cj1lk6ecy0016youaeg70g0cq","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-15-闭包/15-7.png","slug":"15-7.png","post":"cj1lk6ecy0016youaeg70g0cq","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-1.png","slug":"13-1.png","post":"cj1lk6ecf000zyouansemwoui","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-2.png","slug":"13-2.png","post":"cj1lk6ecf000zyouansemwoui","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-3.png","slug":"13-3.png","post":"cj1lk6ecf000zyouansemwoui","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-4.png","slug":"13-4.png","post":"cj1lk6ecf000zyouansemwoui","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-5.png","slug":"13-5.png","post":"cj1lk6ecf000zyouansemwoui","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-6.png","slug":"13-6.png","post":"cj1lk6ecf000zyouansemwoui","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-7.png","slug":"13-7.png","post":"cj1lk6ecf000zyouansemwoui","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-13-【作用域】和【上下文环境】/13-8.png","slug":"13-8.png","post":"cj1lk6ecf000zyouansemwoui","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-10-this/10-1.png","slug":"10-1.png","post":"cj1lk6ebz000pyoua46g2hjbk","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-10-this/10-2.png","slug":"10-2.png","post":"cj1lk6ebz000pyoua46g2hjbk","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-10-this/10-3.png","slug":"10-3.png","post":"cj1lk6ebz000pyoua46g2hjbk","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-10-this/10-4.png","slug":"10-4.png","post":"cj1lk6ebz000pyoua46g2hjbk","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-10-this/10-5.png","slug":"10-5.png","post":"cj1lk6ebz000pyoua46g2hjbk","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-10-this/10-6.png","slug":"10-6.png","post":"cj1lk6ebz000pyoua46g2hjbk","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-10-this/10-7.png","slug":"10-7.png","post":"cj1lk6ebz000pyoua46g2hjbk","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-10-this/10-8.png","slug":"10-8.png","post":"cj1lk6ebz000pyoua46g2hjbk","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-10-this/10-9.png","slug":"10-9.png","post":"cj1lk6ebz000pyoua46g2hjbk","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-11-执行上下文栈/11-1.png","slug":"11-1.png","post":"cj1lk6ec3000syouafgunqzqu","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-11-执行上下文栈/11-2.png","slug":"11-2.png","post":"cj1lk6ec3000syouafgunqzqu","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-11-执行上下文栈/11-3.png","slug":"11-3.png","post":"cj1lk6ec3000syouafgunqzqu","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-11-执行上下文栈/11-4.png","slug":"11-4.png","post":"cj1lk6ec3000syouafgunqzqu","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-11-执行上下文栈/11-5.png","slug":"11-5.png","post":"cj1lk6ec3000syouafgunqzqu","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-11-执行上下文栈/11-6.png","slug":"11-6.png","post":"cj1lk6ec3000syouafgunqzqu","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-11-执行上下文栈/11-7.png","slug":"11-7.png","post":"cj1lk6ec3000syouafgunqzqu","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-11-执行上下文栈/11-8.png","slug":"11-8.png","post":"cj1lk6ec3000syouafgunqzqu","modified":0,"renderable":0},{"_id":"source/_posts/2017-04-17-深入理解javascript原型和闭包-11-执行上下文栈/11-9.png","slug":"11-9.png","post":"cj1lk6ec3000syouafgunqzqu","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cj1lk6eac0008youarpkwhfhh","category_id":"cj1lk6e9q0004youa6ffk4md0","_id":"cj1lk6eax000eyouaeo5wnefl"},{"post_id":"cj1lk6e8u0000youamvfl9a7x","category_id":"cj1lk6e9q0004youa6ffk4md0","_id":"cj1lk6eb4000iyoua90mio51s"},{"post_id":"cj1lk6eak000ayouahdlqrw5i","category_id":"cj1lk6e9q0004youa6ffk4md0","_id":"cj1lk6ebn000kyoua4a0th9kw"},{"post_id":"cj1lk6ear000dyouanp1nuhby","category_id":"cj1lk6e9q0004youa6ffk4md0","_id":"cj1lk6eby000oyouaqnqm84tp"},{"post_id":"cj1lk6e9g0002youanv8y5pql","category_id":"cj1lk6e9q0004youa6ffk4md0","_id":"cj1lk6ec2000ryoua70f556fs"},{"post_id":"cj1lk6eaz000fyoua1wo63mqw","category_id":"cj1lk6e9q0004youa6ffk4md0","_id":"cj1lk6ec7000vyouajiezfw4g"},{"post_id":"cj1lk6eb6000jyouaosyp2ywy","category_id":"cj1lk6e9q0004youa6ffk4md0","_id":"cj1lk6ece000yyoua07w9lc06"},{"post_id":"cj1lk6ea30006youa91z70jag","category_id":"cj1lk6e9q0004youa6ffk4md0","_id":"cj1lk6ecq0012youazroe0zcw"},{"post_id":"cj1lk6ebq000lyouazfpxlbmv","category_id":"cj1lk6e9q0004youa6ffk4md0","_id":"cj1lk6ecy0015youaxvnt7ks6"},{"post_id":"cj1lk6ebz000pyoua46g2hjbk","category_id":"cj1lk6e9q0004youa6ffk4md0","_id":"cj1lk6ed40019youahhrm0bcf"},{"post_id":"cj1lk6ec3000syouafgunqzqu","category_id":"cj1lk6e9q0004youa6ffk4md0","_id":"cj1lk6edf001cyoua03u8xe6c"},{"post_id":"cj1lk6ec8000wyouauc1065wf","category_id":"cj1lk6e9q0004youa6ffk4md0","_id":"cj1lk6edl001gyoua09dtxuii"},{"post_id":"cj1lk6ecf000zyouansemwoui","category_id":"cj1lk6e9q0004youa6ffk4md0","_id":"cj1lk6edu001jyouatid7d21l"},{"post_id":"cj1lk6ecs0013youayswt32ib","category_id":"cj1lk6e9q0004youa6ffk4md0","_id":"cj1lk6edx001nyouagb8nghbb"},{"post_id":"cj1lk6ecy0016youaeg70g0cq","category_id":"cj1lk6e9q0004youa6ffk4md0","_id":"cj1lk6ee4001pyouaevh7b4su"},{"post_id":"cj1lk6ed5001ayoua9z1d5yre","category_id":"cj1lk6e9q0004youa6ffk4md0","_id":"cj1lk6ee6001syouavox2y986"},{"post_id":"cj1lk6edg001dyoua04q9gm6o","category_id":"cj1lk6e9q0004youa6ffk4md0","_id":"cj1lk6ee8001uyoua66szq6q4"},{"post_id":"cj1lk6edo001hyouahspj0rk1","category_id":"cj1lk6edw001lyoua7hubacwq","_id":"cj1lk6eec001xyouae52m3rgc"}],"PostTag":[{"post_id":"cj1lk6eb6000jyouaosyp2ywy","tag_id":"cj1lk6ea10005youakopp84ev","_id":"cj1lk6ebx000nyouantcymsoh"},{"post_id":"cj1lk6eb6000jyouaosyp2ywy","tag_id":"cj1lk6eao000cyouajpkmqb1x","_id":"cj1lk6ec2000qyouapytao8kb"},{"post_id":"cj1lk6eb6000jyouaosyp2ywy","tag_id":"cj1lk6eb4000hyouagc7hci4e","_id":"cj1lk6ec6000uyoua7t47pdfq"},{"post_id":"cj1lk6e8u0000youamvfl9a7x","tag_id":"cj1lk6ea10005youakopp84ev","_id":"cj1lk6ecd000xyoua1v3vxmld"},{"post_id":"cj1lk6e8u0000youamvfl9a7x","tag_id":"cj1lk6eao000cyouajpkmqb1x","_id":"cj1lk6eco0011youavqv6kr93"},{"post_id":"cj1lk6e8u0000youamvfl9a7x","tag_id":"cj1lk6eb4000hyouagc7hci4e","_id":"cj1lk6ecx0014youan3gveul4"},{"post_id":"cj1lk6ebq000lyouazfpxlbmv","tag_id":"cj1lk6ea10005youakopp84ev","_id":"cj1lk6ed30018youadb8k7kz8"},{"post_id":"cj1lk6ebq000lyouazfpxlbmv","tag_id":"cj1lk6eao000cyouajpkmqb1x","_id":"cj1lk6ede001byouaqanw91mh"},{"post_id":"cj1lk6ebq000lyouazfpxlbmv","tag_id":"cj1lk6eb4000hyouagc7hci4e","_id":"cj1lk6edl001fyoua8a4uwit6"},{"post_id":"cj1lk6ebz000pyoua46g2hjbk","tag_id":"cj1lk6ea10005youakopp84ev","_id":"cj1lk6edt001iyouawclj68lv"},{"post_id":"cj1lk6ebz000pyoua46g2hjbk","tag_id":"cj1lk6eao000cyouajpkmqb1x","_id":"cj1lk6edw001myoua91p3nk0x"},{"post_id":"cj1lk6ebz000pyoua46g2hjbk","tag_id":"cj1lk6eb4000hyouagc7hci4e","_id":"cj1lk6ee2001oyouaw99voai8"},{"post_id":"cj1lk6ec3000syouafgunqzqu","tag_id":"cj1lk6ea10005youakopp84ev","_id":"cj1lk6ee6001ryoua4yt3xbs3"},{"post_id":"cj1lk6ec3000syouafgunqzqu","tag_id":"cj1lk6eao000cyouajpkmqb1x","_id":"cj1lk6ee8001tyouax6qlopa8"},{"post_id":"cj1lk6ec3000syouafgunqzqu","tag_id":"cj1lk6eb4000hyouagc7hci4e","_id":"cj1lk6eeb001wyouajkuefgo9"},{"post_id":"cj1lk6ec8000wyouauc1065wf","tag_id":"cj1lk6ea10005youakopp84ev","_id":"cj1lk6eed001yyouazpvu2srn"},{"post_id":"cj1lk6ec8000wyouauc1065wf","tag_id":"cj1lk6eao000cyouajpkmqb1x","_id":"cj1lk6eee0020youa0f6kpyqb"},{"post_id":"cj1lk6ec8000wyouauc1065wf","tag_id":"cj1lk6eb4000hyouagc7hci4e","_id":"cj1lk6eee0021youaa7n8ij1m"},{"post_id":"cj1lk6ecf000zyouansemwoui","tag_id":"cj1lk6ea10005youakopp84ev","_id":"cj1lk6eef0023youa4cf46zsr"},{"post_id":"cj1lk6ecf000zyouansemwoui","tag_id":"cj1lk6eao000cyouajpkmqb1x","_id":"cj1lk6eeg0024youa8xkuo8qu"},{"post_id":"cj1lk6ecf000zyouansemwoui","tag_id":"cj1lk6eb4000hyouagc7hci4e","_id":"cj1lk6eeh0026youag6gme766"},{"post_id":"cj1lk6ecs0013youayswt32ib","tag_id":"cj1lk6ea10005youakopp84ev","_id":"cj1lk6eeh0027youajc5eutkg"},{"post_id":"cj1lk6ecs0013youayswt32ib","tag_id":"cj1lk6eao000cyouajpkmqb1x","_id":"cj1lk6eei0029youax91rrrpl"},{"post_id":"cj1lk6ecs0013youayswt32ib","tag_id":"cj1lk6eb4000hyouagc7hci4e","_id":"cj1lk6eej002ayouahr63hj3k"},{"post_id":"cj1lk6e9g0002youanv8y5pql","tag_id":"cj1lk6ea10005youakopp84ev","_id":"cj1lk6eel002cyouahhr8k5rg"},{"post_id":"cj1lk6e9g0002youanv8y5pql","tag_id":"cj1lk6eao000cyouajpkmqb1x","_id":"cj1lk6eem002dyouan2zebbyi"},{"post_id":"cj1lk6e9g0002youanv8y5pql","tag_id":"cj1lk6eb4000hyouagc7hci4e","_id":"cj1lk6eem002eyouahghbak8t"},{"post_id":"cj1lk6ecy0016youaeg70g0cq","tag_id":"cj1lk6ea10005youakopp84ev","_id":"cj1lk6eeo002fyouahkhjhy2u"},{"post_id":"cj1lk6ecy0016youaeg70g0cq","tag_id":"cj1lk6eao000cyouajpkmqb1x","_id":"cj1lk6eep002gyoua2mh2xfbk"},{"post_id":"cj1lk6ecy0016youaeg70g0cq","tag_id":"cj1lk6eb4000hyouagc7hci4e","_id":"cj1lk6eep002hyouatspnx5w2"},{"post_id":"cj1lk6ed5001ayoua9z1d5yre","tag_id":"cj1lk6ea10005youakopp84ev","_id":"cj1lk6eeq002iyouaovi8mimv"},{"post_id":"cj1lk6ed5001ayoua9z1d5yre","tag_id":"cj1lk6eao000cyouajpkmqb1x","_id":"cj1lk6eer002jyouasxqxc2en"},{"post_id":"cj1lk6ed5001ayoua9z1d5yre","tag_id":"cj1lk6eb4000hyouagc7hci4e","_id":"cj1lk6eer002kyouasz2tlng7"},{"post_id":"cj1lk6edg001dyoua04q9gm6o","tag_id":"cj1lk6ea10005youakopp84ev","_id":"cj1lk6ees002lyoua46sqoyi2"},{"post_id":"cj1lk6edg001dyoua04q9gm6o","tag_id":"cj1lk6eao000cyouajpkmqb1x","_id":"cj1lk6ees002myoua5hsbksoc"},{"post_id":"cj1lk6edg001dyoua04q9gm6o","tag_id":"cj1lk6eb4000hyouagc7hci4e","_id":"cj1lk6ees002nyoualbqpxtkl"},{"post_id":"cj1lk6ea30006youa91z70jag","tag_id":"cj1lk6ea10005youakopp84ev","_id":"cj1lk6ees002oyouabnmpfbh5"},{"post_id":"cj1lk6ea30006youa91z70jag","tag_id":"cj1lk6eao000cyouajpkmqb1x","_id":"cj1lk6eet002pyoua59z415zg"},{"post_id":"cj1lk6ea30006youa91z70jag","tag_id":"cj1lk6eb4000hyouagc7hci4e","_id":"cj1lk6eet002qyoua3bx7ydk6"},{"post_id":"cj1lk6eac0008youarpkwhfhh","tag_id":"cj1lk6ea10005youakopp84ev","_id":"cj1lk6eeu002ryouar3bp9ffc"},{"post_id":"cj1lk6eac0008youarpkwhfhh","tag_id":"cj1lk6eao000cyouajpkmqb1x","_id":"cj1lk6eeu002syoua77tmkc6q"},{"post_id":"cj1lk6eac0008youarpkwhfhh","tag_id":"cj1lk6eb4000hyouagc7hci4e","_id":"cj1lk6eeu002tyouahcau5gvx"},{"post_id":"cj1lk6eak000ayouahdlqrw5i","tag_id":"cj1lk6ea10005youakopp84ev","_id":"cj1lk6eev002uyoua1s6sh9ju"},{"post_id":"cj1lk6eak000ayouahdlqrw5i","tag_id":"cj1lk6eao000cyouajpkmqb1x","_id":"cj1lk6eev002vyoua3zostq3p"},{"post_id":"cj1lk6eak000ayouahdlqrw5i","tag_id":"cj1lk6eb4000hyouagc7hci4e","_id":"cj1lk6eev002wyouas8j7f6nu"},{"post_id":"cj1lk6ear000dyouanp1nuhby","tag_id":"cj1lk6ea10005youakopp84ev","_id":"cj1lk6eew002xyouax4ydb105"},{"post_id":"cj1lk6ear000dyouanp1nuhby","tag_id":"cj1lk6eao000cyouajpkmqb1x","_id":"cj1lk6eew002yyouau2jpcxai"},{"post_id":"cj1lk6ear000dyouanp1nuhby","tag_id":"cj1lk6eb4000hyouagc7hci4e","_id":"cj1lk6eex002zyouah8n3ohpv"},{"post_id":"cj1lk6eaz000fyoua1wo63mqw","tag_id":"cj1lk6ea10005youakopp84ev","_id":"cj1lk6eex0030youa75znsjh3"},{"post_id":"cj1lk6eaz000fyoua1wo63mqw","tag_id":"cj1lk6eao000cyouajpkmqb1x","_id":"cj1lk6eex0031youal2095te3"},{"post_id":"cj1lk6eaz000fyoua1wo63mqw","tag_id":"cj1lk6eb4000hyouagc7hci4e","_id":"cj1lk6eey0032youady0t1jnl"},{"post_id":"cj1lk6edo001hyouahspj0rk1","tag_id":"cj1lk6eek002byoua0ixv53dd","_id":"cj1lk6eey0033youakd8g39wb"}],"Tag":[{"name":"javascript","_id":"cj1lk6ea10005youakopp84ev"},{"name":"原型链","_id":"cj1lk6eao000cyouajpkmqb1x"},{"name":"闭包","_id":"cj1lk6eb4000hyouagc7hci4e"},{"name":"Hello World","_id":"cj1lk6eek002byoua0ixv53dd"}]}}